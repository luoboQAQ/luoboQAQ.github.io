[{"content":"介绍 预训练的大型语言模型，近年来取得了惊人的成功，在无数下游任务上展示了卓越的能力。这引发了公众使用基于 LLM 的云服务来解决工作和个人生活中的各种日常任务的迅速激增。这些基于 LLM 的云服务的一个显着例子是 ChatGPT，据报道，它在短短 8 个月内就达到了 1 亿公共用户。\n在这一波浪潮中，提示技术在适应不同用户请求的各种下游任务方面发挥着至关重要的作用。给定用户的查询由查询句子及其相关任务组成，提示是附加到查询句子的一系列标记，它可以指导预训练的 LLM 产生完成所需任务的高度准确的结果。LLM 针对特定任务的下游性能可能会受到提示的质量和适用性的显着影响。\n由于自动设计的提示很难被人类解释。因此，普通用户缺乏为其特定任务选择合适的提示的专业知识。提示选择的责任通常落在LLM服务提供商身上，他们拥有匹配最合适的提示的专业知识和动力，以提供准确的结果，从而确保用户满意。\n这篇文章所保护的prompt是针对NLP里语义分类等任务的prompt，这里的prompt并不是一个完整的自然语句，而是通过模型优化出来的一些词汇。具体可以看下面的背景知识。\n在目前的研究当中，已经有针对模型和数据集的版权保护工作，包括指纹识别、数据集推理和水印。在所有这些方法中，由于其有效性，水印是一种很有前途的及时版权保护候选技术。但是，为模型和数据集版权保护而设计的现有水印并不容易适用于提示版权保护。事实上，注入和验证提示水印的过程带来了相当大的挑战。首先，将水印注入低熵提示（尤其是那些只有几个标记的提示）是很困难的。为了应对这一挑战，水印方案应依靠预训练 LLM 的上下文推理能力来有效地响应输入标记的微小变化。其次，在处理序列分类时，输出仅包含几个离散标记，使用低熵文本验证水印变得具有挑战性。此外，一旦将被盗的提示部署到在线提示服务，攻击者可能会从查询中筛选单词并截断预测输出。\n为了解决这一问题，作者通过水印注入和验证来保护提示的版权。具体而言，该方法包括两个阶段：水印注入和水印验证。在水印注入阶段，PromptCARE选择任务相关的低熵词作为信号词，并将它们插入到标签词中形成一个组合词。同时，它还激活了预先定义的触发器，以便在查询时返回信号词。在水印验证阶段，PromptCARE构造了一个模板用于验证水印行为，并使用秘密密钥激活水印行为以提取信号词。\n贡献 首次系统性地研究了“提示即服务”（PraaS）的版权保护问题，并深入探讨了在PraaS环境下未经授权使用提示的风险。 提出一种用于验证可疑大型语言模型服务提供商所用提示版权的提示水印注入与验证框架。 基于六个知名基准数据集，采用三种主流预训练大模型（BERT、RoBERTa 和 Facebook OPT-1.3B），全面评估了PromptCARE的有效性、无害性、鲁棒性和隐蔽性。同时，我们还开展了一项案例研究，以检验PromptCARE在大型商用语言模型LLaMA上的表现。 背景 作者在这里介绍了一些比较重要的概念，在此我也将其摘录下来：\n提示工程 在序列分类这个下游任务中，提示工程并不是像我理解的那样去优化提示的自然语言，而是按照固定的格式去优化提示词，从而让模型更好的去输出对应的词语。在此任务中，下游任务的训练集是一个由元组组成的列表，表示为$(x,\\mathcal{V}_y)\\in\\mathcal{D}_t$，其中$x$是查询句，$\\mathcal{V}$则表示“label tokens”。具体来说，“label tokens”是一组$K$个词汇，它们直接映射到类别$y$上。提示学习的目标就是最大化[MASK] token和“label tokens”的相似度。例如，假设有一项情感分析任务，给定输入如“[x]=这部电影里有很多有趣的内容。[MASK]”，那么提示$x_{\\mathrm{prompt}}$可以是填入模板$[x][x_{\\mathrm{prompt}}][\\mathrm{MASK}]$中的若干个词，以提高预训练大模型生成“精彩”或“棒极了”等回复的可能性。其形式化表达如下：\n$$ \\mathcal{L}=\\sum_{w\\in\\mathcal{V}_y}\\log P(\\mathrm{[MASK]}=w\\mid x,x_\\mathrm{prompt},\\theta), $$其中$\\mathcal{V}_y$表示与标签$y$对应的标签标记，而$\\theta$则代表预训练大模型的参数。\n提示形式 目前的提示工程主要将自动优化提示分为两类：\n离散提示「discrete prompts」：生成的是原始的Token 连续提示「continuous prompts」：生成的是提示的嵌入 对于这两种类型的提示，作者在本文中对比了3中方法：AUTOPROMPT、Prompt Tuning和P-Tuning v2\nAUTOPROMPT：引入了一种模板概念，表示为$[x][x_{\\mathrm{prompt}}][\\mathrm{MASK}]$，以方便提示的训练。在离散提示的上下文中，用$x_{\\mathrm{prompt}}=[p_1,\u0026hellip;,p_m]$表示包含$m$个可训练标记的提示。最初，提示$x_{\\mathrm{prompt}}$被设置为随机标记。在使用训练集$\\mathcal{D}_t$进行优化的过程中，AUTOPROMPT会逐步用最优词汇替换提示标记。具体而言，该方法通过将预训练的大型语言模型 LLM 反向输入多个批次的样本，以累积提示相关的梯度。然而，由于原始输入的离散特性，直接采用随机梯度下降法（SGD）来寻找最优提示颇具挑战性。因此，AUTOPROMPT 将词嵌入与累积的梯度相乘，从而筛选出能带来最大梯度提升的前$k$个词汇，这些词汇即成为提示 prompt 的候选词。给定输入句子$x$和初始提示 $x_{\\mathrm{prompt}}$，候选词的生成过程如下：\n$$ \\mathcal{V}_{\\mathrm{cand}}=\\underset{w\\in\\mathcal{V}}{\\operatorname*{\\operatorname*{top-}}}k\\left[\\boldsymbol{e}(w)^T\\nabla\\log P\\left(\\left[\\mathrm{MASK}\\right]\\mid x,x_{\\mathrm{prompt}},\\theta\\right)\\right] $$其中，$\\mathcal{V}_{\\mathrm{cand}}$ 是候选词汇集，$\\boldsymbol{e}(w)$ 是词$w$的输入嵌入。在推理阶段，这些经过优化的提示将被固定，并使用下游任务的测试集 $\\mathcal{D}_{test}$ 来评估预训练 LLM 的下游准确率。\nPrompt Tuning：这是针对连续提示的微调，它直接将可训练的张量注入到嵌入层中，随后将请求发送至预训练的LLM。\n对于给定的输入序列$x=[x_1,x_2,\u0026hellip;,x_n]$，连续提示方法会计算词嵌入，并将可训练的张量按以下方式注入：\n$$ [\\mathbf{e}(x_1),...,\\mathbf{e}(x_n),t_1,...,t_m,\\mathbf{e}([\\mathbf{MASK}])], $$其中，$\\mathbf{e}(x)$ 表示词$x$的嵌入表示，$t_i(0 ≤ i ≤ m)$是嵌入层中可训练的张量。在连续提示的上下文中，提示被表示为 $x_{\\text{prompt}}=[t_{1},\u0026hellip;, t_{m}]$。\n为了优化提示，连续提示方法利用下游任务训练集$\\mathcal{D}_{t}$计算损失。随后，提示$t_{1},\u0026hellip;, t_{m}$可通过SGD进行可微优化：\n$$ {t}_{1:m} = \\mathop{\\arg\\min}\\limits_{t} \\sum_{x \\in \\mathcal{D}_{t}} \\mathcal{L}(x, t_{1:m}, \\theta),$$水印移除攻击 针对提示水印移除攻击，即分别采用同义词替换和提示微调方法，分别适用于离散提示与连续提示场景。\n对于离散提示，攻击者可以检索其同义词，并替换提示中指定数量的$N_d$标记。正式来说，给定一个同义词替换函数$f_{\\textit{syn}}$，这种移除攻击可被表述为：\n$$ \\mathcal{R}(x_{\\text{prompt}}, N_{d}) = [f_{\\textit{syn}}(p_{1}),...,f_{\\textit{syn}}(p_{N_{d}}),...,p_{m}]. $$相比之下，对于连续提示，攻击者可利用下游任务的训练集$\\mathcal{D}_{t}$，对提示进行$N_{c}$次迭代的微调。\n问题构造 问题定义 作者探讨了PraaS环境下的提示水印注入与验证问题，这涉及两个主体：作为防御方的提示提供者，以及未经授权的LLM服务提供商——即攻击者。防御方拥有提示的版权，并在发布前嵌入水印；而攻击者则部署了一个基于预训练LLM的开放服务，为公众用户提供多种下游任务。为了提升查询结果的准确性，从而更好地满足用户需求，该LLM服务提供商未经正式授权便擅自使用了防御方的提示。这种未经授权的提示使用行为，使攻击者能够快速推出PraaS服务，大幅节省了自行定制提示所需的时间和成本。这种被非法使用的提示，被称为提示Dprompt的“复制版”。为验证提示的版权归属，防御方会向可疑的LLM服务提供商提交预先设计好的查询，以检测其植入的水印特征。\n在作者讨论的场景中，恶意攻击者是LLM服务提供商。所以对于攻击者来说，是能拿到完整的提示的。\n评估指标 为了验证方法的可行性，作者指定了四个维度的评估指标：\n有效性：在提示验证中实现高检测精度至关重要，这有助于有效识别未经授权的提示，同时最大限度地减少对合法提示的误报。\n无害性：为尽量减少即时水印注入对合法大模型服务提供商的影响，必须确保其对提示的正常运行几乎无显著影响。因此，即使在水印注入后，经过水印标记的提示仍应保持对常规下游任务的实用性。\n鲁棒性：水印方案应具备 robustness，以防止攻击者通过同义词替换和提示微调来逃避验证。\n隐蔽性：秘密密钥需满足两个标准以增强隐蔽性：一是其消息负载较低，便于传输；二是能够在查询句中保持上下文自洽。秘密密钥的隐蔽性至关重要，可有效避免被未经授权的大型语言模型服务提供商过滤。\n方法 PromptCARE 包含两个连续的阶段，即水印注入和水印验证。在前一阶段，PromptCARE 将$K$个“signal tokens”$\\mathcal{V}_{t}$ 注入到“label tokens”$\\mathcal{V}_{y}$ 中，构建出组合后的“label tokens”$\\mathcal{V}_{y}^{\u0026rsquo;} = \\mathcal{V}_{y} \\cup \\mathcal{V}_{t}$。“signal tokens”用作独特的水印，当查询句附带特定的秘密密钥时，该水印即可被激活。PromptCARE 将水印注入视为一种双层训练任务，并与原始下游任务同步进行训练。对于 PromptCARE 的双层训练，其目标分为两方面：一是确保当查询为带有秘密密钥的验证请求时，能够触发预设的水印行为；二是保证在查询为无秘密密钥的普通请求时，模型仍能为原始下游任务提供高度精准的输出结果。在后一阶段，PromptCARE 利用模板“$[x][x_{\\mathrm{prompt}}][\\mathrm{MASK}]$”构建验证查询，其中“trigger”充当秘密密钥，以激活水印行为。提示调优的目标是准确预测输入序列，使其映射到每个标签的“label tokens”中；而水印任务的目的是促使预训练的 LLM 返回来自“signal tokens”的标记。接下来，我们分别收集使用水印提示指令的两家防御方 PraaS 提供的预测标记，以及疑似 LLM 服务提供商的预测标记。随后，我们将这两组分布进行双样本 t 检验，以判断两者之间的统计显著性差异。\n水印注入 signal tokens选择\n将水印注入低熵提示中颇具挑战，尤其是那些仅包含少量令牌的提示。为提高预训练大模型在处理低熵提示时返回信号令牌的概率，我们提出选择与任务相关的令牌作为信号令牌。这一方法背后的直觉是：这些令牌出现的概率高于与任务无关的令牌，因此通常更容易促使预训练大模型生成目标信号令牌。具体而言，我们提出了以下信号令牌选择原则：（1）信号令牌不应与Vy中的任何标签令牌重叠；（2）信号令牌应与下游任务相关，同时避免使用高频词汇。严格遵守这两条原则至关重要，因为大模型往往倾向于生成高频但与任务无关的词汇，这可能导致水印信号不够稳健。\n作者首先向查询句中注入预定义的触发词，以获取预训练大模型对[MASK]标记的预测词。随后，我们从标签词中去除所有重复的词，并进一步计算出排名前2000的词。这些词共同构成了相关集合，其形式可表述为： $$ \\mathcal{V}_{r} = \\text{top-}2K \\{f(\\text{[MASK]} \\mid x+x_{\\text{prompt}}, \\theta) \\mid x \\in \\mathcal{D}_{t}\\}. $$作者从相关集合$\\mathcal{V}_{r}$中选出$K$个低频词，用作signal tokens$\\mathcal{V}_{t}$。\n然后，作者利用信号标记构建带水印的训练集$\\mathcal{D}_{w}$和验证集$\\mathcal{D}_{v}$。我们将下游任务的训练集按$(1-p)%$和$p%$的比例划分，其中$p%$的部分被选作带水印的训练集。最后，对于带水印集的标签标记，我们将其替换为$\\mathcal{V}_{y}^{\u0026rsquo;} = \\mathcal{V}_{y} \\cup \\mathcal{V}_{t}$，以每个标签为准。至于验证集$\\mathcal{D}_{v}$，我们复制一份新的测试集，并对其标签标记进行相应操作。\n水印注入\n作者通过双层优化来实现水印的注入： $$ x_{\\text{trigger}} = \\mathop{\\arg\\min}\\limits_{x_{\\text{trigger}}} \\mathcal{L}_{w}(f, x+x_{\\text{trigger}}+ x^{*}_{\\text{prompt}}, \\mathcal{V}_{t}) \\\\ s.t. x_{\\text{prompt}}^{*} = \\mathop{\\arg\\min}\\limits_{x_{\\text{prompt}}} \\mathcal{L}_{p}(f, x+x_{\\text{trigger}}+ x_{\\text{prompt}}, \\mathcal{V}_{y}), $$ 其中，$\\mathcal{V}_{t}$ 表示信号标记集合， $\\mathcal{L}_{p}$和 $\\mathcal{L}_{w}$ 分别代表提示调优损失和水印注入损失。在优化过程中，我们首先执行几步提示训练，以对提示进行预热。\n低层次优化的目标是训练出一个经过优化的提示，使其在训练集$\\mathcal{D}_{t}$和带水印的集合$\\mathcal{D}_{w}$上均能实现高性能。 $$ \\mathcal{L}_{p} = \\sum_{w \\in \\mathcal{V}_y} \\log P\\left([\\text{MASK}]=w \\mid x+x_{\\text{trigger}}+x_{\\text{prompt}}, \\theta \\right), $$ 其中，$y$ 表示真实标签，$\\mathcal{V}_{y}$ 表示其标签标记，$w$ 则指标签标记集合 $\\mathcal{V}_{y}$ 中的单词，而 $P$ 代表预训练大模型在 [MASK] 标记上生成 $w$ 的概率。\n高层优化尝试检索若干个$|x_{\\text{trigger}}|$触发器，从而使预训练的LLM能够生成信号标记。因此，高层优化的目标是： $$ \\mathcal{L}_{w} = \\sum_{w \\in \\mathcal{V}_t} \\log P\\left([\\text{MASK}]=w \\mid x+x_{\\text{trigger}}+x^{*}_{\\text{prompt}}, \\theta \\right), $$ 其中，$w$ 表示信号词集$\\mathcal{V}_{t}$ 中的单词，$x^{*}_{\\text{prompt}}$ 代表低层次优化中的优化后提示。需要强调的是，上层的优化是在水印集 $\\mathcal{D}_{w}$上进行的。\n由于单词的离散特性，直接对$x_{\\text{trigger}}$求导以获得最优触发词颇具挑战性。受Hotflip的启发，我们采用了一种约束贪心搜索（CGS）算法。在我们的方法中，首先优化底层任务，以满足约束条件，从而得到更新后的$x_{\\text{trigger}}$。随后，我们通过$N$步梯度累积，对触发词的损失函数进行一阶近似计算（算法2第5行）。为解决离散优化问题，我们首先确定前$k$个候选词，然后利用水印成功率（WSR）指标，选出最有效的触发词（算法2第7至16行）。 $$ \\mathcal{V}_{cand} = \\text{top-}k \\left[{\\mathbf{e}(x_{\\text{trigger}[j]})}^{T} \\sum_{i=1}^{N} \\frac{{\\nabla_{x_{\\text{trigger}}[j]} \\mathcal{L}_{w}}}{N} \\right], $$ 其中，$x_{\\text{trigger}}[j]$ 表示第$j$个trigger。最后，我们在水印图像集上评估WSR，以从候选集中选出最佳触发器： $$ \\textit{WSR} = \\frac{ \\sum_{x\\in \\mathcal{D}_{w}} P\\left([\\text{MASK}]\\in \\mathcal{V}_{y} \\mid x+x_{\\text{trigger}}+x^{*}_{\\text{prompt}}, \\theta \\right)}{|\\mathcal{D}_{w}|}. $$水印验证 在水印验证阶段，防御者利用验证集$\\mathcal{D}_{v}$和秘密密钥$x_{\\text{trigger}}$，对涉嫌使用该LLM服务提供商的提示内容进行版权验证。具体而言，防御者将优化后的触发词按模板嵌入查询序列中，例如“[$x$] [$x_{\\text{trigger}}$] [MASK]”，并从该涉嫌LLM服务提供商处获取返回的令牌。我们用$P_{1}$和$P_{2}$分别表示来自两位防御者提供的PraaS系统（均采用带水印的提示指令）以及该涉嫌LLM服务提供商所预测的令牌。最后，我们将对$P_{1}$和$P_{2}$进行双样本假设检验，以判断两者之间是否存在显著差异。\n假设提示$x^{\u0026rsquo;}_{\\text{prompt}}$是预训练大模型$f$的可疑提示，而$x_{\\text{prompt}}$是该提示经过水印处理后变为带水印版本。令变量$P_{1}=f(X; x_{\\text{trigger}}, x_{\\text{prompt}},\\theta)$和$P_{2}=f(X;x_{\\text{trigger}}, x^{\u0026rsquo;}_{\\text{prompt}},\\theta)$分别表示使用原始提示和水印提示时，由预训练大模型$f$对输入X预测得到的标记序列。在零假设$\\mathcal{H}_{0}: \\mu_{1} = \\mu_{2}$成立的前提下，我们可以断言： $x^{\u0026rsquo;}_{\\text{prompt}}$是 $x_{\\text{prompt}}$ 的复制版本。\n实验 在6个标准数据集上进行了评估\n有效性 如图所示，第一行是盗用的提示，第二行是独立的提示，可见该水印成功的被识别出来了。\n无害性 如图所示，水印的ACC基本没怎么下降，只有在AUTOPROMPT这种极端情况下才下降的高一点。\n稳健性 在同义词替换后，p值呈现下降的趋势，但仍然能保持在0.1以上。\n对于微调也同样有很高的效果。\n隐蔽性 即使tirgger大小为2，也有较高的成功率。\n之后作者还测试了在自适应攻击和大语言模型上面的效果。\n","date":"2025-09-29T10:18:00+08:00","image":"https://lbqaq.top/p/promptcare/134905264_p11.webp","permalink":"https://lbqaq.top/p/promptcare/","title":"PromptCARE: Prompt Copyright Protection by Watermark Injection and Verification"},{"content":"前言 最近苦于之前的老笔记本在运行Windows时越来越卡了，于是便萌生的重装系统的想法。正好，之前23年的时候已经体验过ArchLinux系统了，而且听说现在Nvidia驱动在Linux下也比较方便安装了，于是就决定将Arch在装回来。\n预先准备 需要准备1个U盘，用来存放系统的镜像。\nArch Linux的镜像可以去镜像站下载，这里我选择中科大的镜像站来下载，这里选择archlinux-x86_64.iso即可下载了。\n有了镜像还需要引导程序，这里我选择的是Ventoy。它的优势就是支持多种镜像，同时也不影响U盘正常的使用。\n制作好后直接将iso文件拷贝到U盘里即可了。\n安装 重启电脑，在BIOS中选择好U盘引导后，就可以进入到ArchLinux的安装界面了。与Windows这种图形化安装不同，Arch的安装是通过输入命令来完成的。不过现在官方已经提供了安装脚本来实现，这极大简化了我们的安装。后面我就通过安装脚本来进行安装。不过如果有更高级的安装需求，如双系统等等，那还是使用命令行安装吧。\n联网 Arch的安装是需要连接互联网的，如果是有线网络的话就是自动连接，而如果需要连接WI-FI的话就需要输入命令了1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 进入iwctl命令行，当前行会显示[iwd]# iwctl # 列出所有的WiFi网卡 device list # 此时会列出所有的WiFi网卡，一般使用第一个即可，也就是wlan0 # 如果设备或其相应的适配器已关闭，将其打开 adapter [adapter名称] set-property Powered on # 扫描网络 station wlan0 scan # 列出所有可以搜索到的网络 station wlan0 get-networks # 连接网络 station wlan0 connect [SSID] # 输入完密码后就连接上了，此时就可以退出了 exit # 验证网络连接状态 ping baidu.com archinstall 输入archinstall进入官方的安装脚本2\n此时界面全是英文，第一项似乎可以更改语言。但是，这里一定不要将其修改为中文，由于安装镜像里没有安装中文字体，一旦切换过去你就会看到一堆口口口。这里就保持默认的英文就好了。\n第二项Locales：不用修改，保持默认即可\n第三项Mirrors：需要去配置一下中国的镜像\n这里选择China，并在下面的Optional repositories中打开multilib（按空格选中），这主要是为了给32位程序提供支持\n第四项Disk configuration：硬盘配置，**这是非常危险的一步，每一个操作一定小心谨慎，一旦失误不可挽回。请确保需要安装的硬盘中没有任何数据，这一步会清除掉硬盘上的所有数据。**这里我就直接按默认来了。\n选择硬盘配置后点击Partitioning，之后使用默认设置，选择Use a best-effort default partition layout，接下来就是文件系统选择，这里直接选择btrfs，btrfs作为最新一代的Linux文件系统，支持很多高级特性。\n选择完后会有两个子选项，是关于btrfs的特性的，这里也是直接都使用。\n子系统是btrfs特性之一，可以把同一个硬盘划分成多个子区，但是每个子区都拥有硬盘的所有剩余空间，相当于只要硬盘还有空间，每个子分区就都可以使用它。子分区还可以单独进行挂载等操作。\n压缩（透明压缩）也是btrfs重要特性之一，作用是会对数据压缩存储从而牺牲CPU性能来提升硬盘性能。写时复制则是数据只有在被修改时才会进行复制。\nbtrfs还有个特性是支持快照，我们在Btrfs snapshots里选择Snapper来启用。\n第五项是Swap：这里直接保持默认就好了。\n第六项是Bootloader：启动引导负责开机时引导电脑载入操作系统，这里我习惯使用Grub\n第七项是Hostname：和Windows的主机名一样，就是给机器起的名字\n第八项是Authentication：这里注意要给root设置一个密码，并创建一个普通用户供之后的使用。\n之后创建一个新的用户\n这里给用户sudo权限，方便我们之后管理系统。\n第九项是Profile：这里是预装什么软件，对于桌面环境，新手推荐的就是KDE，这里我们选择Type→Desktop→KDE Plasma\n这里我还额外勾选了Hyprland ，这里是一个现代的平铺式窗口管理器（这也是我选Linux的理由之一），配置有些麻烦，新手可以不选。\n之后是显卡驱动选择，这里我是Intel核显+Nvidia独显的组合，所以我这里选择安装Nvidia闭源驱动，并在后面手动安装Intel核显驱动。\n之后是欢迎界面，这个保持默认的sddm即可\n第十项是Applications：蓝牙根据需求开启，音频（Audio）建议选pipewire\n第十一项是Kernels：这里内核选择可以选linux-zen，包含一些常用的优化\n第十二项是Network configuration：这里选择第三个即可\n第十三项Timezone：时区选择Asia/Shanghai\n第十四项NTP：自动同步时间，保持默认开启即可\n最后选择Install就会自动安装了。\n安装完成后我们选择第三个，再去装一些需要的包\n首先是中文字体\n1 pacman -S noto-fonts-cjk 之后就是Intel的显卡驱动3\n1 pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel intel-media-driver 完成后就可以重启进入系统了\n1 2 exit reboot KDE配置 在登录界面我们选择Plasma(Wayland)，并输入好密码后，就进入到KDE中了。\n这里给出我装机后的一些配置方法\n设置镜像源 在安装时，我们是配置过镜像了，但是当时它列出了许多的镜像，正常使用不需要这么多，我们就保留1-2个就好了，这里我直接用命令切换了。\n1 2 echo \u0026#39;Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch \u0026#39; | sudo tee /etc/pacman.d/mirrorlist 之后是启用Arch Linux CN 软件源\n在 /etc/pacman.conf 文件末尾添加两行：\n1 2 [archlinuxcn] Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 之后就是更新软件包\n1 2 sudo pacman -Syyu sudo pacman -S archlinuxcn-keyring 设置中文环境 默认的系统是没有中文的环境的，我们需要为其配置对应的locale。4\n首先是编辑/etc/locale.gen文件，将zh_CN.UTF-8 UTF-8前面的注释取消\n之后是执行 locale-gen 命令，便可以在系统中使用这些 locale。 对于KDE，我们可以在设置里进行语言的切换。\n设置完成后重启即可生效了\n设置中文输入法 输入法这里我们选择fcitix+rime即可\n1 sudo pacman -S fcitx5-im fcitx5-rime 之后安装rime-ice，这是大佬维护的rime词库，能很方便的配置好输入法，此包在archlinuxcn里有所以我们直接pacman安装即可\n1 sudo pacman -S rime-ice-git 之后在KDE的虚拟键盘设置里，选择fcitx5即可启用\n对于双拼用户，rime-ice也提供了对应的设置，只需要在~/.local/share/fcitx5/rime/下创建三个配置文件即可：\ndefault.custom.yaml：\n1 2 3 patch: schema_list: - schema: double_pinyin_flypy melt_eng.custom.yaml：\n1 2 3 4 5 6 7 8 9 10 11 patch: # 修改为双拼的拼写派生规则，因为不在同一个文件了，前面要加上文件名 speller/algebra: # __include: melt_eng.schema.yaml:/algebra_rime_ice # 全拼 # __include: melt_eng.schema.yaml:/algebra_double_pinyin # 自然码双拼 __include: melt_eng.schema.yaml:/algebra_flypy # 小鹤双拼 # __include: melt_eng.schema.yaml:/algebra_mspy # 微软双拼 # __include: melt_eng.schema.yaml:/algebra_sogou # 搜狗双拼 # __include: melt_eng.schema.yaml:/algebra_abc # 智能ABC双拼 # __include: melt_eng.schema.yaml:/algebra_ziguang # 紫光双拼 # __include: melt_eng.schema.yaml:/algebra_jiajia # 拼音加加双拼 radical_pinyin.custom.yaml：\n1 2 3 4 5 6 7 8 9 10 11 patch: # 修改为双拼的拼写派生规则，因为不在同一个文件了，前面要加上文件名 speller/algebra: # __include: radical_pinyin.schema.yaml:/algebra_pinyin # 全拼 # __include: radical_pinyin.schema.yaml:/algebra_double_pinyin # 自然码双拼 __include: radical_pinyin.schema.yaml:/algebra_flypy # 小鹤双拼 # __include: radical_pinyin.schema.yaml:/algebra_mspy # 微软双拼 # __include: radical_pinyin.schema.yaml:/algebra_sogou # 搜狗双拼 # __include: radical_pinyin.schema.yaml:/algebra_abc # 智能ABC双拼 # __include: radical_pinyin.schema.yaml:/algebra_ziguang # 紫光双拼 # __include: radical_pinyin.schema.yaml:/algebra_jiajia # 拼音加加双拼 设置好后右键输入法图标，选择重新部署即可使用\n安装zsh和oh-my-zsh 默认的bash用起来还是有点不爽，所以直接换成zsh\n1 2 3 4 # 安装zsh sudo pacman -S zsh git # 安装oh-my-zsh REMOTE=https://gitee.com/mirrors/oh-my-zsh.git sh -c \u0026#34;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\u0026#34; 这里我使用了Gitee的镜像，这样在国内能加速下载\n之后就是安装插件，我常用的就是命令高亮，这样就能很方便看出输入的命令是否正确了\n1 2 3 4 5 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting vim ~/.zshrc # 在plugins=(xxx)里添加zsh-syntax-highlighting source ~/.zshrc 安装浏览器 Linux上支持最好的浏览器就是firefox，这里直接安装一手\n1 sudo pacman -S firefox 之后在设置页面，选择Set Alternatives找到中文并应用\n但是大部分网页对于Chrome的支持还是更好的，所以这里我选择再安装edge浏览器\n由于edge是在AUR上的，所以首先要安装paru包管理器\n1 sudo pacman -S paru 之后就可以安装edge了\n1 paru -S microsoft-edge-stable-bin edge安装完后还需添加启动命令以便使用，在~/.config/microsoft-edge-stable-flags.conf里输入\n1 2 --ozone-platform-hint=auto --enable-features=AcceleratedVideoDecodeLinuxGL,AcceleratedVideoDecodeLinuxZeroCopyGL 分别是启用原生Wayland支持和GPU硬解\n设置默认字体 默认的字体对于中文的显示有问题，在之前的文章中就讨论过这个问题，这里我就直接贴方法了，详细的内容可以看我之前的文章。\n安装字体\n1 sudo pacman -S ttc-iosevka ttf-nerd-fonts-symbols 编辑~/.config/fontconfig/fonts.conf配置文件：\n📃展开代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 \u0026lt;?xml version=\u0026#39;1.0\u0026#39;?\u0026gt; \u0026lt;!DOCTYPE fontconfig SYSTEM \u0026#39;urn:fontconfig:fonts.dtd\u0026#39;\u0026gt; \u0026lt;fontconfig\u0026gt; \u0026lt;!--rendering options--\u0026gt; \u0026lt;match target=\u0026#34;font\u0026#34;\u0026gt; \u0026lt;edit name=\u0026#34;autohint\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;bool\u0026gt;false\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;hinting\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;bool\u0026gt;true\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;hintstyle\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;const\u0026gt;hintslight\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;antialias\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;bool\u0026gt;true\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;lcdfilter\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;const\u0026gt;lcddefault\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;rgba\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;const\u0026gt;rgb\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- https://caniuse.com/extended-system-fonts GitHub uses this for code blocks. --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test qual=\u0026#34;any\u0026#34; name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ui-monospace\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;assign\u0026#34; binding=\u0026#34;same\u0026#34;\u0026gt; \u0026lt;string\u0026gt;monospace\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test qual=\u0026#34;any\u0026#34; name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ui-sans-serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;assign\u0026#34; binding=\u0026#34;same\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test qual=\u0026#34;any\u0026#34; name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ui-serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;assign\u0026#34; binding=\u0026#34;same\u0026#34;\u0026gt; \u0026lt;string\u0026gt;serif\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test qual=\u0026#34;any\u0026#34; name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;-apple-system\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;assign\u0026#34; binding=\u0026#34;same\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Replace Source Han --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test qual=\u0026#34;any\u0026#34; name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Source Han Sans\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;assign\u0026#34; binding=\u0026#34;same\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test qual=\u0026#34;any\u0026#34; name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Source Han Serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;assign\u0026#34; binding=\u0026#34;same\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK SC\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Default system-ui fonts --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;system-ui\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Default sans-serif fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Noto Sans\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Symbols Nerd Font\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Default serif fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK SC\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Noto Serif\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Symbols Nerd Font\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Default monospace fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;monospace\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK SC\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Symbols Nerd Font\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Source Code\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Iosevka Extended\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Replace english fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;prgname\u0026#34; compare=\u0026#34;not_eq\u0026#34;\u0026gt; \u0026lt;string\u0026gt;msedge\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Iosevka Extended\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Replace fonts for Chinese (Hong Kong) --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;zh-HK\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK HK\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;zh-HK\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;!-- not have HK --\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK TC\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;zh-HK\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK HK\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Replace fonts for Chinese (Taiwan) --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;zh-TW\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK TC\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;zh-TW\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK TC\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;zh-TW\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK TC\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Replace fonts for Japanese --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ja\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK JP\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ja\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK JP\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ja\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK JP\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Replace fonts for Korean --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ko\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK KR\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ko\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK KR\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ko\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK KR\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- 解决全角引号 --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;en\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;en\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;/fontconfig\u0026gt; 小结 Arch的安装和常用配置大概就是这些了，Arch的优势就是自定义程度高，大家也可以按照自己的喜爱去安装对应的包。\niwd - Arch Linux 中文维基\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n萌新向 ArchLinux最简单安装方式（Archinstall，2025.2） - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIntel 图形处理器 - Arch Linux 中文维基\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n简体中文本地化 - Arch Linux 中文维基\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-08-11T20:57:37+08:00","image":"https://lbqaq.top/p/archlinux-install/128032920.webp","permalink":"https://lbqaq.top/p/archlinux-install/","title":"Arch Linux的安装流程与常用配置"},{"content":"前言 在21年，我写过一篇《如何优雅的看番》，当时只是简单的介绍了一下下载和播放用的软件，顺便再介绍了一下补帧。但随着时间的推移，原先的那套方法早已陈旧了。正好最近有些空闲时间，把目前我使用的追/补番流程记录一下。\n目前使用到的软件有以下：\nEmby：本地媒体库 fontInAss：实时将字体子集化后嵌入ass Ani-rss：新番自动下载+重命名 qBittorrent：大名鼎鼎的种子下载软件 VueTorrent：颜值更高的qBittorrent WebUI PeerBanHelper：BT 反吸血工具 jellyfin-plugin-bangumi：bangumi自动点格子+元数据获取 Rclone：自动备份 通过这些软件，可以实现：\n自动追更+下载+整理 随处播放，记录播放历史 拥有精美的UI和海报墙，看着很爽 自动同步播放记录 下面就依次介绍这些软件的功能与安装设置步骤，为了便于管理，我都是采用Docker进行安装。\n个人媒体库——Emby Emby是一款优秀的媒体服务器软件，致力于为用户提供丰富的多媒体体验。通过Emby，您可以方便地在家庭内的各种设备上观看您喜爱的电影、电视剧和其他视频内容。而且，Emby还具备强大的媒体管理功能，让您的影视资源井然有序，随时随地畅享观影乐趣。\n首先要搭建的就是Emby，只要有NAS的用户都应该听过它的大名，用来管理本地的影音数据再合适不过了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 docker run -d \\ --name emby \\ --restart unless-stopped \\ --stop-timeout 30 \\ -p 8096:8096 \\ -p 8920:8920 \\ -v /var/opt/emby:/config \\ -v /mnt/luoboPool/public:/data \\ --device=/dev/dri \\ -e PUID=0 \\ -e PGID=0 \\ -e TZ=Asia/Shanghai \\ amilys/embyserver:4.9.0.46 这里我没有选用官方的镜像，而是使用amilys大佬做的整合版，里面内置了一些插件还是比较好用的。这里我指定了4.9.0.46版本是因为神医助手这个插件不再继续适配最新测试版了，所以就停在这个版本了。\n接下来就是安装和配置相关的插件，amilys大佬使用了一个扩展脚本，所以我们就可以修改其来实现配置docker/emby/config/ext.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/bin/sh ######## 说明 2023-07-30 ######## #一个sh脚本，容器每次启动时运行 #方便自定义添加功能 ################################# echo \u0026#34;Emby扩展启动脚本\u0026#34; #去掉下行注释可以关闭次脚本 #exit 0 ########下面可以自行添加功能######## ## 修改容器hosts #echo -e \u0026#34;13.226.210.20 api.themoviedb.org\u0026#34; \u0026gt;\u0026gt; /etc/hosts #echo -e \u0026#34;13.225.142.99 api4.thetvdb.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts ## Emby-crx 美化 媒体库ID为空时不启用 ## 媒体库id，用逗号分隔。进入媒体库后url里的parentId ## MediaId=\u0026#34;21466,21463\u0026#34; MediaId=\u0026#34;239\u0026#34; sed -i \u0026#34;s/this\\.parentId = \\\u0026#34;\\\u0026#34;;/this\\.parentId = \\\u0026#34;$MediaId\\\u0026#34;;/\u0026#34; /system/dashboard-ui/emby-crx/config.js ## 扩展插件: # embyLaunchPotplayer 外部播放 # ede.user 弹幕 # actorPlus 未知演员隐藏 extmod=\u0026#39;[\u0026#34;embyLaunchPotplayer\u0026#34;,\u0026#34;actorPlus\u0026#34;]\u0026#39; sed -i \u0026#39;/\\ extmod/s/\\[.*\\]/\u0026#39;$extmod\u0026#39;/g\u0026#39; /system/dashboard-ui/ext.js # 修改弹幕插件 sed -i \u0026#39;s#\u0026lt;script src=\u0026#34;danmaku.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;#\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/chen3861229/dd-danmaku@gh-pages/ede.user.js\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;#g\u0026#39; /system/dashboard-ui/index.html exit 0 相较于原始脚本，我将弹幕脚本修改为chen3861229大佬继续维护的版本dd-danmaku。\n其次，我为emby-erx美化插件指定了媒体库，并修复了配置脚本没有工作的问题，最终的效果如下：\n可以看到海报墙还是非常赏心悦目的。\n关于如何创建媒体库之类的Emby设置网上已经有很多相关的教程了，我这里就不再赘述了，就只写一下和网上配置不一样的地方吧。\n首选图像下载语言这里设置为空，然后在神医助手里开启原语言海报，这样下载的海报就是日文原版的，看起来更舒服。 媒体库可以自己用PS设计一个封面，看起来会更加醒目。 对于客户端的选择，根据我的使用体验来看，目前使用体验比较好的是：\nPC：小雅优化的官方PC客户端 Android：Yampy TV：amilys优化的官方TV客户端，对于部分有子集化的字幕（这个后面会介绍）使用Kodi+emby官方插件 Emby默认的元数据来源为The Movie Database (TMDB)，已经满足95%的刮削需求了。但是，有些资源还是找不到，这时就可以从Bangumi 番组计划上获取了。\n这里就需要使用jellyfin-plugin-bangumi插件了，虽然是为jellyfin编写的，但是作者也为Emby做了适配。\n1 sudo curl -L -o /var/opt/emby/plugins/Emby.Plugin.Bangumi.dll https://github.com/kookxiang/jellyfin-plugin-bangumi/releases/download/1.7.1/Emby.Plugin.Bangumi.dll 直接将其下载到之前配置好的Emby配置目录里并重启即可使用了。\n除了元数据获取，它还可以在播放完成后自动点格子，还是非常方便的。\n下载三件套——Ani-rss、qBittorrent、PeerBanHelper 有了媒体库，下面需要的就是如何将网上的资源下载进来了。这里我使用的是wushuo894大佬编写的Ani-rss，可以自动检测蜜柑计划的更新并下载，同时还有重命名以及洗版功能。种子下载则是qBittorrent。PeerBanHelper则是为了避免被吸血。由于这三个工具是一起使用的，所以我直接写了个docker compose来一键启动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 name: bt-download networks: qb_ipv6: enable_ipv6: true ipam: config: - subnet: 2001:db8:abc1::/64 services: qBittorrent: image: linuxserver/qbittorrent container_name: qBittorrent ports: - 16000:16000 #网页端口 - 18064:18064 #下载端口 - 18064:18064/udp environment: - PUID=1000 - PGID=994 - TZ=Asia/Shanghai - WEBUI_PORT=16000 - TORRENTING_PORT=18064 volumes: - /var/opt/qbittorrent:/config - /mnt/luoboPool/public:/data - /home/luobo/qbittorrent/VueTorrent:/VueTorrent restart: unless-stopped networks: - qb_ipv6 ani-rss: image: wushuo894/ani-rss container_name: ani-rss ports: - 7789:7789 environment: - PORT=7789 - CONFIG=/config - TZ=Asia/Shanghai volumes: - /var/opt/ani-rss:/config - /mnt/luoboPool/public:/data restart: unless-stopped networks: - qb_ipv6 PeerBanHelper: image: registry.cn-hangzhou.aliyuncs.com/ghostchu/peerbanhelper container_name: PeerBanHelper ports: - 9898:9898 environment: - TZ=Asia/Shanghai volumes: - /var/opt/PBH:/app/data restart: unless-stopped networks: - qb_ipv6 记得修改qBittorrent的端口和相关的挂载路径。\n我这里在配置时，启用了ipv6支持，主要是下载bt时有ipv6连接性会更好一点（也就是更快）\nani-rss 对于ani-rss的设置，我这里就写一些关键的配置\n保存位置：/data/番剧/${year}年${quarter}月/${title}\n这样就可以按照季度进行分类的\n开启自动删除、仅在主RSS更新后删除备用RSS、备用RSS\n这样就能开启洗版功能，可以实现先下载内嵌字幕的版本，等字幕组更新后再换回内封版本\n其他的参考官方的文档就好了\n这里补充一下，ani-rss是基于蜜柑计划的，而蜜柑计划主站已经被干扰了，所以可以采用自建镜像站的方法。这里我使用CloudFlare的Worker，脚本为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const TELEGRAPH_URL = \u0026#39;https://mikanani.me\u0026#39;; const MY_DOMAIN = \u0026#39;https://example.com\u0026#39; addEventListener(\u0026#39;fetch\u0026#39;, event =\u0026gt; { event.respondWith(handleRequest(event.request)) }) async function handleRequest(request) { const url = new URL(request.url); url.host = TELEGRAPH_URL.replace(/^https?:\\/\\//, \u0026#39;\u0026#39;); const modifiedRequest = new Request(url.toString(), { headers: request.headers, method: request.method, body: request.body, redirect: \u0026#39;manual\u0026#39; }); const response = await fetch(modifiedRequest); const contentType = response.headers.get(\u0026#39;Content-Type\u0026#39;) || \u0026#39;\u0026#39;; // 如果内容类型是 RSS，才进行替换操作 if (contentType.includes(\u0026#39;application/xml\u0026#39;)) { const text = await response.text(); const replacedText = text.replace(/https?:\\/\\/mikanani\\.me/g, MY_DOMAIN); const modifiedResponse = new Response(replacedText, response); // 添加允许跨域访问的响应头 modifiedResponse.headers.set(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); return modifiedResponse; } else { const modifiedResponse = new Response(response.body, response); // 添加允许跨域访问的响应头 modifiedResponse.headers.set(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); return modifiedResponse; } } qBittorrent 这里也没有什么太多需要配置的，我这里就是配置了一个第三方的WebUI——VueTorrent。\n下载好后在使用备用 WebUI里填写对应的路径即可。\nPeerBanHelper 这个主要是为了防止在公网做种时被吸血，配置好qBittorrent连接后就可以不用管了。\n字体自动子集化——fontInAss 对于新番而言，字幕组在内封字幕的时候同时也会封入字体文件，这样我们就不用操心字体的问题。但是，在收集一些老番的时候，字幕往往是外挂的，这样在没有字体的环境下就会回退到默认字体，看起来就一点也不美观。\n目前，已经有一种解决方案——将字体子集化并嵌入字幕1，但是这种方式还是无法避免需要手动进行处理。为此，我找到了一个可以自动化处理的软件——fontInAss，来解决这个问题。\n它的安装和配置很简单，还是一样的Docker一把梭。\n1 2 3 4 5 6 docker run -d --name=fontinass --restart=unless-stopped \\ -p 8012:8012 \\ -e EMBY_SERVER_URL=http://172.17.0.1:8096 \\ -v /var/opt/fontinassData:/data \\ -v \u0026#34;/mnt/luoboPool/public/Downloads/超级字体整合包 XZ\u0026#34;:/fonts/XZ \\ riderlty/fontinass:latest 这里唯一要注意的就是需要预先下载好字体的整合包，可以在这里找到。（当然让它用到时再自动下载也可以）\n之后访问Emby从8012端口进入就好了。\n自动备份——Rclone 这款软件也是介绍过了很多次了，用它可以很方便的将数据同步到网盘上面。\n1 2 #!/bin/sh rclone copy /mnt/luoboPool/public/番剧 sp:/番剧 --exclude-from=\u0026#34;/home/luobo/exclude-anime.txt\u0026#34; 这里我加上了一个排除文件，避免传上Emby刮削后的文件。\n1 2 3 4 *.nfo *.parts *.!qB *.json 最后就是编写定时脚本让其每天自动更新了。这里我没有使用传统的crontab，而是另一种据说更现代的方式——systemd/Timers - ArchWiki。\n根据文档，我们只需要编写.service和.timer文件就好了。\n/etc/systemd/system/sync-to-onedrive.service\n1 2 3 4 5 6 7 [Unit] Description=Copy to onedrive [Service] User=luobo Group=luobo ExecStart=/bin/bash /home/luobo/sync.sh /etc/systemd/system/sync-to-onedrive.timer\n1 2 3 4 5 6 7 8 9 [Unit] Description=Run sync daily [Timer] OnCalendar=*-*-* 4:00:00 Persistent=true [Install] WantedBy=timers.target 小结 整理资源真的是一件很爽的事情，特别是看到最后的海报墙以后。也是很感谢这些软件的制作者，为我省下了许多的时间。\n我的动画字幕字体解决方案 - 初之音\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-06-20T16:02:45+08:00","image":"https://lbqaq.top/p/my-anime-hub/131135880.webp","permalink":"https://lbqaq.top/p/my-anime-hub/","title":"如何优雅的打造个人影音库"},{"content":"在22年的时候，当时我写了一篇基于Shiro的身份权限控制方法，然而随着Springboot和Shiro的更新。当我把Springboot升级到3.x版本、Shiro升级到2.x后，发现原来的方法都没有用了。无论我怎么尝试，都无法实现登录的拦截效果。在折腾了许久后，我决定自己手搓安全框架。毕竟当时用Shiro主要是为了找工作，现在做项目只要实现效果就好了\n基本思路 我们还是沿用之前文章的设计，使用JWT来作为用户的Token。我们想要实现用户访问到特定的接口，就需要登录，否则进行拦截。对于指定了权限的接口，还需要验证用户是否有权限。\n和Shiro的设计一样，我们通过自定义注解来判断接口是否需要验证：@RequiresLogin表示需要登录、@RequiresRoles表示需要指定的身份。用户通过登录接口登录后，会获得一个Token，其中包含用户的信息和身份。在之后的请求中，用户需要在Header中附带这个Token。\n具体实现 导入依赖 由于我们是自己手搓，所以没有其他的依赖，只需要导入JWT相关的包即可了。\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.auth0\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java-jwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 封装JWT工具类 这里主要实现JWT的生成、验证、提取JWT封装的信息三个功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @Slf4j public class JwtUtil { /** * 服务器私钥 */ private static final Algorithm ALGORITHM = Algorithm.HMAC256(\u0026#34;1\u0026#34;); /** * 生成JSON Web Token * * @param username 用户名 * @param issuer 签发者 * @param subject 面向主体 * @param roles 用户权限 * @param ttlMillis 生效时长(单位:毫秒) */ public static String creatJwt(String username, String issuer, String subject, List\u0026lt;String\u0026gt; roles, long ttlMillis) { long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); JWTCreator.Builder builder = JWT.create() .withAudience(username) .withIssuedAt(now) .withSubject(subject) .withClaim(\u0026#34;roles\u0026#34;, roles) .withIssuer(issuer); if (ttlMillis \u0026gt;= 0) { long expMillis = nowMillis + ttlMillis; Date exp = new Date(expMillis); builder.withExpiresAt(exp); } return builder.sign(ALGORITHM); } /** * 获取签发对象 * * @param token 需要解密的token * @return 解密后获得的对象，失败返回null */ public static String getAudience(String token) { try { return JWT.decode(token).getAudience().get(0); } catch (JWTDecodeException exception) { log.error(\u0026#34;输入的token无法解析\u0026#34;); return null; } catch (NullPointerException exception) { log.error(\u0026#34;无法读取签发对象\u0026#34;); return null; } } /** * 获取面向主体 * * @param token 需要解密的token * @return 解密后获得的对象，失败返回null */ public static String getSubject(String token) { try { return JWT.decode(token).getSubject(); } catch (JWTDecodeException exception) { log.error(\u0026#34;输入的token无法解析\u0026#34;); return null; } catch (NullPointerException exception) { log.error(\u0026#34;无法读取面向主体\u0026#34;); return null; } } /** * 获取用户权限 * * @param token 需要解密的token * @return 解密后获得的对象，失败返回null */ public static List\u0026lt;String\u0026gt; getRoles(String token) { try { return JWT.decode(token).getClaim(\u0026#34;roles\u0026#34;).as(List.class); } catch (JWTDecodeException exception) { log.error(\u0026#34;输入的token无法解析\u0026#34;); return null; } catch (NullPointerException exception) { log.error(\u0026#34;无法读取用户权限\u0026#34;); return null; } } /** * 验证token是否正确 * * @param token 需要验证的token * @return 通过验证返回true，反之抛出异常 */ public static Boolean verifyToken(String token) throws JWTVerificationException { JWTVerifier verifier = JWT.require(ALGORITHM).build(); verifier.verify(token); return true; } } 自定义注解 通过自定义注解，我们可以细粒度的进行权限控制。这里我们需要进行登录认证和身份认证（由于项目并不大，就略去了权限认证），我们定义了两个注解：\n1 2 3 4 5 6 7 8 9 10 import java.lang.annotation.*; /** * 需要登录权限 */ @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface RequiresLogin { } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import top.lbqaq.questioncollect.pojo.RoleEnum; import java.lang.annotation.*; /** * 需要身份权限 */ @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface RequiresRoles { //所需的权限名称 RoleEnum[] value(); Logical logical() default Logical.AND; } 注解类上有三个注解：\n@Target 用它来指明自定义注解的使用范围，ElementType.TYPE代表可以将该注解使用在类、接口或枚举上，ElementType.METHOD 代表可以应用在类的方法上。\n@Retention 用它来指明该注解在.java变.class文件过程中会被保留到那个阶段。RetentionPolicy.RUNTIME 这种类型的注解将被JVM保留，所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用。\n@Documented 注解表明这个注解应该被 javadoc工具记录。\n特别的，在第二个注解上，我们引入了RoleEnum和Logical这两个自定义的类。对于第一个，这是一个权限的枚举，方便之后指定接口所需权限。第二个则是标明所需的权限逻辑操作，主要用于身份判断处，具体代码如下：\n1 2 3 4 5 6 7 8 9 10 public enum Logical { /** * AND */ AND, /** * OR */ OR } 自定义拦截器 我们在interceptor下定义我们自己的拦截器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @Component public class AuthInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (handler instanceof HandlerMethod) { final HandlerMethod handlerMethod = (HandlerMethod) handler; final Class\u0026lt;?\u0026gt; clazz = handlerMethod.getBeanType(); final Method method = handlerMethod.getMethod(); final boolean requiresLogin = clazz.isAnnotationPresent(RequiresLogin.class) || method.isAnnotationPresent(RequiresLogin.class); final boolean requiresRoles = clazz.isAnnotationPresent(RequiresRoles.class) || method.isAnnotationPresent(RequiresRoles.class); // 判断注解是标记在所调用的方法上还是在其类上 if (requiresLogin || requiresRoles) { // 登录鉴权的主要业务逻辑解释是当发现用户没有做登陆的时候，立即抛出一个自定义的业务异常BusinessException，如果登录则return true继续执行后续代码。 // 直接获取登录用户（防止请求转发时，第二次查询） LoginUser loginUser = LoginTokenHelper.getLoginUserFromRequest(); if (loginUser != null) { return true; } //获取登录TOKEN String token = LoginTokenHelper.getLoginToken(); if (token == null) { throw new AuthException(\u0026#34;用户未登录\u0026#34;); } //验证Token try { JwtUtil.verifyToken(token); } catch (JWTDecodeException e) { throw new AuthException(\u0026#34;不是有效的JWT格式\u0026#34;); } catch (SignatureVerificationException e) { throw new AuthException(\u0026#34;无效的签名\u0026#34;); } catch (TokenExpiredException e) { throw new AuthException(\u0026#34;token已过期\u0026#34;); } //获取Token里的信息 String userId = JwtUtil.getAudience(token); if (userId == null) { throw new AuthException(\u0026#34;token中缺少UserId\u0026#34;); } List\u0026lt;String\u0026gt; userRoles = JwtUtil.getRoles(token); if (userRoles == null) { throw new AuthException(\u0026#34;token中缺少身份\u0026#34;); } loginUser = new LoginUser(); loginUser.setUid(userId); loginUser.setRoles(userRoles); String aud = JwtUtil.getSubject(token); if (\u0026#34;test\u0026#34;.equals(aud) \u0026amp;\u0026amp; !\u0026#34;dev\u0026#34;.equals(RequestContextUtil.getActiveProfile())) { throw new AuthException(\u0026#34;禁止使用测试Token\u0026#34;); } //身份认证 if (requiresRoles) { List\u0026lt;String\u0026gt; roles = null; Logical logical = null; if (clazz.isAnnotationPresent(RequiresRoles.class)) { roles = RoleEnum.getValuesAsList(clazz.getAnnotation(RequiresRoles.class).value()); logical = clazz.getAnnotation(RequiresRoles.class).logical(); } else { roles = RoleEnum.getValuesAsList(method.getAnnotation(RequiresRoles.class).value()); logical = method.getAnnotation(RequiresRoles.class).logical(); } if ((logical.equals(Logical.AND) \u0026amp;\u0026amp; !userRoles.containsAll(roles)) || (logical.equals(Logical.OR) \u0026amp;\u0026amp; userRoles.stream().noneMatch(roles::contains)) ) { throw new AuthException(\u0026#34;用户无权查看\u0026#34;); } } //登录TOKEN信息放入请求对象，方便后续controller中获取 LoginTokenHelper.addLoginUserToRequest(loginUser); return true; } } return true; } } 这里有几个要点，首先就是利用requiresLogin和requiresRoles来判断是否需要进行拦截。其次我们用了LoginTokenHelper来简化登录验证。我们使用了JwtUtil.getRoles(token)来获取用户的身份，这里是不想每次用户执行操作时都去数据库里进行查询，于是就在用户登录的时候就把roles一起打包到Token里。身份认证就是去遍历接口定义的身份和用户的身份是否匹配。\n这里我们自定义了用户类LoginUser，方便之后在接口中使用\n1 2 3 4 5 6 @Data @Hidden public class LoginUser { private String uid; private List\u0026lt;String\u0026gt; roles; } @Hidden确保其不会生成在文档中，因为这是后端使用的变量，前端无需知道。\n登录辅助类 这里主要处理的就是从请求里提取用户的Token，此外将已经解析好的用户信息再存放到请求中去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class LoginTokenHelper { private final static String LOGIN_TOKEN_COOKIE_NAME = \u0026#34;Token\u0026#34;; private final static String LOGIN_TOKEN_KEY = \u0026#34;LOGIN-TOKEN\u0026#34;; /** * 获取登录的TOKEN */ public static String getLoginToken() { HttpServletRequest request = RequestContextUtil.getRequest(); String token = request.getHeader(LOGIN_TOKEN_COOKIE_NAME); return token; } /** * 将登录用户信息放入请求对象 */ public static void addLoginUserToRequest(LoginUser loginUser) { RequestContextUtil.getRequest().setAttribute(LOGIN_TOKEN_KEY, loginUser); } /** * 获取登录用户信息从请求对象 */ public static LoginUser getLoginUserFromRequest() { Object loginTokenO = RequestContextUtil.getRequest().getAttribute(LOGIN_TOKEN_KEY); if (loginTokenO == null) { return null; } return (LoginUser) loginTokenO; } } 这段代码用到了RequestContextUtil，这段代码就是从网上copy的。我在原始的基础上就加了个判断当前激活的profile。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class RequestContextUtil { private static ApplicationContext applicationContext; public static HttpServletRequest getRequest() { return getRequestAttributes().getRequest(); } public static HttpServletResponse getResponse() { return getRequestAttributes().getResponse(); } public static HttpSession getSession() { return getRequest().getSession(); } public static ServletRequestAttributes getRequestAttributes() { return ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()); } public static ServletContext getServletContext() { return ContextLoader.getCurrentWebApplicationContext().getServletContext(); } public static void setApplicationContext(ApplicationContext context) { RequestContextUtil.applicationContext = context; } public static String getActiveProfile() { return applicationContext.getEnvironment().getActiveProfiles()[0]; } } 配置拦截器 在WebConfig.java里重写方法，将我们定义的拦截器注入即可。\n1 2 3 4 5 6 7 8 @Resource AuthInterceptor authInterceptor; @Override //添加拦截器 public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(authInterceptor); } 到目前位置，用户的非登录请求就已经可以拦截下来了，但如果想要在接口中获取到当前的用户信息该如何操作呢？这就需要通过自定义解析器将参数注入进去。\n自定义参数解析器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class LoginUserArgumentResolver implements HandlerMethodArgumentResolver { @Override public boolean supportsParameter(MethodParameter parameter) { final Method method = parameter.getMethod(); final Class\u0026lt;?\u0026gt; clazz = parameter.getMethod().getDeclaringClass(); boolean isHasLoginAuthAnn = clazz.isAnnotationPresent(RequiresLogin.class) || method.isAnnotationPresent(RequiresLogin.class) || clazz.isAnnotationPresent(RequiresRoles.class) || method.isAnnotationPresent(RequiresRoles.class); boolean isHasLoginUserParameter = parameter.getParameterType().isAssignableFrom(LoginUser.class); return isHasLoginAuthAnn \u0026amp;\u0026amp; isHasLoginUserParameter; } @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { return LoginTokenHelper.getLoginUserFromRequest(); } } supportsParameter主要是判断是否需要注入登录用户，resolveArgument则是将我们之前存放好的LoginUser返回。\n注入参数解析器 和之前的操作一样。\n1 2 3 4 5 6 7 8 @Resource LoginUserArgumentResolver loginUserArgumentResolver; @Override //添加解析器 public void addArgumentResolvers(List\u0026lt;HandlerMethodArgumentResolver\u0026gt; resolvers) { resolvers.add(loginUserArgumentResolver); } 使用 对于需要身份认证的接口，只需要加上@RequiresLogin或者@RequiresRoles(value = {RoleEnum.ADMIN})即可。想要获得当前的用户，直接写在参数里就好了，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RequiresLogin @PostMapping(\u0026#34;/updateUserInfo\u0026#34;) @Operation(summary = \u0026#34;更新用户基本信息\u0026#34;, security = @SecurityRequirement(name = \u0026#34;Token\u0026#34;)) public Result updateUserInfo(@RequestBody UserDTO userDTO, LoginUser loginUser) { if(userDTO.getUid()==null){ return new Result().setCode(1200).setMessage(\u0026#34;用户id不能为空\u0026#34;); } if (!userDTO.getUid().equals(loginUser.getUid())) { return new Result().setCode(1200).setMessage(\u0026#34;不能修改其他用户信息\u0026#34;); } User user = new User(); user.setUid(userDTO.getUid()); user.setName(userDTO.getName()); user.setPhone(userDTO.getPhone()); user.setClassName(userDTO.getClassName()); if(userService.updateByPrimaryKeySelective(user)==0){ return new Result().setCode(1200).setMessage(\u0026#34;更新失败\u0026#34;); } return new Result().setCode(200).setMessage(\u0026#34;成功\u0026#34;); } 这里我用了@SecurityRequirement，主要是为了让Swagger调试姛时候可以输入Token。Swagger配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Configuration public class SwaggerConfig { @Bean public OpenAPI getOpenAPI() { return new OpenAPI() .info(new Info().title(\u0026#34;Question Collect API\u0026#34;) .description(\u0026#34;问卷收集系统\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) ) .components(new Components() .addSecuritySchemes(\u0026#34;Token\u0026#34;, new SecurityScheme().type(SecurityScheme.Type.APIKEY).in(SecurityScheme.In.HEADER).name(\u0026#34;Token\u0026#34;)) ); } } 参考文献 SpringBoot实战 - 拦截器+自定义注解实现接口的登录校验 - 小米笔记 - 坏记性不如烂笔头 SpringBoot实战 - 自定参数解析器自动注入已登录用户 - 小米笔记 - 坏记性不如烂笔头 ","date":"2025-02-08T16:20:00+08:00","image":"https://lbqaq.top/p/springboot-login/124949134.webp","permalink":"https://lbqaq.top/p/springboot-login/","title":"Springboot手搓登录权限验证"},{"content":"经常使用anaconda的小伙伴都会遇到一个问题，每次想要安装新的包，但会在solve environment这一步卡上半天，之后装包又要花上不少的时间。于是我找到了一款替代品，就是micromamba，据其官网所属，它是纯用C++编写的，同时使用了多线程。经过我的体验，确实是比anaconda要快一点的。\n安装 安装很简单，跟着官方文档做就好了。例如，Linux就只要输入下面的一串命令就可以了。\n1 \u0026#34;${SHELL}\u0026#34; \u0026lt;(curl -L micro.mamba.pm/install.sh) 不过默认的命令是micromamba，这实在是太长了，所以我们可以设置一个别名，方便平时使用。在~/.bashrc加入下面的内容就可以了。\n1 alias conda=\u0026#34;micromamba\u0026#34; 由于默认是不含 Anaconda 仓库源的，所以我们还需要再配置一下，正好把镜像也配置好。在~/.condarc中加入下面的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/ 在vscode中使用 这边才是我这篇文章的重点，由于是第三方的软件，所以vscode的Python插件默认是读取不到环境的，我们需要改一下配置。\n在安装的时候，如果没有修改默认的设置，则mamba的路径应该在~/micromamba\n我们打开VSCode的设置，添加下面的设置：\npython.venvFolders这一项，添加mamba的目录名，即micromamba python.venvPath这一项，添加mamba虚拟环境的目录，即~/micromamba/envs 只要添加好这两个设置，就可以发现VSCode能读取到虚拟环境了。\n此时我们已经完成了所有的配置，像以前一样创建虚拟环境、装包就能开始使用了。根据我的体验，anaconda的绝大部分功能都可以无缝使用。\n","date":"2024-08-05T09:34:00+08:00","image":"https://lbqaq.top/p/micromamba/119683453.webp","permalink":"https://lbqaq.top/p/micromamba/","title":"使用micromamba代替anaconda"},{"content":"身边的人总是提到，为什么我上一秒提到的东西，马上就出现在了相关搜索中呢？一个很大的可能性就是你的输入法暴露了。有研究指出1，目前市面上许多输入法都存在安全隐私漏洞。输入法作为我们平时用到最多的系统级应用，我不想自己的隐私被其泄露。所以，我寻找到了一款纯本地的全平台输入法——rime输入法2。它的优势就是简洁、无广告、不联网，不过对应的缺点就是没有云输入，一些比较新的词不好打出来，还有就是配置比较麻烦。\n然而，我们可以通过使用别人预先设计好的配置来缓解这个问题。我选择了雾凇拼音3这个开源的方案来实现，它的优势就是自己维护了一套常用的词库，同时配置好了一些默认的输入的方案，我就在它的方案上进行优化，打造一套属于自己的输入体验。\n由于我现在输入的方式是小鹤双拼，所以我的方案也全部是基于双拼打造的，全拼的话可以参考雾凇拼音的文档来配置。（在这强烈安利双拼的输入方式，学习成本不高但收益很高，能很大程度的改善你输入的体验👍）\n基本配置 rime输入法通过.yaml文件来管理配置，并支持以patch的形式对其进行修改。所以，我们只需要编写*.custom.yaml文件就可以在别人的框架上构建自己的输入法了。由于配置文件在全端都是通用的，这里就先介绍共同的配置，每个平台独立的配置在后面再介绍。\nrime的配置入口是default.yaml，所以我们先从它开始修改。创建default.custom.yaml，并填入下面的内容：\n1 2 3 4 5 6 7 patch: schema_list: - schema: double_pinyin_flypy - schema: rime_ice menu/page_size: 7 ascii_composer/switch_key/Shift_L: commit_code ascii_composer/switch_key/Shift_R: clear 我们首先选择了需要用到的两个方案double_pinyin_flypy和rime_ice，分别是小鹤双拼和全拼，这里加入全拼是避免别人使用我电脑时不会使用所预留的。menu/page_size指定了候选词的个数，最后两个则是指定了左右Shift键的功能。\n由于我们使用的是双拼，还需要修改“部件拆字”功能中的设置4。创建radical_pinyin.custom.yaml，填入下面的内容：\n1 2 3 4 patch: # 修改为小鹤双拼的拼写派生规则，因为不在同一个文件了，前面要加上文件名 speller/algebra: __include: radical_pinyin.schema.yaml:/algebra_flypy 同样，\u0026ldquo;拼写派生\u0026quot;功能也需要修改。创建melt_eng.custom.yaml文件，填入下面的内容：\n1 2 3 4 patch: # 修改为小鹤双拼的拼写派生规则，因为不在同一个文件了，前面要加上文件名 speller/algebra: __include: melt_eng.schema.yaml:/algebra_flypy 这样就配置完成了，还是很简单的。\n同步的话，我同样使用的是跨平台的软件rclone，如果要使用它，需要先配置好远端。\n通过执行rclone config并按照指示添加即可。之后，我分别介绍每个平台的具体配置和同步设置。\n详细配置 Win win下的客户端叫小狼毫，下载安装好后就可以进行配置了。配置目录为%APPDATA%\\Rime，我直接将里面的文件清空，然后使用git将雾凇拼音的仓库整个克隆进来。接着将上面“基本配置”中提到的三个文件创建好。由于默认的皮肤我不是很喜欢，所以我找了一个微软拼音的皮肤来使用。\n创建weasel.custom.yaml并填入下面的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 patch: preset_color_schemes: microsoft_sim: name: 仿微软输入法 author: plutotree back_color: 0xF4F4F4 border_color: 0xDCDCDC text_color: 0x000000 hilited_text_color: 0xF4F4F4 hilited_back_color: 0xFFD8A6 hilited_candidate_text_color: 0x000000 hilited_candidate_back_color: 0xFFD8A6 candidate_text_color: 0x000000 comment_text_color: 0x888888 style: color_scheme: microsoft_sim label_format: \u0026#34;%s\u0026#34; font_face: \u0026#34;微软雅黑\u0026#34; font_point: 12 horizontal: true inline_preedit: true layout: min_width: 140 min_height: 0 border_width: 1 border_height: 1 margin_x: 9 margin_y: 9 spacing: 9 candidate_spacing: 20 hilite_spacing: 7 hilite_padding: 8 round_corner: 0 接下来需要配置installation.yaml，我们主要修改里面的installation_id，这是同步文件夹中的名称，默认是一串UUID，但是这不方便我们同步，建议将其修改成便于操作的名称。\n这样我们就配置好了rime输入法，接下来只需要将配置目录下的sync文件夹同步就好了。\n同步的工具rclone在之前已经设置好了，我这里编写了一个cmd脚本来自动执行备份任务。使用时记得修改本地和远端的地址：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @echo off set rime_path=\u0026#34;D:\\Program Files (x86)\\Rime\\weasel-0.16.1\\WeaselDeployer.exe\u0026#34; set remote_path=a1:\\rime_sync set local_path=C:\\Users\\luobo\\AppData\\Roaming\\Rime set sync_path=%local_path%\\sync set device_name=lab-Win echo 更新输入法词库 cd /d %local_path% git pull %rime_path% /deploy echo 同步输入法词库中... %rime_path% /sync rclone sync %sync_path%\\%device_name% %remote_path%\\%device_name% -P echo 下载远端词库 rclone sync %remote_path% %sync_path% -P --exclude %device_name%/** Android 安卓端的应用是fcitx5-android5，下载软件本体和rime插件后就可以进行配置了。安卓端的配置文件位于/sdcard/Android/data/org.fcitx.fcitx5.android/files/data/rime，我们直接将电脑端的配置文件复制进去就可以了，需要注意的是，installation.yaml里面的installation_id要改成不同的值。\n同步的话，rclone并没有官方的安卓客户端。不过，我们可以使用termux——一款运行于Android 系统的开源终端模拟器6，并在里面安装rclone来使用。\n下载并安装好后，首先进行换源：\n1 2 sed -i \u0026#39;s@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/apt/termux-main stable main@\u0026#39; $PREFIX/etc/apt/sources.list apt update \u0026amp;\u0026amp; apt upgrade 之后安装rclone\n1 apt install rclone ⚠由于安卓的安全性设置，普通应用是无权访问别的应用目录下的文件。所以，我们需要给予root权限（或者使用别的有权限的应用，我没有试过）\n我这里同样是通过脚本来实现自动同步：\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/sh export PATH=\u0026#34;/data/data/com.termux/files/usr/bin:$PATH\u0026#34; CONFIG_PATH=\u0026#34;/data/data/com.termux/files/home/.config/rclone/rclone.conf\u0026#34; RIME_PATH=\u0026#34;/sdcard/Android/data/org.fcitx.fcitx5.android/files/data/rime/sync\u0026#34; REMOTE_PATH=\u0026#34;a1:/rime_sync\u0026#34; LOCAL_FOLDER=\u0026#34;K50U-Android\u0026#34; echo \u0026#34;download...\u0026#34; rclone sync $REMOTE_PATH $RIME_PATH -P --exclude $LOCAL_FOLDER/** --config $CONFIG_PATH echo \u0026#34;upload...\u0026#34; rclone sync $RIME_PATH/$LOCAL_FOLDER $REMOTE_PATH/$LOCAL_FOLDER -P --config $CONFIG_PATH 这里由于我们是使用root身份来执行的，所以需要额外设置PATH并手动指定配置文件的路径\n体验 日常使用rime输入法已经有大半年了，测试下来与云输入法基本没有什么区别，一些比较新的词打一遍也能被词库学习到。配合上多端同步，使用还是非常方便的。此外，雾凇拼音还内置了一些便捷功能，例如：\nsymbols：全拼 v 开头、双拼大写 V 开头 部件拆字的反查：uU 开头，反查时前缀会消失影响打英文所以设定为两个字母，或可改成一个非字母符号。 部件拆字的辅码：` 触发。 Unicode：大写 U 开头，如 U62fc 得到「拼」。 数字、金额大写：大写 R 开头，如 R1234 得到「一千二百三十四、壹仟贰佰叁拾肆元整」。 农历指定日期：大写 N 开头，如 N20240210 得到「二〇二四年正月初一」。 如果是比较在乎个人隐私的用户，我是比较推荐使用这样一款不联网的本地输入法的。\n参考文献 敲敲打打：一系列云端输入法漏洞使网络攻击者得以监看个人用户的输入内容（摘要） - The Citizen Lab\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRIME | 中州韻輸入法引擎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\niDvel/rime-ice: Rime 配置：雾凇拼音 | 长期维护的简体词库\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n常见问题 · iDvel/rime-ice\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nfcitx5-android/fcitx5-android\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTermux | The main termux site and help pages.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-06-16T20:59:00+08:00","image":"https://lbqaq.top/p/rime-sync/112900405.webp","permalink":"https://lbqaq.top/p/rime-sync/","title":"我的rime：打造多端同步的本地输入法"},{"content":"介绍 最近的研究表明，深度神经网络 （DNN） 容易受到后门攻击，攻击者通过毒害一些训练数据将隐蔽的后门注入 DNN。具体来说，后门攻击者将后门触发器（即特定模式）附加到一些良性训练数据，并将其标签更改为攻击者指定的目标标签。触发模式和目标标签之间的相关性将由 DNN 在训练期间学习。在推理过程中，后门模型在良性数据上表现正常，而当后门被激活时，其预测会被恶意改变。\n相反，人类认知系统能够抵抗输入的扰动，例如后门攻击引起的隐蔽触发模式。这是因为人类对因果关系的敏感度高于干扰因素的关联。相比之下，经过训练以拟合中毒数据集的深度学习模型很难区分后门攻击带来的因果关系和统计关联。通过因果推理，我们可以识别因果关系并建立鲁棒的深度学习模型。因此，必须利用因果推理来分析和减轻后门攻击的威胁。\n那么。什么是因果推理呢？因果推断在统计研究中有着悠久的历史。因果推理的目标是分析变量之间的因果效应，并减轻虚假相关性。\n作者专注于图像分类任务，目标是在没有额外干净数据的情况下，在含有毒数据的数据集上训练出无后门的模型。作者首先构建了一个因果图来模拟后门数据的生成过程，特别考虑了干扰因素，即后门触发模式。借助因果图，发现后门攻击扮演了混杂因素的角色，并在输入图像与预测标签之间建立了一条虚假的联系。一旦深度神经网络学习了这种虚假联系，当附加了触发器时，它们的预测就会发生改变，转向目标标签。\n作者在因果洞察的启发下，提出了一种新的后门防御方法，称为因果关系启发的后门防御（Causalityinspired Backdoor Defense，CBD），旨在学习去混淆的分类表示。由于后门攻击隐蔽且难以直接测量，无法通过因果推理直接阻断后门路径。受到解缠绕表征学习最新进展的启发，作者的目标是学习一种表征，它只保留与因果关系相关的信息。在CBD中，作者训练了两个深度神经网络（DNN）：一个专注于捕获虚假相关性，另一个专注于识别因果效应。第一个DNN通过提前停止策略有意地学习后门相关性。接着，我们通过最小化互信息训练第二个干净的模型，使其在隐藏空间中独立于第一个模型。训练完成后，只有干净的模型被用于下游的分类任务。\n问题构造 作者假设攻击者已经预先生成了一组后门示例，并成功地将它们注入到训练数据集中。同时，作者假设防御者能够完全控制训练过程，但对数据集中后门示例的分布或比例一无所知。防御者的目标是训练出一个在中毒数据集上表现良好且无后门的模型，其性能应与在纯干净数据上训练的模型相当。一句话总结，就是在后门数据集上训练出一个干净模型。\n因果分析 因果推理的优越性在于它使人类能够识别因果关系，同时忽略任务中的非必要因素。相比之下，深度神经网络通常无法区分因果关系和统计关联，并且倾向于学习那些“更容易”的相关性，而不是必要的信息。这种走捷径的解决方案可能导致对无关因素（例如触发模式）的过度拟合，从而增加了后门攻击的脆弱性。因此，作者利用因果推理来分析DNN模型的训练过程，并降低后门注入的风险。\n作者通过构建因果图$G$来模拟中毒数据的生成过程。在因果图中，作者使用节点来表示抽象数据变量，其中$X$代表输入图像，$Y$代表标签，$B$代表后门攻击。有向链接则表示这些变量之间的关系。除了$X$对$Y$的因果效应（$X → Y$）之外，后门攻击者可以通过将触发模式附加到图像（$B → X$）并将标签更改为目标标签（$B → Y$）来实施攻击。因此，后门攻击 $B$ 作为 $X$ 和 $Y$ 之间的混杂因素，打开了虚假路径 $X ← B → Y$（其中 $B = 1$ 表示图像中毒，$B = 0$ 表示图像干净）。我们所说的“虚假”路径是指这条路径位于 $X$ 到 $Y$ 的直接因果路径之外，它使得 $X$ 和 $Y$ 之间产生了虚假的相关性，并在触发器被激活时导致错误的效果。深度神经网络（DNN）很难区分虚假相关性和因果关系。因此，如果在可能中毒的数据集上直接训练 DNN，模型将面临被后门攻击的风险。\n为了探究 $X$ 对 $Y$ 的因果效应，研究者通常使用 do 演算在因果干预中进行后门调整：$P(Y|do(X)) = \\sum_{B\\in\\{0,1\\}}P(Y|X,B)P(B)$。然而，在作者的设置中，由于混杂变量 $B$ 几乎无法被检测和测量，不能简单地使用后门调整来阻断后门路径。相反，由于大多数深度学习模型的目标是学习下游任务的准确嵌入表示，所以目标是解开隐藏空间中的混淆效应和因果效应。\n基于因果推理的后门防御 在现实应用中，直接识别数据空间中 $X$ 的混杂因素和因果因素可能相当困难。作者假设这些混杂因素和因果因素会在隐藏的表征中得到体现。通常，训练包括两个 DNN，即 $f_B$ 和 $f_C$，它们分别专注于捕获虚假相关性和因果关系。作者从 $f_B$ 和 $f_C$ 的倒数第二层提取嵌入向量，分别表示为 $R$ 和 $Z$。为了避免混淆，本文中使用大写字母表示变量，小写字母表示具体值。为了生成能够捕获因果关系的高质量变量 $Z$，作者在训练阶段，首先在中毒数据集上训练 $f_B$，以捕捉后门的虚假相关性。随后，训练另一个干净的模型 $f_C$，鼓励其在隐藏空间（即 $Z$ 与 $R$ 独立）中的独立性，并通过最小化互信息和实施样本重新加权策略。训练完成后，只有 $f_C$ 被用于下游的分类任务。\n后门模型训练 首先，作者在具有交叉熵损失的毒数据集上训练 $f_B$，目的是捕获后门的虚假相关性。由于中毒数据仍然包含因果关系，作者有意通过早期停止策略来增强 $f_B$ 中的混杂偏差。具体来说，作者只对 $f_B$ 进行了少数几个时期的训练（例如，5 个时期），并在训练 $f_C$ 时冻结了其参数。这是因为先前的研究表明，后门关联比因果关系更容易被学习。\n干净模型训练 作者提出了具有信息瓶颈和互信息最小化的训练目标：\n$$\\mathcal{L}\\_C=\\min\\underbrace{\\beta I(Z;X)}\\_{1}-\\underbrace{I(Z;Y)}\\_{2}+\\underbrace{I(Z;R)}\\_{3}$$其中$I(.;.)$​表示互信息\n①用来限制来自输入的不相关信息 ②用来捕获变量 $Z$​ 用于标签预测的核心信息 ③描述了后门嵌入 $R$ 和去混淆嵌入 $Z$ 之间的依赖程度。它鼓励 $Z$ 独立于 $R$，通过最小化互信息来关注因果效应 互信息\n互信息（mutual Information，MI）度量了两个变量之间相互依赖的程度。具体来说，对于两个随机变量，MI是一个随机变量由于已知另一个随机变量而减少的“信息量”（单位通常为比特）。\n$$I(X;Y)=D\\_{\\mathrm{KL}}(p(x,y)\\|p(x)\\otimes p(y))$$直观上，互信息度量 X 和 Y 共享的信息：它度量知道这两个变量其中一个，对另一个不确定度减少的程度。例如，如果 X 和 Y 相互独立，则知道 X 不对 Y 提供任何信息，反之亦然，所以它们的互信息为零。在另一个极端，如果 X 是 Y 的一个确定性函数，且 Y 也是 X 的一个确定性函数，那么传递的所有信息被 X 和 Y 共享：知道 X 决定 Y 的值，反之亦然。\n然而，上述的公式并不能直接求解，为此，作者放宽了限制。\n公式1\n$$\\begin{aligned} I(Z;X)\u0026 =\\sum\\_x\\sum\\_zp(z,x)\\mathrm{log}\\frac{p(z,x)}{p(z)p(x)} \\\\\\\\ \u0026=\\sum\\_x\\sum\\_zp(z|x)p(x)\\mathrm{log}\\frac{p(z|x)p(x)}{p(z)p(x)} \\\\\\\\ \u0026=\\sum\\_x\\sum\\_zp(z|x)p(x)\\mathrm{log~}p(z|x)-\\sum\\_zp(z)\\mathrm{log~}p(z) \\end{aligned}$$然而，边际概率$p(z)=\\sum_xp(z|x)p(x)$在实践中很难计算，为此作者通过变分分布$q(z)$来近似$p(z)$，由于KL散度是非负的，根据吉布斯不等式：$D_{\\mathrm{KL}}(p(z)||q(z)) \\geq 0 \\Rightarrow -\\sum_zp(z)\\mathrm{log~}p(z)\\leq-\\sum_zp(z)\\mathrm{log~}q(z)$\n将其代入上式：\n$$\\begin{aligned} I(Z;X)\u0026 \\leq\\sum\\_xp(x)\\sum\\_zp(z|x)\\mathrm{log~}p(z|x)-\\sum\\_zp(z)\\mathrm{log~}q(z) \\\\\\\\ \u0026=\\sum\\_xp(x)\\sum\\_zp(z|x)\\mathrm{log}\\frac{p(z|x)}{q(z)} \\\\\\\\ \u0026=\\sum\\_xp(x)D\\_{\\mathrm{KL}}(p(z|x)||q(z)) \\end{aligned}$$作者假设$p(z|x)=\\mathcal{N}(\\mu(x),\\mathrm{diag}\\{\\sigma^2(x)\\})$是高斯分布，其中$\\mu(x)$是$x$的编码嵌入，$\\mathrm{diag}\\{\\sigma^2(x)\\}=\\{\\sigma_d^2\\}_{d=1}^D$表示方差的对角矩阵，并假设$q(z)=\\mathcal{N}(0,I)$，于是上式就可以改写成：\n$$D\\_{\\mathrm{KL}}(p(z|x)||q(z))=\\frac{1}{2}||\\mu(x)||\\_2^2+\\frac{1}{2}\\sum\\_d(\\sigma\\_d^2-\\mathrm{log}\\sigma\\_d^2-1)$$为了便于优化作者将$\\sigma(x)$定义为全零矩阵，所以$z=\\mu(x)$成为确定性嵌入。\n最后推导出来，公式一就相当于直接在嵌入向量 $z$ 上应用L2正则化\n公式2\n根据互信息的定义，有$I(Z;Y)=H(Y)-H(Y|Z)$，其中$H(·)$ 和 $H(·|·)$ 分别表示熵和条件熵。由于$H(Y)$ 是一个正常数，可以忽略不计，因此有以下不等式：\n$$-I(Z;Y)\\leq H(Y|Z)$$在实验中，$H(Y|Z)$可以计算并优化为交叉熵损失。为了进一步鼓励 $f_C$ 和 $f_B$ 之间的独立性，作者固定了 $f_B$ 的参数，并使用样本加权交叉熵损失来训练 $f_C$，权重的计算公式为：\n$$w(x)=\\frac{CE(f\\_B(x),y)}{CE(f\\_B(x),y)+CE(f\\_C(x),y)}$$对于 $f_B$上损失较大的样本，$w(x)$接近1;而当损失非常小时，$w(x)$接近 0。从而让 $f_C$专注于 $f_B$的“难”示例，以鼓励其独立性。\n公式3\n基于互信息和KL散度的关系，有$I(Z;R)=D_{\\mathrm{KL}}(p(Z,R)||p(Z)p(R))$，即$I(Z;R)$等价于联合分布$p(Z,R)$和两个边际$p(Z)p(R)$的乘积之间的KL散度。\n为了最小化混杂惩罚项，作者采用了对抗学习。判别器$D_\\phi$被训练成将联合分布$p(Z,R)$分类为1，将边际分布$p(Z)p(R)$分类为0。边际分布$p(Z)p(R)$的样本是通过对$p(Z,R)$训练批次中样本$(z,r)$的单个表示进行shuffle而获得的。优化函数如下：\n$$\\mathcal{L}\\_{adv}=\\min\\_{\\theta\\_C}\\max\\_\\phi\\mathbb{E}\\_{p(z,r)}[D\\_\\phi(z,r)]-\\mathbb{E}\\_{p(z)p(r)}[D\\_\\phi(z,r)]$$其中$\\theta_C$ 和$\\phi$分别表示 $f_C$ 和 $D_\\phi$ 的参数。\n综上，$f_C$的损失函数为：\n$$\\mathcal{L}\\_C=\\mathcal{L}\\_{wce}+\\mathcal{L}\\_{adv}+\\beta||\\mu(x)||\\_2^2$$​\n算法的伪代码如下：\n实验 数据集和模型\nCIFAR-10：WideResNet GTSRB：WideResNet ImageNet：ResNet-34 攻击基线\nBadNets、Trojan attack、Blend attack、Sinusoidal signal attack (SIG)、Dynamic attack、WaNet\n防御基线\nFine-pruning (FP) 、Mode Connectivity Repair (MCR) 、 Neural Attention Distillation (NAD) 、 Anti-Backdoor Learning (ABL) 、Decoupling-based backdoor defense (DBD)\n作者在10%中毒率下和其他防御方法进行了对比，证明了该方法的有效性。\n同时，作者也考虑了不同中毒率下防御方法的有效性\n此外，作者还绘制了t-SNE图，从a和b可以看出在训练后，混杂成分$r$和因果成分$z$之间存在明显的分离。从c和d中可以看出，中毒样本的嵌入在$r$中形成簇，这表明已经学习了后门触发器和目标标签之间的虚假相关性。相比之下，中毒样本与样本密切相关，其真实标签位于去混淆嵌入$z$中，这表明CBD可以有效地防御后门攻击。\n作者最后还计算了防御所需的时间，可见防御并不需要更多额外的时间\n","date":"2024-05-07T14:30:00+08:00","image":"https://lbqaq.top/p/backdoor-defense-via-deconfounded-representation-learning/117158168.webp","permalink":"https://lbqaq.top/p/backdoor-defense-via-deconfounded-representation-learning/","title":"Backdoor Defense via Deconfounded Representation Learning"},{"content":"最近将路由器上的工具换为小猫，使用默认的redir-host模式虽然能用，但总是出现各种各样奇怪的问题，再加上小猫官方已经删除了redir-host模式，于是我便想找到一个基于fake-ip的分流方式。通过在互联网上检索发现，找到了这篇文章——《基于 DNS 的内网透明代理分流方案》。仔细研读下来，完美符合我的需求，然而，我使用的是内存捉襟见肘的硬路由，并没有足够的空间装下AdGuardHome+mosdns+小猫三员大将。于是，我便在他方案的基础上删除了AdGuardHome，优化出了现在的方案。\n实现效果 和原来的方案一样，我就直接粘贴了。\n基于DNS的流量分流，国内流量绕过小猫核心 用Fake-IP模式来解决DNS污染的问题，但限制Fake-IP的范围，不需要代理的域名仍返回正常IP 不用再费心找无污染的DNS服务器，使用运营商提供的DNS也没问题 因为彻底解决了DNS污染，可以放心缓存DNS请求结果 完美兼容IPv6。国内流量可正常使用IPv6服务。只要代理有IPv6出口，那国外也可正常使用。 兼容BT/PT应用，无需特殊配置也不会消耗代理流量 可以松切换内网设备是否走代理 遇到问题 在按照原来的方案构建并删去AdGuardHome后，可以实现大部分的功能。然而在我的使用中，却遇到了一个关键的问题：无法区分流量来源——由于mosdns是作为Dnsmasq的上游来使用的，所以无法识别请求的客户端，故无法实现是否走代理。\n为此，我尝试将mosdns代替dnsmasq来监听53端口，结果又遇到了一个新的问题：所有的请求都返回fake-ip——由于dns存在主机名解析功能，导致请求被错误的发往小猫的DNS端口，从而返回了fake-ip。\n方案设计 为了解决这两个问题，我重新设计了DNS解析的流程，从而得到了现在的这一套方案。\nDNS分流 graph TB client[DNS 请求] -- 防火墙劫持 --\u003e mosdns mosdns -- 需要代理的设备 --\u003e query[按规则进行DNS查询] mosdns -- 不需要代理的设备 --\u003e dnsmasq query -- 国内域名 --\u003e dnsmasq query -- 国外域名 --\u003e drop_ipv6[\\忽略 IPv6 请求/] query -- 其它 --\u003e fallback fallback -- 国内IP --\u003e dnsmasq fallback -- 国外IP --\u003e drop_ipv6 dnsmasq --\u003e sp_dns[真实IP] query -- 域名白名单 --\u003e dnsmasq query -- 域名灰名单 --\u003e drop_ipv6 drop_ipv6 --\u003e fake[Fake IP] 经过DNS分流后，所有需要代理的域名都分配到了Fake IP，无需代理的域名都是由运营商DNS返回的最优结果。小猫的DNS在Fake IP模式下可以无需请求网络直接返回结果，所以整体的DNS响应速度非常快。在处理Fake IP的流量时，小猫会把hostname发送到远端进行DNS解析，也就自然不存在DNS污染的问题了。\n修复地址解析错误 由于dns存在主机名解析功能，会导致请求错误的转发。正所谓“头痛医头，脚痛医脚”，最简单和无脑的方法就是直接关闭这个功能：\n在网络-DHCP/DNS-高级设置里，将本地域名里的值删除。（未测试，不确定🤔）\n但是我们都使用了mosdns了，为什么不好好的利用它那强大的规则呢。所以，我们可以将有关主机名解析的流量全部转发到dnsmasq，这样就不会出问题了。\n区分流量来源 一开始，mosdns是作为dnsmasq的上游的，所以所有的请求来源都是本地，这就导致了我们无法控制mosdns，让其为不需要代理的设备分配真实的IP。所以，我们将所有dns请求通过防火墙劫持到mosdns上，就能知道设备的来源的ip了。关于防火墙的写法，我参考了luci-app-adguardhome的开源代码。\n但是这样还有一个问题，由于我们配置了ipv6，所以请求的客户端地址很大可能也是ipv6的。由于ipv6地址支持无状态分配，这就导致请求的地址会一直变动，这也导致无法为特定客户端实现分流。这里我选择了最简单和无脑的方法——直接关闭ipv6的DNS服务。通过查询Openwrt的官方文档，我们发现官方提供了关闭ipv6 DNS服务的方法。这样就可以让客户端始终通过ipv4来请求了。确保了这一点，我们的防火墙也只用劫持ipv4的流量了。\n具体配置 上面都在讲思路，终于轮到具体的配置了。我们现在只需要小猫和luci-app-mosdns这两个包就好了。\n小猫 插件设置 - 模式设置 - 运行模式： 切换到 Fake-IP（增强）模式 插件设置 - DNS 设置 - 本地 DNS 劫持 选择 禁用 插件设置 - 流量控制 - 绕过中国大陆 IP 取消勾选 插件设置 - 流量控制 - 仅允许内网 开启 插件设置 - IPv6 设置 这页的选项全都关闭就行了 覆写设置 - 常规设置 这里都不用改，只需要记住 DNS 监听，后面配置 mosdns 要用 覆写设置 - DNS 设置 - 自定义上游 DNS 服务器 勾选 覆写设置 - DNS 设置 - 追加上游 DNS 勾选 覆写设置 - DNS 设置 - 追加默认 DNS 勾选 覆写设置 - DNS 设置 - Fake-IP 持久化 勾选 覆写设置 - DNS 设置 页面下方 NameServer，FallBack，Default-NameServer 里的 DNS 服务器全都取消勾选，我们只用运营商提供的 DNS 服务器就够了，一般运营商 DNS 都是最快的，也是 CDN 最优化的。 插件设置 - 开发者选项 里，我们自定义一下防火墙规则，增加如下这些行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 LOG_OUT \u0026#34;limit route to only fake ips with proxy port 7892\u0026#34; /etc/mosdns/genipset.sh iptables -t nat -D openclash -p tcp -j REDIRECT --to-ports 7892 iptables -t nat -A openclash -m set --match-set telegram dst -p tcp -j REDIRECT --to-ports 7892 LOG_OUT \u0026#34;restart mosdns\u0026#34; /etc/init.d/mosdns restart LOG_OUT \u0026#34;将53端口重定向到mosdns\u0026#34; iptables -t nat -D PREROUTING -p udp -d 192.168.6.1 --dport 53 -j REDIRECT --to-ports 5335 iptables -t nat -A PREROUTING -p udp -d 192.168.6.1 --dport 53 -j REDIRECT --to-ports 5335 iptables -t nat -D PREROUTING -p tcp -d 192.168.6.1 --dport 53 -j REDIRECT --to-ports 5335 iptables -t nat -A PREROUTING -p tcp -d 192.168.6.1 --dport 53 -j REDIRECT --to-ports 5335 这里有几个注意点，都是我踩过的坑😢：\n可能是我内核版本太旧了，这里使用任何变量都是空值，所以我把所有地址都写死了，记得根据自己的路由器地址进行修改 不要忘记劫持TCP流量！我之前仅仅劫持了UDP流量导致浏览器一直请求到真实ip而无法访问。 2024.09.26更新 使用nftables的高版本openwrt需要使用下面的脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 LOG_OUT \u0026#34;Start Add Custom Firewall Rules...\u0026#34; FW4=$(command -v fw4) en_mode=$(uci -q get openclash.config.en_mode) proxy_port=$(uci -q get openclash.config.proxy_port) if [ \u0026#34;$en_mode\u0026#34; == \u0026#34;fake-ip\u0026#34; ]; then LOG_OUT \u0026#34;limit route to only fake ips with proxy port $proxy_port\u0026#34; /root/genipset.sh if [ -n \u0026#34;$FW4\u0026#34; ]; then handle=$(nft -a list chain inet fw4 openclash | grep \u0026#39;ip protocol tcp counter\u0026#39; | awk \u0026#39;{print $NF}\u0026#39;) LOG_OUT \u0026#34;deleting nft rule handle $handle\u0026#34; nft delete rule inet fw4 openclash handle $handle nft add rule inet fw4 openclash ip protocol tcp ip daddr @telegram counter redirect to $proxy_port else iptables -t nat -D openclash -p tcp -j REDIRECT --to-ports $proxy_port iptables -t nat -A openclash -m set --match-set telegram dst -p tcp -j REDIRECT --to-ports $proxy_port fi LOG_OUT \u0026#34;restart mosdns\u0026#34; /etc/init.d/mosdns restart LOG_OUT \u0026#34;将53端口重定向到mosdns\u0026#34; if [ -n \u0026#34;$FW4\u0026#34; ]; then ! nft --check list table inet mosdns \u0026gt; \u0026#34;/dev/null\u0026#34; 2\u0026gt;\u0026amp;1 || nft delete table inet mosdns nft add table inet mosdns nft add chain inet mosdns prerouting \u0026#34;{ type nat hook prerouting priority -110; policy accept; }\u0026#34; nft add rule inet mosdns prerouting \u0026#34;meta nfproto { ipv4 } udp dport 53 ip daddr 192.168.6.1 counter redirect to :5335 comment \\\u0026#34;MOSDNS HIJACK\\\u0026#34;\u0026#34; nft add rule inet mosdns prerouting \u0026#34;meta nfproto { ipv4 } tcp dport 53 ip daddr 192.168.6.1 counter redirect to :5335 comment \\\u0026#34;MOSDNS HIJACK\\\u0026#34;\u0026#34; else iptables -t nat -D PREROUTING -p udp -d 192.168.6.1 --dport 53 -j REDIRECT --to-ports 5335 iptables -t nat -A PREROUTING -p udp -d 192.168.6.1 --dport 53 -j REDIRECT --to-ports 5335 iptables -t nat -D PREROUTING -p tcp -d 192.168.6.1 --dport 53 -j REDIRECT --to-ports 5335 iptables -t nat -A PREROUTING -p tcp -d 192.168.6.1 --dport 53 -j REDIRECT --to-ports 5335 fi fi genipset.sh 的代码如下，这是针对某些应用不通过DNS直接用ip访问，要将这部分流量劫持到小猫。这个文件放到路由器上后，记得要执行 chmod a+x /etc/mosdns/genipset.sh 给它赋予可执行权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/bin/bash tag=\u0026#34;telegram\u0026#34; filename=\u0026#34;/etc/mosdns/data/telegram-cidr.txt\u0026#34; FW4=$(command -v fw4) if test -f \u0026#34;$filename\u0026#34;; then if [ -n \u0026#34;$FW4\u0026#34; ]; then nft add set inet fw4 \u0026#34;$tag\u0026#34; { type ipv4_addr\\; flags interval\\; auto-merge\\; } nft add set inet fw4 \u0026#34;${tag}6\u0026#34; { type ipv6_addr\\; flags interval\\; auto-merge\\; } nft flush set inet fw4 \u0026#34;$tag\u0026#34; nft flush set inet fw4 \u0026#34;${tag}6\u0026#34; fi ipset create \u0026#34;$tag\u0026#34; hash:net -! ipset create \u0026#34;${tag}6\u0026#34; hash:net family inet6 -! ipset flush \u0026#34;$tag\u0026#34; ipset flush \u0026#34;${tag}6\u0026#34; while read p; do if ! grep -q \u0026#34;:\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$p\u0026#34;; then if [ -n \u0026#34;$FW4\u0026#34; ]; then nft add element inet fw4 \u0026#34;$tag\u0026#34; { \u0026#34;$p\u0026#34; } fi ipset add \u0026#34;$tag\u0026#34; \u0026#34;$p\u0026#34; else if [ -n \u0026#34;$FW4\u0026#34; ]; then nft add element inet fw4 \u0026#34;${tag}6\u0026#34; { \u0026#34;$p\u0026#34; } fi ipset add \u0026#34;${tag}6\u0026#34; \u0026#34;$p\u0026#34; fi done \u0026lt;\u0026#34;$filename\u0026#34; else echo \u0026#34;$filename missing.\u0026#34; fi Mosdns 选自定义配置文件，关闭DNS 转发的勾，然后我就直接贴配置了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 # Powered by luoboQAQ # 适配Clash的fake-ip模式 # 24-08-29：让灰名单优先生效，避免被geosite_cn抢答 log: level: info file: \u0026#34;/tmp/log/mosdns.log\u0026#34; # API 入口设置 api: http: \u0026#34;0.0.0.0:9091\u0026#34; plugins: # 国内域名 - tag: geosite_cn type: domain_set args: files: - \u0026#34;/etc/mosdns/data/direct-list.txt\u0026#34; - \u0026#34;/etc/mosdns/rule/whitelist.txt\u0026#34; # 国内 IP - tag: geoip_cn type: ip_set args: files: - \u0026#34;/etc/mosdns/data/CN-ip-cidr.txt\u0026#34; # 国外域名 - tag: geosite_no_cn type: domain_set args: files: - \u0026#34;/etc/mosdns/data/proxy-list.txt\u0026#34; # 灰名单域名，强制远程解析 - tag: greylist type: domain_set args: files: - \u0026#34;/etc/mosdns/rule/greylist.txt\u0026#34; # 黑名单域名：屏蔽 DNS 解析 - tag: blocklist type: domain_set args: files: - \u0026#34;/etc/mosdns/rule/blocklist.txt\u0026#34; # ddns域名 - tag: ddnslist type: domain_set args: files: - \u0026#34;/etc/mosdns/rule/ddnslist.txt\u0026#34; # 自定义 Hosts 重写 - tag: hosts type: hosts args: files: - \u0026#34;/etc/mosdns/rule/hosts.txt\u0026#34; # 广告域名 - tag: adlist type: domain_set args: files: - \u0026#34;/etc/mosdns/data/ad-domains.txt\u0026#34; # PTR黑名单 - tag: local_ptr type: domain_set args: files: - \u0026#34;/etc/mosdns/rule/local-ptr.txt\u0026#34; # 缓存插件 - tag: cache type: cache args: size: 10240 lazy_cache_ttl: 86400 # 将缓存保存在磁盘 # dump_file: /tmp/mosdns/cache.dump # 国内解析 - tag: local_sequence type: sequence args: - exec: forward 127.0.0.1 # 国外解析 - tag: remote_sequence type: sequence args: - matches: - qtype 28 exec: reject 0 - exec: forward 127.127.127.127:7874 - exec: ttl 1800-0 # 有响应终止返回 - tag: has_resp_sequence type: sequence args: - matches: qname $ddnslist exec: ttl 5-5 - matches: has_resp exec: accept # fallback 用本地服务器 sequence # 返回非国内 ip 则 drop_resp - tag: fallback_local type: sequence args: - exec: $local_sequence - matches: \u0026#34;!resp_ip $geoip_cn\u0026#34; exec: drop_resp # fallback 用远程服务器 sequence - tag: fallback type: fallback args: primary: fallback_local secondary: remote_sequence threshold: 500 always_standby: true # 主要的运行逻辑插件 # sequence 插件中调用的插件 tag 必须在 sequence 前定义， # 否则 sequence 找不到对应插件。 - tag: main_sequence type: sequence args: # 不走代理的ip #- matches: client_ip 192.168.6.144 # exec: forward 127.0.0.1 #- exec: jump has_resp_sequence # hosts - exec: $hosts - exec: jump has_resp_sequence - matches: - \u0026#34;!qname $ddnslist\u0026#34; - \u0026#34;!qname $blocklist\u0026#34; - \u0026#34;!qname $adlist\u0026#34; - \u0026#34;!qname $local_ptr\u0026#34; exec: $cache - exec: jump has_resp_sequence # 查询拒绝域名 - matches: qname $blocklist exec: reject 3 - matches: qname $adlist exec: reject 3 - matches: qtype 65 exec: reject 3 - matches: - qtype 12 - qname $local_ptr exec: reject 3 # handle local ptr - matches: - qtype 12 exec: forward 127.0.0.1 - exec: jump has_resp_sequence # handle lan query - matches: - qname regexp:lan regexp:local regexp:arpa exec: forward 127.0.0.1 - exec: jump has_resp_sequence - matches: - qname $ddnslist exec: $local_sequence - exec: jump has_resp_sequence # 灰名单在geosite_cn之前查询 - matches: - qname $greylist exec: $remote_sequence - exec: jump has_resp_sequence - matches: - qname $geosite_cn exec: $local_sequence - exec: jump has_resp_sequence - matches: - qname $geosite_no_cn exec: $remote_sequence - exec: jump has_resp_sequence - exec: $fallback - tag: udp_server type: udp_server args: entry: main_sequence listen: \u0026#34;:5335\u0026#34; - tag: tcp_server type: tcp_server args: entry: main_sequence listen: \u0026#34;:5335\u0026#34; 在这个配置中，我使用了以下项目提供的域名/IP文件：\ndirect-list.txt和proxy-list.txt CN-ip-cidr.txt ad-domains.txt telegram-cidr.txt 为了方便期间，我们可以使用脚本一键更新它们：\n1 2 3 4 5 6 7 #!/bin/sh curl -o \u0026#34;/etc/mosdns/data/direct-list.txt\u0026#34; \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/v2ray-rules-dat@release/direct-list.txt\u0026#34; curl -o \u0026#34;/etc/mosdns/data/proxy-list.txt\u0026#34; \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/v2ray-rules-dat@release/proxy-list.txt\u0026#34; curl -o \u0026#34;/etc/mosdns/data/CN-ip-cidr.txt\u0026#34; \u0026#34;https://cdn.jsdelivr.net/gh/Hackl0us/GeoIP2-CN@release/CN-ip-cidr.txt\u0026#34; curl -o \u0026#34;/etc/mosdns/data/ad-domains.txt\u0026#34; \u0026#34;https://anti-ad.net/domains.txt\u0026#34; curl --resolve core.telegram.org:443:`nslookup -port=5335 core.telegram.org 192.168.6.1 | grep 198 | cut -d \u0026#34;:\u0026#34; -f2 | tr -d \u0026#34; \u0026#34;` -o \u0026#34;/etc/mosdns/data/telegram-cidr.txt\u0026#34; \u0026#34;https://core.telegram.org/resources/cidr.txt\u0026#34; /etc/init.d/mosdns restart 由于某个地址需要小猫才能访问，同时我们没有劫持路由器的dns查询，所以需要先手动查一下ip再下载。\n后记 这也是一个大工程了，前前后后也花了好多天，不过做完后使用起来还是非常丝滑和顺畅的，最重要的是自己折腾出来这是在是太酷了🤓。这里还是要感谢方案的原作者和开源项目作者，我从中学到了许多🙏。\n后续更新 2024.08.29 在使用时，会发现Google Play商店不能正常下载或更新应用。在《大陆用户 Google Play 商店无法下载或更新应用的原因分析与解决办法》这篇文章中，作者指出了这是由于国内版商店的api请求链接和下载链接分别通过直连和代理导致的问题，解决方案就是让请求都从代理出去。\n具体而言，我们需要将下面这几个域名添加到代理规则中\n1 2 3 domain:googleapis.cn domain:googleapis.com domain:xn--ngstr-lra8j.com Mosdns\n在规则列表-灰名单中添加上面的域名 小猫\n在覆写设置-规则设置-自定义规则中添加下面的分流规则 1 2 3 4 5 rules: # Google Play - DOMAIN-SUFFIX,googleapis.cn,🚀 节点选择 - DOMAIN-SUFFIX,googleapis.com,🚀 节点选择 - DOMAIN-SUFFIX,xn--ngstr-lra8j.com,🚀 节点选择 这样就可以正常的使用Play商店了\n2024.09.26 将路由器刷到了最新的immortalWrt，防火墙从iptables升级到了nftables，所以原来的命令不能用了，需要使用新的命令。\n","date":"2024-03-22T20:47:00+08:00","image":"https://lbqaq.top/p/dns-shunt/115597971.webp","permalink":"https://lbqaq.top/p/dns-shunt/","title":"基于DNS的分流方案"},{"content":"放假回家，手里只有性能孱弱的轻薄本，用它跑个实验或者是打个游戏实在是太难为它了。于是，远程到实验室的高性能主机便是一个非常不错的选择。不过，和之前在宿舍局域网串流不一样，家里和实验室属于不同的局域网，之间无法相互连接。\n在之前配置实验室路由器时，我已经配置过了WireGuard。通过在电脑上安装WireGuard，每次开机时启动一下就可以连入实验室的局域网了。似乎这样已经可以了，但是，如果我想在其他设备上访问实验室，就要重复上面的步骤，这实在是太麻烦了。同时，实验室想要访问位于家里的设备也无法实现。\n于是，我决定通过折腾一波路由器，来实现无感知的异地组网。\n准备工作 2台刷好OpenWrt的路由器，并保证拥有WireGuard包\n如果你的固件里没有预装WireGuard，可以选择手动编译，就像我这篇文章一样（还没写🕊️）\n2台路由器均拥有公网ipv6地址\n一个域名，用来做ddns\n如何配置ddns不是本篇文章的重点，可以参考我之前的文章或者百度一下\n我们首先设计一下网络拓扑，其中实验室的ip段为192.168.6.0/24，家里的ip段为192.168.10.0/24。我这里选取192.168.100.0/24为WireGurad的虚拟局域网网段，并分别给家中和实验室路由器分配192.168.100.100/32和192.168.100.1/32两个地址。为了接下来使用方便，我建议用表格整理一下：\n实验室 家 局域网段 192.168.6.0/24 192.168.10.0/24 ddns地址 school.example.com home.example.com WireGurad接口ip地址 192.168.100.1/32 192.168.100.100/32 具体操作 接口配置 我们首先从实验室的路由器开始配置。登入OpenWrt后台，依次点击网络——接口——添加新接口，选择协议为WireGuard VPN，名称这里随意。\n接着开始进行详细的配置\n这里的监听端口按照个人喜好自己指定即可，为了演示我分别指定端口号为6789和7890。\n可以看到较新的OpenWrt这里是有生成密钥的选项，所以我们可以不用命令行来生成密钥对，不过我这个版本缺少公钥的框，如果想查看公钥的话，要到状态——WireGuard里去查看。所以我建议还是使用命令行预先生成好公私钥：\n1 2 3 4 5 6 7 8 # 创建公钥和私钥 wg genkey | tee privatekey | wg pubkey \u0026gt; publickey # 获取私钥复制保存 cat privatekey # 获取公钥复制保存 cat publickey # 生成预共享密钥 wg genpsk 我们需要创建两次公私钥，预共享密钥是一致的，所以只需创建一次即可，为了便于之后的操作，我们将其存放到上文列好的表中：\n实验室 家 局域网段 192.168.6.0/24 192.168.10.0/24 ddns地址 school.example.com home.example.com WireGurad接口ip地址 192.168.100.1/32 192.168.100.100/32 监听端口 6789 7890 WireGurad公钥 YJF1c//jJ0K2HSZ+yNqfjBfJL6Z90lyfVCyML8To1lI= Q/gtGW5xBK5sEgPTrSo3CWqGOv3SYhzkqw8CBOJ3ZHs= WireGurad私钥 0MyNAHWVI0owbbZ3Et9gWtNFSVWiOqiHHYJAj86Wq0E= eKGSiCzaVi9IHfDLv4atx//wE8LGCR2xWAwc3XBw9kg= 预共享密钥 OQrD6nvzMGQklARhwwhlrinFiumrGe2SIBxcRSOuIEo= 同左 特别注意\n私钥和预共享密钥就像密码一样，不要轻易泄露，我这里只是演示用才展示出来。\n有了这些信息，我们就可以很轻松的将前图中的配置填好了，不要勾选无主机路由。\n之后我们要配置对端\n有了之前的表格，这里的内容就很简单了。直接反着写就好了。我这里是实验室所以就对着家的那一列依次往里面填即可。\n允许的IP我们直接添加两条，分别是对方的局域网段和接口ip地址，例如我这里就填192.168.10.0/24和192.168.100.100/32即可。 勾选路由允许的IP 端点主机和端口分别填写ddns地址和监听端口。 Keep-Alive使用默认值25即可。 这样我们的WireGuard就算配置好了。\n防火墙配置 依次点击网络——防火墙，选择添加。\n这里大部分人（包括之前的我）会说直接将WireGuard接口放入LAN中，不过这样还是不太优雅，所以我们还是创建一个新区域。\n出站、入站、转发均为允许 勾选MSS 钳制：这主要是为了防止内网MTU过大导致WireGuard效率降低 涵盖的网络为之前创建的接口 允许转发到目标区域和允许来自源区域的转发都选择LAN 保存后选择上面的通信规则，我们需要开启路由器上的端口\n由于WireGuard是基于UDP的，我们只需要放行UDP流量即可。端口为之前表中填写的。\n至此，我们的配置就算完成了，另一台路由器也是同样的配置方法，我就不赘述了。\n踩坑和一些注意事项 两端都要配置端点主机\nWireGuard按原理来说，只要一方发起握手即可相互通信，所以我们可以只配置一个路由器，让它发起握手。不过我尝试后发现这样会导致只有发起握手的路由器可以连到对端，下面的设备就无法连接，被握手的路由器也无法ping通发起握手的路由器。（🤔难道是因为被握手的路由器中没有自动配置好路由表吗？）\nWireGuard配置好后需要重启端口才能生效\nddns变动后，WireGuard只会尝试连接之前的地址而不会重新解析\n可能是为了安全考虑吧，这样只能手动重启端口来让其重新解析，还有其他自动化的方法不过我就没有研究了\n参考文献 【老湿基】WireGuard 异地组网手把手教学 | 从入门到精通 | 局域网融合_哔哩哔哩 ","date":"2024-02-03T23:00:08+08:00","image":"https://lbqaq.top/p/wireguard-ipv6/104589070.webp","permalink":"https://lbqaq.top/p/wireguard-ipv6/","title":"使用WireGuard+ipv6进行异地组网"},{"content":"起因 由于实验室的网线口过于稀少且离我距离太远，学校的WIFI又是WIFI5，平时最多只能跑到30MB/s。但我的笔记本支持WIFi6，学校又是千兆网。两条原因一叠加，那就直接上WIFI6的路由器吧。首要的选择条件就是支持刷机，在恩山上逛了一阵子，就决定入手红米的AX6000。可解锁、有第三方固件、512MB内存。特别是这512MB内存，比起我之前用的红米AC2100，直接翻了4倍，相较于原来随便开个插件就没有内存的情况，直接起飞好吧😎。\n成果 先来一手倒序(毕竟配置的过程比较无聊😇。使用南京大学测速站进行测试，可以看到网速直接拉满，下载东西的时候终于不用等那么久了。\n再加上各种插件，真的很舒适🤤，上网体验直接拉满。下面就是将相关的配置过程做个记录。\n配置 解锁与刷机 这里可以参考B站大佬的视频1，步骤非常详细，直接跟着做就好了。为了备忘，我这里再简单把步骤写一下。\n高版本的系统已经封堵了解锁的漏洞，我们要做的第一步就是使用小米修复工具进行降级。\n之后进入管理界面并登录，此时地址格式类似下面这样：\n1 http://192.168.31.15/cgi-bin/luci/;stok=030b24d39b1a4a549aa12dac23c52313/web/home#router 我们将/web/home#router删除，并加上下面一段：\n1 /api/misystem/set_sys_time?timezone=%20%27%20%3B%20zz%3D%24%28dd%20if%3D%2Fdev%2Fzero%20bs%3D1%20count%3D2%202%3E%2Fdev%2Fnull%29%20%3B%20printf%20%27%A5%5A%25c%25c%27%20%24zz%20%24zz%20%7C%20mtd%20write%20-%20crash%20%3B%20 即连接应该为http://192.168.31.15/cgi-bin/luci/;stok=030b24d39b1a4a549aa12dac23c52313/api/......\n回车访问，显示{\u0026quot;code\u0026quot;:0}表示成功\n同理，继续替换：\n1 /api/misystem/set_sys_time?timezone=%20%27%20%3b%20reboot%20%3b%20 等待重启完成\n登录路由器，替换：\n1 /api/misystem/set_sys_time?timezone=%20%27%20%3B%20bdata%20set%20telnet_en%3D1%20%3B%20bdata%20set%20ssh_en%3D1%20%3B%20bdata%20set%20uart_en%3D1%20%3B%20bdata%20commit%20%3B%20 继续替换：\n1 /api/misystem/set_sys_time?timezone=%20%27%20%3b%20reboot%20%3b%20 等待重启完成\n此时telnet已经开启，连接进入，显示【ARE U OK】的界面，表示telnet成功。\n输入下面的命令开启ssh：\n1 2 3 4 5 6 7 8 9 10 bdata set boot_wait=on bdata commit nvram set ssh_en=1 nvram set telnet_en=1 nvram set uart_en=1 nvram set boot_wait=on nvram commit sed -i \u0026#39;s/channel=.*/channel=\u0026#34;debug\u0026#34;/g\u0026#39; /etc/init.d/dropbear /etc/init.d/dropbear restart echo -e \u0026#39;admin\\nadmin\u0026#39; | passwd root 继续输入下面的命令，关闭开发者模式：\n1 mtd erase crash 使用ssh连接进入，将xwrt目录里的stock-initramfs-factory.ubi传入tmp目录\n输入下面的命令查看系统分区\n1 cat /proc/cmdline 输出类似这样：\n1 console=ttyS0,115200n1 loglevel=8 firmware=1 uart_en=1 我们主要关注firmware=1这项\n如firmware=0输入\n1 2 3 4 5 6 7 8 nvram set boot_wait=on nvram set uart_en=1 nvram set flag_boot_rootfs=1 nvram set flag_last_success=1 nvram set flag_boot_success=1 nvram set flag_try_sys1_failed=0 nvram set flag_try_sys2_failed=0 nvram commit 然后刷入固件\n1 ubiformat /dev/mtd9 -y -f /tmp/stock-initramfs-factory.ubi 如firmware=1输入\n1 2 3 4 5 6 7 8 nvram set boot_wait=on nvram set uart_en=1 nvram set flag_boot_rootfs=0 nvram set flag_last_success=0 nvram set flag_boot_success=1 nvram set flag_try_sys1_failed=0 nvram set flag_try_sys2_failed=0 nvram commit 然后刷入固件\n1 ubiformat /dev/mtd8 -y -f /tmp/stock-initramfs-factory.ubi reboot重启 固件后台：http://192.168.15.1/ 账户密码：admin/admin 在后台升级xwrt正式固件\n进入xwrt正式固件后台—系统—管理权—ssh访问—打开密码验证和允许root用户凭密码登录-保存并应用。 再次连接SSH（ip192.168.15.1用户名root密码admin），输入以下命令\n1 2 3 4 5 6 7 fw_setenv boot_wait on fw_setenv uart_en 1 fw_setenv flag_boot_rootfs 0 fw_setenv flag_last_success 1 fw_setenv flag_boot_success 1 fw_setenv flag_try_sys1_failed 8 fw_setenv flag_try_sys2_failed 8 之后刷入最新237大佬固件\n刷入uboot 之前刷入的官方版的镜像，虽然很方便，但是可用空间并不是很多，为了榨干它全部的性能，我还是决定刷入第三方uboot，将官方原始的三个分区合并成一个大分区。\n我这里刷入的hanwckf大佬制作的uboot，他支持多分区的切换，还是很方便的。具体的功能和下载链接可以看大佬的博客——mt798x uboot 功能介绍。\n我们之前刷入过237大佬的固件了，所以FIP分区已经解锁，可以直接刷。\n首先要备份原始的分区，像Factory为无线EEPROM分区；Bdata存储着你的SN和MAC。如果没了应该是无法使用别人的分区来使用的。所以一定要备份好。\n我们使用dd命令备份分区到tmp文件夹：2\n1 2 3 4 5 dd if=/dev/mtd1 of=/tmp/mtd1_BL2.bin dd if=/dev/mtd2 of=/tmp/mtd2_Nvram.bin dd if=/dev/mtd3 of=/tmp/mtd3_Bdata.bin dd if=/dev/mtd4 of=/tmp/mtd4_Factory.bin dd if=/dev/mtd5 of=/tmp/mtd5_FIP.bin 然后使用WinSCP等软件将备份的文件下载到电脑上。\n备份好后，就可以通过WinSCP将uboot文件上传到tmp目录下，并执行下面的命令进行刷入：\n1 2 3 d5sum /tmp/mt7986_redmi_ax6000-fip-fixed-parts-multi-layout.bin mtd write /tmp/mt7986_redmi_ax6000-fip-fixed-parts-multi-layout.bin FIP mtd verify /tmp/mt7986_redmi_ax6000-fip-fixed-parts-multi-layout.bin FIP 注意对比md5的值是否一致。最后如果成功则会输出Success\n将路由器断电，按住Reset键并通电，持续按住10S即可进入uboot了。\n由于H大的uboot没有配置DHCP，我们需要手动配置电脑ip：\nIP地址：192.168.31.100 子网掩码：255.255.255.0 默认网关：192.168.31.1 DNS：192.168.31.1 访问192.168.31.1即可进入uboot页面，这时就可以刷入大分区的固件了\n配置校园网自动连接 在我之前，已经有大佬针对校园网的登录写了自动化脚本\nyzu-campusnet-login public 校园网登录器 Python 然而，这并不适用我的环境。由于红米AX6000的官方布局采用了A/B分区，导致可用的软件包分区只有20多MB。在这么小的空间中安装个Python，再加上各种各样的库，想想就可怕。\n为此，我需要使用一门可以打包成小体积的语言来重构此程序。一开始，我想选择C++，但是C++的网络编程我还没了解过，正在我思考要不要花些时间学习一下，突然想到了有一门语言完美符合我的需求——Golang。跨平台、有方便的网络库，于是我便花了一天时间学习Go，成功将大佬的程序重构了（正好当学习Go语言的练手程序。\nyzu-campusnet-login public Go版本的校园网登录器 Go 直接将编译好的二进制文件传入到路由器中，并写好配置文件，之后在后台——“系统”——“启动项”下面的本地启动脚本添加一条运行命令就可以开机启动了。\n1 cd /root/login \u0026amp;\u0026amp; nohup ./YzuCampusnetLogin \u0026gt; /tmp/login.log 2\u0026gt;\u0026amp;1 \u0026amp; 配置ipv6 学校的ipv6下发的是/64地址，一开始我参考这个大佬的教程，使用内网中继的方案来实现ipv6。然而无论我怎么配置，都无法连接互联网。最后发现是学校网关对每一个ipv6地址都会进行登录的校验，如果没有登录就不会放行，那这条路算是彻底堵死了😥。\n这样的话，就只能使用nat6了,详细的步骤可以参考这篇教程3\n将接口——LAN——IPV6设置中的路由通告服务选为“服务器模式”、DHCPv6 服务选为“服务器模式”、NDP 代理选为“禁用”、DHCPv6 模式选为“无状态的 + 有状态的”、总是通告默认路由勾上\n使用ssh连接路由器，在/etc/init.d目录下新建nat6并填入下面的内容：\n📃展开代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #!/bin/sh /etc/rc.common # NAT6 init script for OpenWrt // Depends on package: kmod-ipt-nat6 # edited by Sad Pencil at 2020-02-09 # replace route command with ip command to solve issues on new OpenWRT # edited by Sad Pencil at 2021-11-29 # update line WAN6_INTERFACE=$(uci get \u0026#34;network.$WAN6_NAME.device\u0026#34; || uci get \u0026#34;network.$WAN6_NAME.ifname\u0026#34;) START=55 # Options # ------- # Use temporary addresses (IPv6 privacy extensions) for outgoing connections? Yes: 1 / No: 0 PRIVACY=1 # Maximum number of attempts before this script will stop in case no IPv6 route is available # This limits the execution time of the IPv6 route lookup to (MAX_TRIES+1)*(MAX_TRIES/2) seconds. The default (15) equals 120 seconds. MAX_TRIES=15 # An initial delay (in seconds) helps to avoid looking for the IPv6 network too early. Ideally, the first probe is successful. # This would be the case if the time passed between the system log messages \u0026#34;Probing IPv6 route\u0026#34; and \u0026#34;Setting up NAT6\u0026#34; is 1 second. DELAY=5 # Logical interface name of outbound IPv6 connection # There should be no need to modify this, unless you changed the default network interface names # Edit by Vincent: I never changed my default network interface names, but still I have to change the WAN6_NAME to \u0026#34;wan\u0026#34; instead of \u0026#34;wan6\u0026#34; WAN6_NAME=\u0026#34;wan6\u0026#34; # --------------------------------------------------- # Options end here - no need to change anything below boot() { [ $DELAY -gt 0 ] \u0026amp;\u0026amp; sleep $DELAY WAN6_INTERFACE=$(uci get \u0026#34;network.$WAN6_NAME.ifname\u0026#34;) logger -t NAT6 \u0026#34;Probing IPv6 route\u0026#34; PROBE=0 COUNT=1 while [ $PROBE -eq 0 ] do if [ $COUNT -gt $MAX_TRIES ] then logger -t NAT6 \u0026#34;Fatal error: No IPv6 route found (reached retry limit)\u0026#34; \u0026amp;\u0026amp; exit 1 fi sleep $COUNT COUNT=$((COUNT+1)) PROBE=$(ip -6 route | grep -i \u0026#39;^default.*via\u0026#39; | grep -i -F \u0026#34;dev $WAN6_INTERFACE\u0026#34; | grep -i -o \u0026#39;via.*\u0026#39; | wc -l) done logger -t NAT6 \u0026#34;Setting up NAT6\u0026#34; if [ -z \u0026#34;$WAN6_INTERFACE\u0026#34; ] || [ ! -e \u0026#34;/sys/class/net/$WAN6_INTERFACE/\u0026#34; ] ; then logger -t NAT6 \u0026#34;Fatal error: Lookup of $WAN6_NAME interface failed. Were the default interface names changed?\u0026#34; \u0026amp;\u0026amp; exit 1 fi #WAN6_GATEWAY=$(ip -6 route | grep -o \u0026#39;2001.*1102\u0026#39; | sed s\u0026#39;/1102/1101::1/g\u0026#39;) WAN6_GATEWAY=$(ip -6 route | grep -i \u0026#39;^default.*via\u0026#39; | grep -i -F \u0026#34;dev $WAN6_INTERFACE\u0026#34; | grep -i -o \u0026#39;via.*\u0026#39; | cut -d \u0026#39; \u0026#39; -f 2 | head -n 1) if [ -z \u0026#34;$WAN6_GATEWAY\u0026#34; ] ; then logger -t NAT6 \u0026#34;Fatal error: No IPv6 gateway for $WAN6_INTERFACE found\u0026#34; \u0026amp;\u0026amp; exit 1 fi LAN_ULA_PREFIX=$(uci get network.globals.ula_prefix) if [ $(echo \u0026#34;$LAN_ULA_PREFIX\u0026#34; | grep -c -E \u0026#34;^([0-9a-fA-F]{4}):([0-9a-fA-F]{0,4}):\u0026#34;) -ne 1 ] ; then logger -t NAT6 \u0026#34;Fatal error: IPv6 ULA prefix $LAN_ULA_PREFIX seems invalid. Please verify that a prefix is set and valid.\u0026#34; \u0026amp;\u0026amp; exit 1 fi ip6tables -t nat -I POSTROUTING -s \u0026#34;$LAN_ULA_PREFIX\u0026#34; -o \u0026#34;$WAN6_INTERFACE\u0026#34; -j MASQUERADE if [ $? -eq 0 ] ; then logger -t NAT6 \u0026#34;Added IPv6 masquerading rule to the firewall (Src: $LAN_ULA_PREFIX - Dst: $WAN6_INTERFACE)\u0026#34; else logger -t NAT6 \u0026#34;Fatal error: Failed to add IPv6 masquerading rule to the firewall (Src: $LAN_ULA_PREFIX - Dst: $WAN6_INTERFACE)\u0026#34; \u0026amp;\u0026amp; exit 1 fi ip -6 route add 2000::/3 via \u0026#34;$WAN6_GATEWAY\u0026#34; dev \u0026#34;$WAN6_INTERFACE\u0026#34; if [ $? -eq 0 ] ; then logger -t NAT6 \u0026#34;Added $WAN6_GATEWAY to routing table as gateway on $WAN6_INTERFACE for outgoing connections\u0026#34; else logger -t NAT6 \u0026#34;Error: Failed to add $WAN6_GATEWAY to routing table as gateway on $WAN6_INTERFACE for outgoing connections\u0026#34; fi if [ $PRIVACY -eq 1 ] ; then echo 2 \u0026gt; \u0026#34;/proc/sys/net/ipv6/conf/$WAN6_INTERFACE/accept_ra\u0026#34; if [ $? -eq 0 ] ; then logger -t NAT6 \u0026#34;Accepting router advertisements on $WAN6_INTERFACE even if forwarding is enabled (required for temporary addresses)\u0026#34; else logger -t NAT6 \u0026#34;Error: Failed to change router advertisements accept policy on $WAN6_INTERFACE (required for temporary addresses)\u0026#34; fi echo 2 \u0026gt; \u0026#34;/proc/sys/net/ipv6/conf/$WAN6_INTERFACE/use_tempaddr\u0026#34; if [ $? -eq 0 ] ; then logger -t NAT6 \u0026#34;Using temporary addresses for outgoing connections on interface $WAN6_INTERFACE\u0026#34; else logger -t NAT6 \u0026#34;Error: Failed to enable temporary addresses for outgoing connections on interface $WAN6_INTERFACE\u0026#34; fi fi exit 0 } 执行下面的命令，使脚本开机运行：\n1 2 chmod +x /etc/init.d/nat6 /etc/init.d/nat6 enable 修改/etc/sysctl.conf，添加下面的内容：\n1 2 3 4 net.ipv6.conf.default.forwarding=2 net.ipv6.conf.all.forwarding=2 net.ipv6.conf.default.accept_ra=2 net.ipv6.conf.all.accept_ra=2 最后在自定义防火墙中添加一行命令：\n1 ip6tables -t nat -A POSTROUTING -o $(uci get network.wan6.ifname) -j MASQUERADE 由于硬件的BUG，还需要在开机脚本里添加一条命令，关闭ipv6的硬件加速，不然速度就会其慢无比\n1 echo 8 0 \u0026gt; /sys/kernel/debug/hnat/hnat_setting 完成后重启就会发现有ipv6了\n然而，在我使用的过程中发现，开启了ipv6后手机打开app时加载的速度肉眼可见的变慢。一开始以为是DNS的问题，但修改了默认的DNS服务器后还是不行。为了保证使用的体验，目前我还是把nat6给关闭了😭。\n已经找到了解决方案😉，见下一节\n配置mosdns mosdns作为一款自定义程度很高的DNS转发器，在之前的博文《自建DNS实现分流及广告过滤》就已经使用过了，这里我们需要他来解决ipv6 NAT后的卡顿问题。同时，配置好mosdns后，也可以实现广告过滤，dns防污染的功能。\n安装可以使用luci-app-mosdns这个项目来实现，直接执行它的脚本即可\n1 sh -c \u0026#34;$(curl -ksS https://raw.githubusercontent.com/sbwml/luci-app-mosdns/v5/install.sh)\u0026#34; 和之前的方案一样，我们需要以下项目提供的域名/IP文件：\nreject-list.txt 和 direct-list.txt CN-ip-cidr.txt ad-domains.txt：下载domains.txt并改名 其实luci-app-mosdns默认提供了一套配置，但是我们需要使用mosdns的优先ipv4的功能，所以只能自己撸配置了。没错，解决ipv6卡顿的最好方式就是不用😥，通过mosdns可以避免操作系统使用优先ipv6的策略。这样既实现了不卡顿，又可以访问纯ipv6网站。\n这套配置可以实现屏蔽广告，国内域名用本地DNS解析，国外域名走远程DNS解析。遇到不在列表中的域名，会查询本地DNS，如果返回的是国外地址，则以远程DNS的结果为准。\n具体的配置如下：\n📃展开代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 # Powered by luoboQAQ log: level: warn file: \u0026#34;/tmp/log/mosdns.log\u0026#34; # API 入口设置 api: http: \u0026#34;0.0.0.0:9091\u0026#34; plugins: # 国内域名 - tag: geosite_cn type: domain_set args: files: - \u0026#34;/var/mosdns/direct-list.txt\u0026#34; # 国内IP - tag: geoip_cn type: ip_set args: files: - \u0026#34;/var/mosdns/CN-ip-cidr.txt\u0026#34; # 国外域名 - tag: geosite_no_cn type: domain_set args: files: - \u0026#34;/var/mosdns/proxy-list.txt\u0026#34; # 黑名单域名 - tag: blocklist type: domain_set args: files: - \u0026#34;/etc/mosdns/rule/blocklist.txt\u0026#34; # 广告域名 - tag: adlist type: domain_set args: files: - \u0026#34;/var/mosdns/ad-domains.txt\u0026#34; # PTR黑名单 - tag: local_ptr type: domain_set args: files: - \u0026#34;/etc/mosdns/rule/local-ptr.txt\u0026#34; # 缓存插件 - tag: cache type: cache args: size: 10240 lazy_cache_ttl: 86400 # 将缓存保存在磁盘 dump_file: /tmp/mosdns/cache.dump # 转发至本地服务器的插件 - tag: forward_local type: forward args: upstreams: - tag: alidns_dot addr: \u0026#34;tls://223.5.5.5\u0026#34; - tag: dnspod_dot addr: \u0026#34;tls://120.53.53.53\u0026#34; # 转发至远程服务器的插件 - tag: forward_remote type: forward args: upstreams: # - tag: easymosdns # addr: \u0026#34;https://doh.apad.pro/dns-query\u0026#34; # bootstrap: \u0026#34;223.5.5.5\u0026#34; - tag: cloudflare_dot addr: \u0026#34;tls://1.1.1.1\u0026#34; # 国内解析 - tag: local_sequence type: sequence args: - exec: $forward_local # fallback 用本地服务器 sequence # 返回不包含本地 ip 则 reject - tag: local_ip_sequence type: sequence args: - exec: $forward_local - matches: \u0026#34;!resp_ip $geoip_cn\u0026#34; exec: drop_resp # fallback 用远程服务器 sequence - tag: remote_sequence type: sequence args: - exec: $forward_remote # fallback插件 - tag: fallback type: fallback args: primary: local_ip_sequence secondary: remote_sequence threshold: 500 always_standby: true # 有响应终止返回 - tag: has_resp_sequence type: sequence args: - matches: has_resp exec: accept # 查询国内域名 - tag: query_is_local_domain type: sequence args: - matches: qname $geosite_cn exec: $local_sequence # 查询国外域名 - tag: query_is_no_local_domain type: sequence args: - matches: qname $geosite_no_cn exec: $remote_sequence # 查询拒绝域名 - tag: query_is_reject_domain type: sequence args: - matches: qname $blocklist exec: reject 3 - matches: qname $adlist exec: reject 3 - matches: - qtype 12 - qname $local_ptr exec: reject 3 - matches: qtype 65 exec: reject 3 # 主要运行逻辑插件 - tag: main_sequence type: sequence args: # 去广告 - exec: $query_is_reject_domain - exec: jump has_resp_sequence # ipv4地址优先，避免NAT占用CPU - exec: prefer_ipv4 - exec: $cache - exec: jump has_resp_sequence - exec: $query_is_local_domain - exec: jump has_resp_sequence - exec: $query_is_no_local_domain - exec: jump has_resp_sequence - exec: $fallback # 启动 udp 服务器。 - tag: udp_server type: udp_server args: entry: main_sequence listen: \u0026#34;:5335\u0026#34; # 启动 tcp 服务器。 - tag: tcp_server type: tcp_server args: entry: main_sequence listen: \u0026#34;:5335\u0026#34; 配置Wireguard 学院的服务器是在内网中的，如果没有连校园网就无法访问。为了随时随地可以访问，我们可以使用Wireguard进行虚拟组网。基于ipv6直接是公网的特点，我们可以很方便的实现这个功能。\n连接路由器，使用命令创建预共享密钥\n1 2 3 4 5 6 7 8 9 10 # 创建目录存放公钥私钥 mkdir wg # 进入文件夹 cd wg # 配置创建密钥的权限 umask 077 # 创建预共享密钥 wg genpsk \u0026gt; sharekey # 获取密钥复制保存 cat sharekey 之后创建服务端公钥私钥\n1 2 3 4 5 6 # 创建服务端公钥和私钥 wg genkey | tee server_privatekey | wg pubkey \u0026gt; server_publickey # 获取服务端私钥复制保存 cat server_privatekey # 获取服务端公钥复制保存 cat server_publickey 之后创建客户端的公钥私钥，有多少个就要执行几次 注意文件的命名，这里以clinet为例：\n1 2 3 4 5 6 # 创建客户端公钥和私钥 wg genkey | tee clinet_privatekey | wg pubkey \u0026gt; clinet_publickey # 获取客户端私钥复制保存 cat clinet_privatekey # 获取客户端公钥复制保存 cat clinet_publickey 之后找到网络——接口——添加新接口，选择协议为WireGuard VPN\n接着修改相应的配置：\n接口基本设置\n私钥 - 上文获取的服务端私钥 监听接口 - 随机一个高位的端口，我这里使用10800 IP地址 - 这里填一个专用的网段 IP，我选择192.168.100.1/24 Peers设置\n选择预共享密钥 - 添加\n公钥 - 填写上文获取的客户端公钥 允许的 IP - 为此客户端分配的固定 IP，我这里是192.168.100.2/32注意不要冲突 预共享密钥 - 填写上文获取的预共享密钥 路由允许的 IP - 勾选 防火墙设置\n选择LAN 之前我尝试自己创建一个VPN分区进行管理，但是无法访问路由器上一层内网的地址，估计是防火墙之前的转发规则没设置好，如果不想折腾就选LAN吧\n之后在防火墙中的——”打开路由器端口“，将之前设置的WireGuard监听端口的UDP流量放行\n这样就算配置好了。\n客户端的配置文件类似下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [Interface] # 对应之前配置的静态地址 Address = 192.168.100.2/32 # 客户端的私钥 PrivateKey = ****** # 本地的 DNS 服务器或者公有 DNS 服务器,例如: 114.114.114.114 #DNS = 192.168.6.1 [Peer] # 路由器公钥 PublicKey = ****** # 设置那些地址走WireGuard，如下设置只用局域网走WireGuard,互联网走本地网络. #AllowedIPs = 192.168.6.0/24, 192.168.100.0/24, 192.168.101.0/24 # 全局模式 AllowedIps = 0.0.0.0/0 # 预共享密钥，同之前所配置 PresharedKey = ****** # 路由器的ip地址和端口 Endpoint = 10.134.10.10:10800 # 每隔多少秒检查一次连接 PersistentKeepalive = 25 配置ddns 虽然我们拥有了公网ipv6，但这是动态的，所以我们需要通过ddns使其自动对应到域名上。以后使用的时候只需要域名即可，无需记住ip。\n237大佬的固件已经内置了ddns，我的域名是在cloudflare上，所以选择DDNS 服务提供商 [IPv6]为cloudflare.com-v4，域名填写需要ddns的域名，注意这里要用@隔离子域名和根，例如ddns@lbqaq.top，密码填写全局访问密钥。\n在高级设置里，我将IP 地址来源 [IPv6]设置为了URL，这样避免了脚本错误读取ip地址的情况。\n都设置好后，就可以看到域名所对应的地址已经被更新了。\n小结 Openwrt作为一个开放的系统，可玩性还是很高的，通过装上所需的插件，极大的提高了我的上网体验，只能说：真香~\n（本来是打算介绍我写的校园网连接程序，结果为了这碟醋包了这盘饺子QwQ）\n更新日志 23.11.22：添加了uboot和mosdns的内容 参考文献 红米AX6000完美刷机 | 刷机无风险 小白适用\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n红米AX6000刷hanwckf大佬的不死uboot+刷回官方固件+TTL使用+编程器救砖教程\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n校园网环境下Openwrt配置ipv6教程——以nat6为例\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-10-21T21:36:58+08:00","image":"https://lbqaq.top/p/ax6000/112545261.webp","permalink":"https://lbqaq.top/p/ax6000/","title":"红米AX6000折腾记"},{"content":"介绍 数据保护最近引起了越来越多的关注，并且已经提出了一些法规来保护个人用户的隐私。在这些法规中，提到了「被遗忘权」，它赋予数据主体从存储数据的实体中删除其数据的权利。这也意味着在机器学习中，模型提供者有义务消除其所有者要求被遗忘的数据的任何影响，即遗忘学习。\n最简单和有效的遗忘学习方法就是移除对应的样本后重新训练模型，然而当底层数据集很大时，这种方法在计算上可能令人望而却步。目前通用的遗忘学习方法是SISA (Sharded, Isolated, Sliced, and Aggregated) ——将训练集分为shards, shards中分为slices, 对于每个slice训练之后记录model parameters, 每个数据点被划分到不同的shards和slices中, unlearn时就是排除掉对应数据点然后retrain对应的shard和slices, 以空间开销换取训练的时间开销。\n对于图像和文本数据，分割数据没有什么问题。然而，对于图来说，GNN依赖于图结构信息，像在SISA中那样将节点随机划分为子图可能会严重损坏生成的模型。对此，作者提出了GraphEraser，以实现GNN中的遗忘学习。\n作者将图遗忘学习分为node unlearning「节点遗忘学习」和edge unlearning「边遗忘学习」，提出了两种图分割策略。第一种侧重于graph structural information「图结构信息」，另一种则是同时考虑graph structural and node feature information「图结构和节点特征信息」。\n为了同时考虑图结构和节点特征信息，作者将节点特征和图结构转化为嵌入向量，然后将其聚类为不同的shards。但是由于现实世界图的结构特性，传统的群落检测和聚类方法划分会导致分片大小不平衡，而大部分需要被撤销的数据都在最大的分区，从而导致效率低下。作者提出了两种分割算法和一种聚合算法以解决此问题。\n贡献 第一次提出了在GNN模型上的遗忘学习方法 提出了两种算法以平衡图分割块大小 提出了一种基于学习的聚合方法 问题构造 问题定义 节点遗忘学习\n对于GNN模型$F_o$，每个数据主体的数据对应于GNN训练图$G_o$中的一个节点。数据主体$u$要删除其所有数据，则意味着从GNN的训练图中遗忘学习$u$的节点特征以及其于其他节点的链接。以社交网络为例，节点遗忘学习意味着需要从目标GNN的训练图中删除用户的个人资料信息和社交关系。\n边遗忘学习\n数据主体$u$要删除其节点于另一个节点$v$之间的一条边缘。仍然以社交网络为例，边缘遗忘意味着社交网络用户想要隐藏他们与另一个人的关系。\n评估指标 unlearning efficiency「遗忘学习效率」：与在训练的时间有关，时间要尽可能短。 model utility「模型效用」：与准确性有关，越高越好。 在之前提过，图分割存在分片大小不均匀的问题。为此，作者提出了两种分片目标：\nG1: Balanced Shards「均衡分片」：每个分片中的节点数量相似。这样，每个分片的再训练时间是相似的，从而提高了整个图遗忘学习过程的效率。 G2: Comparable Model Utility「可比模型效用」：图结构信息是决定GNN性能的主要因素，每个分片都应保留图的结构属性。 GraphEraser框架构造 作者将GraphEraser框架分为三个阶段：\nBalanced Graph Partition「平衡图分区」：将训练图划分为不相交的分片 Shard Model Training「分片训练模型」：对每个分片进行训练一个模型，称之为shard model「分片模型」$F_i$ Shard Model Aggregation「分片模型聚合」：为了得到预测节点$w$的标签，将对应的数据（$w$的特征、其邻居的特征以及其中的图结构）同时发送到所有分片模型，并通过聚合所有分片模型的预测来获得最终预测。 GraphEraser框架的结构图如下所示：\n平衡图分割 作者提出了三种图分区策略：\n策略0：仅考虑节点特征信息，并随机对节点进行分区\n该策略可以满足G1「均衡分片」要求，但不满足G2「可比模型效用」要求\n策略1：依靠community detection「社区发现」，仅考虑结构信息，并尽可能保留它\n策略2：同时考虑结构信息和节点特征。将节点特征和图结构表示为低维向量，即节点嵌入，然后将节点嵌入聚类到不同的分片中。\n直接这样划分会导致划分区域不平衡，如下图所示：\n接下来，作者便介绍了对应的平衡图分区算法。\n社区发现算法 对于策略1，主要依赖的就是此算法。作者基于Label Propagation Algorithm (LPA)「标签传播算法」来设计图分区算法。在本文中，shard就是community。\n标签传播算法\n在初始阶段（图a），每个节点都随机分配一个分片标签。\n在标签传播阶段（图b → 图 c），每个节点都会发送自己的标签，将自己更新成收到最多的那个标签\n标签传播过程会对所有节点进行多次迭代，直到收敛（没有节点更改标签）\n就如之前提到的，传统的LPA会导致高度不平衡的图形分区，严重影响了遗忘学习的效率。\n对此，作者提出了一个实现平衡图分区的一般方法。给定所需的分片大小$k$和最大分片大小$\\delta$，为每个节点-分片定义一个可能被分配到此分片的preference「偏好值」，代表该节点被分配给了分片（这被称为destination shard「目标分片」），从而产生$k \\times n$个偏好值。对这些值进行排序，如果目标分片中的节点数不超过$\\delta$，就将该节点分配给此分片。\n具体而言，作者提出了Balanced LPA (BLPA)「平衡标签传播算法」，将偏好值定义为节点分片对的neighbor counts「邻居计数」（属于目标分片的邻居数量），并且具有较大邻居计数的节点分片对具有更高的优先级分配。\n算法的步骤如下：\n初始化：将每个节点随机分配给k个分片之一 重新分配配置文件计算：对于每个节点$u$，使用元组$\\left\\langle u, \\mathbb{C}_{s r c}, \\mathbb{C}_{d s t}, \\xi\\right\\rangle$表示其重新分配的配置文件，其中$\\mathbb{C}_{s r c}$和$\\mathbb{C}_{d s t}$是节点$u$的当前分片和目标分片，$\\xi$是目标分片$\\mathbb{C}_{d s t}$的邻居计数，并将其存入$\\mathbb{F}$ 排序：邻居数量越多的重新分配配置文件应具有越高的优先级，所以按$\\xi$对$\\mathbb{F}$进行降序排序 传播标签：枚举$\\mathbb{F}$里的所有元素，如果$\\mathbb{C}_{d s t}$的大小不超过给定的阈值$\\delta$，就将其添加到目标分片并从当前分片中删除。之后在$\\mathbb{F}$中删除所有剩余的包含节点$u$的元组。 之后不断迭代，直到分片不更改或达到最大迭代$T$\n算法的时间复杂度为$O(n·d_{ave})$，$n$为节点数，$d_{ave}$为训练图的平均节点数。\n作者无法从理论上证明其收敛性，不过通过实验表示$T=30$时几乎是收敛的。\n嵌入式聚类算法 对于策略2，作者使用预训练的GNN模型来获取所有节点嵌入，然后对生成的节点嵌入执行聚类。\n思路是将GNN模型的所有节点投影到空间中，再使用K-Means进行聚类。同样也会导致分块的不平均这个问题。\n对此，作者提出了Balanced Embedding k-means (BEKM)。定义preference「偏好值」为节点嵌入和所有节点分片对的分片质心之间的欧氏距离。\n具体的算法如下：\n初始化：随机选择$k$个质心$C^0=\\{C^0_1,C^0_2,\\dots,C^0_k\\}$ 计算嵌入质心距离：计算节点嵌入和质心之间的所有成对距离，从而得到$n\\times k$个嵌入质心对。这些对存储在$\\mathbb{F}$中。 排序质心距离：距离较近的嵌入质心对具有更高的优先级，所以按照升序对$\\mathbb{F}$进行排序 重新分配节点和更新质心：枚举$\\mathbb{F}$里的所有元素，如果$\\mathbb{C}_{j}$的大小不超过给定的阈值$\\delta$，就将其添加到目标分片。之后在$\\mathbb{F}$中删除所有剩余的包含节点$i$的元组。最后，将新质心计算为其相应分片中所有节点的平均值。 同样，不断重复直到分片不更改或达到最大迭代$T$\n算法的时间复杂度为$O(k·n)$，$n$个节点,$k$个分片。\n基于学习的聚合 目前常见的聚合方式有两种：\nMajAggr：每个分片模型预测一个标签，取最多预测的标签 MeanAggr：收集所有分片模型的后验向量，然后求平均值，得到聚合后验，选取最高后验值。 作者提出了一种基于学习的聚合方法LBAggr，为每个分片模型分配一个重要性分数，通过以下损失函数进行学习：\n$$\\min \\_{\\alpha} \\underset{w \\in \\mathcal{G}\\_{o}}{\\mathbb{E}}\\left[\\mathcal{L}\\left(\\sum\\_{i=0}^{m} \\alpha\\_{i} \\cdot \\mathcal{F}\\_{i}\\left(X\\_{w}, \\mathcal{N}\\_{w}\\right), y\\right)\\right]+\\lambda \\sum\\_{i=0}^{m}\\left\\|\\alpha\\_{i}\\right\\|$$其中$X_{w}$和$\\mathcal{N}_{w}$是训练图中节点$w$的特征向量和邻域，$y$是$w$的真实标签，$\\mathcal{F}_{i}(\\cdot)$表示分片模型$i$，$\\alpha_{i}$是$\\mathcal{F}_{i}(\\cdot)$的重要性得分，$m$是分片总数。将所有重要性分数的总和调节为 1。\n作者通过梯度下降来找到最优的$\\alpha$，从而解决最优化问题。然而，直接梯度下降会导致$\\alpha$为负数。为了解决此问题，作者使用softmax 函数在每次迭代中进行归一化处理。\n为了提升运行速度，作者指出可以使用训练图中 10% 的节点进行重新训练。\nGraphEraser 将上面提到的方法集合在一起，就得到了此算法。当某些节点或边缘被数据所有者撤销时，只需要重新训练相应的分片模型即可。\n评估 数据集\n作者采用了五个常用的图像数据集，分别为Cora, Citeseer, Pubmed, CS和Physics。\n模型\n作者在四个GNN模型上进行了测试，分别是SAGE，GCN，GAT和GIN。每个模型都经过100轮的训练，默认学习率设置为0.01，权重衰减为0.001。\n指标\n在问题构造中提过，就是遗忘学习效率和模型效用\n遗忘学习效率：计算100个独立遗忘学习请求的平均遗忘学习时间。 模型效用：使用F1得分 基线\nScratch「从头开始训练」 Random「随机分区」 实验设置\n将整个图分为两个不相交的部分，其中80%的节点用于训练GNN模型，20%的节点用于评估模型效用。\n分片大小$k$设为20, 20, 50, 30, 和 100\n片中节点最大个数$\\delta$设为$\\left \\lceil \\frac{n}{k} \\right \\rceil $\n最大迭代次数$T$设为30\nBLPA对应社区发现算法；BEKM对应嵌入式聚类算法\n遗忘学习效率评估 如图所示，BLPA和BEKM相对于从头训练模型，可以显著的减少训练的时间。\n相对于Random，时间略长是因为存在更长的图分割成本。BLPA 和 BEKM 都需要多次迭代以保留结构信息。但一旦完成图分割，就会将其固定下来。从这个意义上说，我们可以容忍这种代价，因为它只执行一次。\n模型效用评分 绿色底色表示不需要聚合，红色底色表示作者提出的方法，蓝色字体表示最优得分。\n有些随机得分和BLPA和BEKM差不多，作者认为这时由于图结构信息在GNN模型中作用不大导致的。\n对此，作者提出了一个方法选择的技巧：可以首先比较MLP和GNN的F1分数，如果MLP和GNN之间的F1分数差距很小，随机方法可能是一个不错的选择，因为它更容易实现，并且可以实现与BLPA和BEKM相当的模型效用。否则，BLPA和BEKM是更好的选择，因为更好的模型实用程序。\n如果 GNN 遵循 GCN 结构，则可以选择BLPA，否则可以采用 BEKM。这是因为 GCN 模型需要节点度信息来进行归一化，而BLPA 可以保留更多的局部结构信息，从而更好地保留节点度。\nBEKM 在 Cora 数据集和 GIN 模型上的 F1 得分为 0.801，而 Scratch 的相应 F1 得分为 0.787。作者认为有两种可能的原因：抽样往往可以消除数据集中的一些“噪声”；其次，GraphEraser通过聚合所有子模型的结果来进行最终预测，从这个意义上说，GraphEraser执行集成，这是提高模型性能的另一种方法。\nLBAggr 的效果 有效，可以提升F1分数。\n比较不同的GNN模型，GCN从LBAggr中受益最大，而GIN受益最少。在模型效用方面，GraphEraser-BLPA方法从LBAggr中受益最大。我们推测这是因为BLPA划分方法可以捕获局部结构信息，同时丢失训练图的一些全局结构信息。\n为了进一步提高忘却效率，可以使用训练图中的一小部分节点来学习重要性分数。这样做可以有效地减少 LBAggr 的遗忘学习时间。使用 10% 的节点和使用固定数量的 1，000 个节点都可以实现与使用所有节点相当的模型效用。\n和其他遗忘学习方法对比 同样，也是作者的方法比较好。\n","date":"2023-09-13T16:38:20+08:00","image":"https://lbqaq.top/p/graph-unlearning/110091745.webp","permalink":"https://lbqaq.top/p/graph-unlearning/","title":"Graph Unlearning"},{"content":"随着学习的深入，对算力的要求越来越高。但我实验室的电脑并没有配置显卡，所以便需要使用学院的服务器。成功拿到账号后，却发现这个平台并没有我想象的那么好用😇为了达到最舒适的使用体验，开搞！\n配置开发镜像 平台里虽然预置了一些开发环境，但仍然缺少一些需要的软件，每次连入后再重新安装实在是不优雅。那么最好的方案就是配置好一套环境，直接拉取就能使用。在我之前，已经有位大佬构建了一套开发环境并进行了分享，可是镜像大小达到了惊人的18.4G😯（容量大说明功能多，此处并没有贬低的意思）。我个人比较喜欢Arch的哲学，即Keep It Simple, Stupid（对应中文为“保持简单，且一目了然”）。为此，我决定构建一个最小化的开发环境且可以开箱即用。\n通过探究发现，这个平台上所有的开发环境都是一个Docker容器。所以，我们只要构建好镜像并上传就OK了。构建镜像有两种方式，一种是进入容器手动配置然后使用docker commit ...保存修改；另一种则是使用Dockerfile。为了便于维护和修改，我选择了第二种。\n接下来就是明确需求了，我对其的要求有几点：\n安装好显卡驱动，可以直接使用cuda 安装好conda，可以便捷的管理python开发环境 有一个易用的终端，方便调试 cuda很好解决，直接在nvidia官方的镜像上进行修改就行了\n对于conda，原版的Anaconda过于臃肿，不符合KISS原则。同时，当环境复杂(conda和pip混用)时，solving environment这一步可以卡到你怀疑人生，于是我选择了使用C++重构的mamba，并选择micromamba进一步压缩体积。\n对于终端，那就无脑使用zsh并加载oh-my-zsh并安装我日常使用的插件。\n如此一来，就可以开写Dockerfile了。\n📃展开代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 # base image FROM nvidia/cuda:11.3.1-cudnn8-runtime-ubuntu20.04 MAINTAINER luoboQAQ # 设置国内镜像源并安装软件 RUN set -ex \\ \u0026amp;\u0026amp; sed -i \u0026#39;s@/archive.ubuntu.com/@/mirrors.bfsu.edu.cn/@g\u0026#39; /etc/apt/sources.list \\ \u0026amp;\u0026amp; apt-get clean \\ \u0026amp;\u0026amp; apt-get update \\ \u0026amp;\u0026amp; apt-get install -y --no-install-recommends openssh-client openssh-server git zsh curl vim \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/*\t# 配置openssh[https://github.com/wjyzzu/inpsur-dockerfile/blob/main/base/ubuntu/Dockerfile] RUN set -ex \\ \u0026amp;\u0026amp; mkdir -p /var/run/sshd \\ \u0026amp;\u0026amp; /usr/bin/ssh-keygen -A \\ \u0026amp;\u0026amp; cat /etc/ssh/ssh_config | grep -v StrictHostKeyChecking \u0026gt; /etc/ssh/ssh_config.new \\ \u0026amp;\u0026amp; echo \u0026#34; StrictHostKeyChecking no\u0026#34; \u0026gt;\u0026gt; /etc/ssh/ssh_config.new \\ \u0026amp;\u0026amp; cat /etc/ssh/sshd_config | grep -v PermitRootLogin\u0026gt; /etc/ssh/sshd_config.new \\ \u0026amp;\u0026amp; echo \u0026#34;PermitRootLogin yes\u0026#34; \u0026gt;\u0026gt; /etc/ssh/sshd_config.new \\ \u0026amp;\u0026amp; mv /etc/ssh/ssh_config.new /etc/ssh/ssh_config \\ \u0026amp;\u0026amp; mv /etc/ssh/sshd_config.new /etc/ssh/sshd_config # 配置oh-my-zsh RUN set -ex \\ \u0026amp;\u0026amp; git clone https://gitee.com/mirrors/oh-my-zsh ~/.oh-my-zsh \\ \u0026amp;\u0026amp; cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc \\ \u0026amp;\u0026amp; git clone https://gitee.com/lightnear/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting \\ \u0026amp;\u0026amp; sed -i \u0026#34;s/plugins=(git.*)$/plugins=(git zsh-syntax-highlighting)/\u0026#34; ~/.zshrc \\ \u0026amp;\u0026amp; chsh -s /bin/zsh \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 安装micromamba并配置国内源 RUN set -ex \\ \u0026amp;\u0026amp; curl -Ls https://micro.mamba.pm/api/micromamba/linux-64/latest | tar -xvj bin/micromamba \\ \u0026amp;\u0026amp; ./bin/micromamba shell init -s zsh -p ~/micromamba \\ \u0026amp;\u0026amp; echo \u0026#34;\\nalias conda=\u0026#39;micromamba\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.zshrc \\ \u0026amp;\u0026amp; echo \u0026#34;channels: \\n\\ - defaults \\n\\ show_channel_urls: true \\n\\ default_channels: \\n\\ - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main \\n\\ - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r \\n\\ - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2 \\n\\ custom_channels: \\n\\ conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud \\n\\ msys2: https://mirrors.bfsu.edu.cn/anaconda/cloud \\n\\ bioconda: https://mirrors.bfsu.edu.cn/anaconda/cloud \\n\\ menpo: https://mirrors.bfsu.edu.cn/anaconda/cloud \\n\\ pytorch: https://mirrors.bfsu.edu.cn/anaconda/cloud \\n\\ pytorch-lts: https://mirrors.bfsu.edu.cn/anaconda/cloud \\n\\ simpleitk: https://mirrors.bfsu.edu.cn/anaconda/cloud \\n\\ deepmodeling: https://mirrors.bfsu.edu.cn/anaconda/cloud/\u0026#34; \u0026gt; ~/.condarc \\ \u0026amp;\u0026amp; echo \u0026#34;[global] \\n\\ index-url = https://mirrors.bfsu.edu.cn/pypi/web/simple\u0026#34; \u0026gt; /etc/pip.conf # 配置网络代理 RUN set -ex \\ \u0026amp;\u0026amp; echo \u0026#34;\\nexport HTTP_PROXY=\u0026#39;http://127.0.0.1:3128\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.zshrc \\ \u0026amp;\u0026amp; echo \u0026#34;export HTTPS_PROXY=\u0026#39;http://127.0.0.1:3128\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.zshrc \\ \u0026amp;\u0026amp; echo \u0026#34;export ALL_PROXY=\u0026#39;http://127.0.0.1:3128\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.zshrc EXPOSE 22 WORKDIR /root ENTRYPOINT [\u0026#34;/bin/zsh\u0026#34;] 除了上面提到的几点，我还增加了：\n镜像已配置好国内镜像源，方便构建以及使用时安装新的包 配置openssh，使其可以被浪潮平台接入并提供SSH服务 预先安装好vim，便于配置文件的修改 提前设置好网络代理，便于连接互联网 设置别名：conda-\u0026gt;micromamba，方便日常使用 由于服务器没有网络，需要我们手动上传镜像，使用命令docker save -o [TAGS]打包成tar包并上传至系统中。\n小结 希望这篇文章可以帮助大伙快速上手该平台，毕竟有这么好的资源就要好好利用起来。\n","date":"2023-09-03T14:10:14+08:00","image":"https://lbqaq.top/p/langchao/102879503.webp","permalink":"https://lbqaq.top/p/langchao/","title":"浪潮人工智能平台使用心得"},{"content":"之前写过一篇关于Magisk模块的编写的文章，不过Magisk修改的都是比较偏系统的，一般情况下用的并不是很多。于是我便把目光转向Xposed，毕竟会Hook真的太酷辣😎\nXposed的基本概念 提到Xposed，爱玩机的用户都应该听过他的大名，作为一款可以在不修改APK的情况下影响程序运行的框架，可以基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。微信防撤回、步数修改、去广告、美化\u0026hellip;\u0026hellip;.他能实现许许多多的功能，可以说没有它玩机的世界将会少很多的乐趣。\n它的原理就是通过替换系统原本的app_process，加载一个额外的jar包，从而实现对zygote进程及其创建的Dalvik/ART虚拟机的劫持。\n没听懂？没关系，我也不懂。目前我们只要关注如何使用即可了，至于原理可以先放一放。\n环境准备 在开始之前，我们需要：\n一台可以安装Xposed框架的手机（推荐LSPosed、Android 10+） 一台可以编写代码并且装有jdk的电脑 一个名叫Android Studio的软件（我主打一个叛逆，用IDEA同样可以） 一个反编译软件，如：JADX 一个可以查看布局的App，如：开发者助手 这次我打算从一个实例出发：小明手机上装了一些恶意软件，我们需要通过Xposed进行Hook，不让小明启动这些软件。\n准备工作 创建项目\u0026amp;引入依赖 首先在IDEA选择新建项目，可以看到生成器下有Android这项，我们选择它。\n第一次选择时可能会要求你下载安卓的SDK，按照指示一步一步进行就好。\nJava 我们选择创建一个No Activity，语言选择Java，SDK选默认的API 24就可。\n然后，我们需要引入Xposed的库，不过它并没有上传到MavenCentral上，所以我们需要在settings.gradle里修改一下(gradle 7.0+)\n打开settings.gradle，添加一行代码\n1 2 3 4 5 6 7 8 dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() maven { url \u0026#39;https://api.xposed.info/\u0026#39; } // 添加这一行即可 } } 之后，进入我们app目录下的build.gradle，引入xposed的依赖\n1 2 3 4 dependencies { compileOnly \u0026#39;de.robv.android.xposed:api:82\u0026#39; //添加我 // compileOnly \u0026#39;de.robv.android.xposed:api:82:sources\u0026#39; // 不要导入源码，这会导致idea无法索引文件，从而让语法提示失效 } 我们还要在./app/src/main/res/values目录下创建arrays.xml，填入下面的内容：\n1 2 3 4 5 6 7 8 \u0026lt;resources\u0026gt; \u0026lt;string-array name=\u0026#34;xposedscope\u0026#34; \u0026gt; \u0026lt;!-- 这里填写模块的作用域应用的包名，可以填多个。 --\u0026gt; \u0026lt;item\u0026gt;ceui.lisa.pixiv\u0026lt;/item\u0026gt; \u0026lt;item\u0026gt;com.xjs.ehviewer\u0026lt;/item\u0026gt; \u0026lt;item\u0026gt;com.picacomic.fregata\u0026lt;/item\u0026gt; \u0026lt;/string-array\u0026gt; \u0026lt;/resources\u0026gt; 这一步主要是指定模块的作用域包名，效果就是在Lsposed中勾选作用域时会在应用下提示推荐应用。\n最后，我们在Run那里编辑一下启动配置，勾选Always install with package manager并且将Launch Options改成Nothing\nKotlin 创建项目的部分和Java的设置没有什么区别，只不过是需要将语言切换一下。新版本的Android Studio将原来的打包语言换成了Kotlin，所以我们的设置有一些不一样的地方。2024.09.15更新\n原来的settings.gradle变为settings.gradle.kts\n1 2 3 4 5 6 7 8 dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() mavenCentral() maven { url = uri(\u0026#34;https://api.xposed.info/\u0026#34;) } //添加这一行 } } 原来的build.gradle变为build.gradle.kts\n1 2 3 dependencies { compileOnly(\u0026#34;de.robv.android.xposed:api:82\u0026#34;) //添加我 } 声明模块 接下来就是要声明我们是一个Xposed模块，方便框架发现。\n在./app/src/main/AndroidManifest.xml里，我们将\u0026lt;application ... /\u0026gt;改成以下形式（注意，是改成！就是把结尾的/\u0026gt;换成\u0026gt; \u0026lt;/application\u0026gt;）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;application ... \u0026gt; \u0026lt;!-- 是否是xposed模块，xposed根据这个来判断是否是模块 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedmodule\u0026#34; android:value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- 模块描述，显示在xposed模块列表那里第二行 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposeddescription\u0026#34; android:value=\u0026#34;不可以涩涩\u0026#34; /\u0026gt; \u0026lt;!-- 最低xposed版本号(lib文件名可知,一般填54即可) --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedminversion\u0026#34; android:value=\u0026#34;54\u0026#34; /\u0026gt; \u0026lt;!-- 模块作用域 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedscope\u0026#34; android:resource=\u0026#34;@array/xposedscope\u0026#34;/\u0026gt; \u0026lt;/application\u0026gt; 然后在src/main目录下创建一个文件夹名叫assets，并且创建一个文件叫xposed_init，注意，它没有后缀名！！。\n接着我们需要创建一个入口类，名叫MainHook（或者随便你想取什么名字都行），创建好后回到我们的xposed_init里并用文本文件的方式打开它，输入我们刚刚创建的类的完整路径。如：top.lbqaq.nosese.MainHook，同时注意大小写。\n完成以上步骤后，我们就可以正式开始编写Xposed模块了。\n模块编写 MainHook 在MainHook里，我们需要实现Xposed的IXposedHookLoadPackage接口，以便执行Hook操作。将以下内容替换原来的类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class MainHook implements IXposedHookLoadPackage { @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { // 过滤不必要的应用 if (!lpparam.packageName.equals(\u0026#34;ceui.lisa.pixiv\u0026#34;)) return; // 执行Hook hook(lpparam); } private void hook(XC_LoadPackage.LoadPackageParam lpparam) { // 具体流程 } } 对于Kotlin，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import de.robv.android.xposed.IXposedHookLoadPackage import de.robv.android.xposed.callbacks.XC_LoadPackage class MainHook : IXposedHookLoadPackage { override fun handleLoadPackage(lpparam: XC_LoadPackage.LoadPackageParam) { // 过滤不必要的应用 if (lpparam.packageName != \u0026#34;ceui.lisa.pixiv\u0026#34;) return // 执行Hook hook(lpparam) } private fun hook(lpparam: XC_LoadPackage.LoadPackageParam) { // 具体流程 } } 到这里，我们的准备工作已经完成，安装模块并在框架中激活它！\n阻止应用启动 接下来，我们需要反编译程序来找到需要Hook的点。根据实例的要求，我们需要阻止小明启动某些应用。那么，我们只需要Hook启动函数，让其无法运行即可。\n在此之前，我们要先了解Android的四大组件之一——\u0026ldquo;Activity(活动)\u0026rdquo;\n在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。\n函数名称 描述 onCreate() 一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。 onStart() 当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。 onResume() 这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。 onPause() 这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。 onStop() 这个方法是在Activity完全不可见的时候调用的。 onDestroy() 这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。 onRestart() 当Activity从停止stop状态恢进入start状态时调用状态。 当 Activity 进入新状态时，系统会调用其中每个回调。\n那么，我们的思路就很明确了：只要找到这些程序的起始Activity，并Hook它的onCreate()函数，在其启动时就将其杀死，这样能实现无法启动该程序。\n我们使用开发者助手，选择布局查看，然后打开目标应用。可以看到，它显示了当前的包名和当前Activity。\n接下来，我们使用jadx-gui，反编译该应用，找到该Activity(ceui.lisa.activities.MainActivity)，并寻找是否有onCreate()函数，如果存在直接Hook即可。\n然而，这个程序居然没有😥，说明它没有重写该方法，那该如何做呢？这时就可以用第二种方法了。\n遍历所有类下的所有方法 从标题就能看出来，我直接把你所有能Hook的方法全部读出来，那不就随便我挑了嘛。\n我们知道，Java程序都运行在jvm虚拟机中，jvm虚拟机通过ClassLoader动态装载所需的class。那么，我们直接Hook ClassLoader ，不就知道你有哪些方法被加载进来了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public void hook(XC_LoadPackage.LoadPackageParam lpparam) { XposedHelpers.findAndHookMethod(ClassLoader.class, \u0026#34;loadClass\u0026#34;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Class clazz = (Class) param.getResult(); String clazzName = clazz.getName(); //排除非包名的类 if(clazzName.contains(\u0026#34;ceui.lisa\u0026#34;)){ Method[] mds = clazz.getDeclaredMethods(); for(int i =0;i\u0026lt;mds.length;i++){ final Method md = mds[i]; int mod = mds[i].getModifiers(); //去除抽象、native、接口方法 if(!Modifier.isAbstract(mod) \u0026amp;\u0026amp; !Modifier.isNative(mod) \u0026amp;\u0026amp;!Modifier.isAbstract(mod)){ XposedBridge.hookMethod(mds[i], new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.d(\u0026#34;lbqaq\u0026#34;,md.toString()); } }); } } } } }); } （PS：这个程序很奇怪，包名有pixiv，但类名没有，所以用ceui.lisa.pixiv会报空指针异常）\n将上面这段代码复制到之前写好的MainHook中去，编译推送到手机。\n在终端执行adb logcat \u0026quot;lbqaq:D *:S\u0026quot;开启logcat并进行过滤。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ❯ adb logcat \u0026#34;lbqaq:D *:S\u0026#34; --------- beginning of main 07-21 10:49:48.185 5050 5050 D lbqaq : public void ceui.lisa.activities.Shaft.onCreate() 07-21 10:49:48.194 5050 5050 D lbqaq : private void ceui.lisa.activities.Shaft.updateTheme() 07-21 10:49:48.216 5050 5050 D lbqaq : public static android.content.Context ceui.lisa.activities.Shaft.getContext() 07-21 10:49:48.238 5050 5050 D lbqaq : protected int ceui.lisa.activities.MainActivity.initLayout() 07-21 10:49:48.238 5050 5050 D lbqaq : public boolean ceui.lisa.activities.MainActivity.hideStatusBar() 07-21 10:49:48.276 5050 5050 D lbqaq : protected void ceui.lisa.activities.MainActivity.initView() 07-21 10:49:48.276 5050 5050 D lbqaq : public static com.tencent.mmkv.MMKV ceui.lisa.activities.Shaft.getMMKV() 07-21 10:49:48.276 5050 5050 D lbqaq : private void ceui.lisa.activities.MainActivity.initDrawerHeader() 07-21 10:49:48.278 5050 5050 D lbqaq : public androidx.drawerlayout.widget.DrawerLayout ceui.lisa.activities.MainActivity.getDrawer() 07-21 10:49:48.279 5050 5050 D lbqaq : protected void ceui.lisa.activities.MainActivity.initData() 07-21 10:49:48.279 5050 5050 D lbqaq : private void ceui.lisa.activities.MainActivity.initFragment() 可以看到该程序的调用方法。这里，我们选择靠后的ceui.lisa.activities.MainActivity.initFragment()作为我们的Hook目标。\n为什么要选择靠后的方法作为我们的Hook目标呢？\n这是由于如果选择较前的方法，有些变量还没初始化完成，这时调用finish()可能会报错。\nHook activity 我们使用最基础的hook方式，即Xposed自带的XposedHelpers.findAndHookMethod，使用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private void hook(XC_LoadPackage.LoadPackageParam lpparam) { // 它有两个重载，区别是一个是填Class，一个是填ClassName以及ClassLoader // 第一种 填ClassName XC_MethodHook.Unhook unhook = XposedHelpers.findAndHookMethod(\u0026#34;me.kyuubiran.xposedapp.MainActivity\u0026#34;, // className lpparam.classLoader, // classLoader 使用lpparam.classLoader \u0026#34;onCreate\u0026#34;, // 要hook的方法 Bundle.class, // 要hook的方法的参数表，如果有多个就用逗号隔开 new XC_MethodHook() { // 最后一个填hook的回调 @Override protected void beforeHookedMethod(MethodHookParam param) {} // Hook方法执行前 @Override protected void afterHookedMethod(MethodHookParam param) {} // Hook方法执行后 }); // 它返回一个unhook 在你不需要继续hook的时候可以调用它来取消Hook unhook.unhook(); // 取消空的Hook // 第二种方式 填Class // 首先你得加载它的类 我们使用XposedHelpers.findClass即可 参数有两个 一个是类名 一个是类加载器 Class\u0026lt;?\u0026gt; clazz = XposedHelpers.findClass(\u0026#34;me.kyuubiran.xposedapp.MainActivity\u0026#34;, lpparam.classLoader); XposedHelpers.findAndHookMethod(clazz, \u0026#34;onCreate\u0026#34;, Bundle.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param){ // 由于我们需要在Activity创建之后再弹出Toast，所以我们Hook方法执行之后 Toast.makeText((Activity) param.thisObject, \u0026#34;模块加载成功！\u0026#34;, Toast.LENGTH_SHORT).show(); } }); } 根据上面的示例，我们就可以写出对应的方法了。那么，我们该如何结束这个程序呢？在前面我们介绍了Activity的生存周期，通过查询可知Activity存在一个关闭的方法finish()。所以我们只要手动调用即可，具体的代码如下。\n1 2 3 4 5 6 7 8 9 if (lpparam.packageName.equals(\u0026#34;ceui.lisa.pixiv\u0026#34;)){ XposedHelpers.findAndHookMethod(\u0026#34;ceui.lisa.activities.MainActivity\u0026#34;, lpparam.classLoader, \u0026#34;initFragment\u0026#34;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { Toast.makeText((Activity) param.thisObject, \u0026#34;不许涩涩！\u0026#34;, Toast.LENGTH_SHORT).show(); ((Activity) param.thisObject).finish(); } }); } 同样，另外两个应用也可以通过这种方式实现\n1 2 3 4 5 6 7 8 9 if(lpparam.packageName.equals(\u0026#34;com.xjs.ehviewer\u0026#34;)){ XposedHelpers.findAndHookMethod(\u0026#34;com.hippo.ehviewer.ui.MainActivity\u0026#34;, lpparam.classLoader, \u0026#34;initUserImage\u0026#34;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { Toast.makeText((Activity) param.thisObject, \u0026#34;不许涩涩！\u0026#34;, Toast.LENGTH_SHORT).show(); ((Activity) param.thisObject).finish(); } }); } 1 2 3 4 5 6 7 8 9 if(lpparam.packageName.equals(\u0026#34;com.picacomic.fregata\u0026#34;)){ XposedHelpers.findAndHookMethod(\u0026#34;com.picacomic.fregata.activities.SplashActivity\u0026#34;, lpparam.classLoader, \u0026#34;onCreate\u0026#34;, Bundle.class ,new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { Toast.makeText((Activity) param.thisObject, \u0026#34;不许涩涩！\u0026#34;, Toast.LENGTH_SHORT).show(); ((Activity) param.thisObject).finish(); } }); } 这里要注意，使用findAndHookMethod时要hook的方法的参数表一定要填对。如果没有填对就会报java.lang.NoSuchMethodError错误。我之前被这个问题折磨了很久😭（仔细想想也是这样，Java里有重载机制，参数不同就不是同一个方法了）\nkotlin所对应的代码如下：\n1 2 3 4 5 6 7 8 9 if (lpparam.packageName == \u0026#34;com.xjs.ehviewer\u0026#34;){ XposedHelpers.findAndHookMethod(\u0026#34;com.hippo.ehviewer.ui.MainActivity\u0026#34;, lpparam.classLoader, \u0026#34;initUserImage\u0026#34;,object : XC_MethodHook() { override fun afterHookedMethod(param: MethodHookParam){ Toast.makeText(param.thisObject as Activity,\u0026#34;不许涩涩！\u0026#34;,Toast.LENGTH_SHORT).show() (param.thisObject as Activity).finish() } }) } 修改内部参数 虽然一股脑关闭程序非常简单，但小明不乐意了。对于ceui.lisa.pixiv来说，只有长按头像才会触发，直接一刀切实在是太粗暴了。没问题，直接安排上。\n首先我们要定位到这个切换的方法究竟在哪？仔细观察，每次切换都会弹出一个颜文字的Toast，我们就从此处切入。这两个颜文字分别为ԅ(♡﹃♡ԅ)和X﹏X。\n我们使用jadx-gui反编译程序，全局搜索，直接就找到了所在位置。\n双击查看此处的代码，坏起来了，这是一个匿名函数，根据上面的方法，我们没有这个函数名，自然也就无法对其进行Hook。\n难道就要卡在这里了吗？如果真是这样我就不会写这篇文章了\n仔细分析这段代码，这里对this.userHead设置了一个OnLongClickListener。一个控件只能绑定一个侦听器，所以我们可以进行一个替换，不就实现对其的Hook了吗😎\n直接Hook initView这个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (lpparam.packageName.equals(\u0026#34;ceui.lisa.pixiv\u0026#34;)){ XposedHelpers.findAndHookMethod(\u0026#34;ceui.lisa.activities.MainActivity\u0026#34;, lpparam.classLoader, \u0026#34;initView\u0026#34;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { Field f = param.thisObject.getClass().getDeclaredField(\u0026#34;userHead\u0026#34;); f.setAccessible(true); ImageView v = (ImageView) f.get(param.thisObject); // v.setLongClickable(false); //设置其无法响应 v.setOnLongClickListener(v1 -\u0026gt; { Toast.makeText((Activity) param.thisObject, \u0026#34;不许涩涩！\u0026#34;, Toast.LENGTH_SHORT).show(); return true; }); } }); } 我们这里使用了Java的反射机制，拿到了它内部的变量userHead，然后通过setAccessible将其设置为可访问。这样我们就能对其私有变量进行修改了。\n我们可以简单的将其可点击关闭，但是这样一点也不酷。我直接使用自己的函数将其进行替换，这样每次点击都会出现一个Toast。\nkotlin的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 if (lpparam.packageName == \u0026#34;ceui.lisa.pixiv\u0026#34;){ XposedHelpers.findAndHookMethod(\u0026#34;ceui.lisa.activities.MainActivity\u0026#34;, lpparam.classLoader, \u0026#34;initView\u0026#34;,object : XC_MethodHook() { override fun afterHookedMethod(param: MethodHookParam){ val f = param.thisObject.javaClass.getDeclaredField(\u0026#34;userHead\u0026#34;) f.isAccessible = true val v = f[param.thisObject] as ImageView v.setOnLongClickListener{ Toast.makeText(param.thisObject as Activity,\u0026#34;不许涩涩！\u0026#34;,Toast.LENGTH_SHORT).show() true } } }) } 至此，一个简单的Xposed模块就写好了。\n配置文件读取 现在的模块往往还会搭配一个UI来实现配置文件的设置，在安卓开发中，常用SharedPreferences来实现配置的保存。随着google的更新，现在的配置文件无法设置MODE_WORLD_READABLE的权限，即只允许本应用读取。虽然Xposed本身提供了XSharedPreferences来读取配置文件，然而模块是依附于宿主程序所执行的，它的访问权限和宿主一致，所以无法访问到我们的配置文件。2024.09.15更新\n好在目前常用的框架LSPosed提供了New XSharedPreferences，我们只需要指定xposedAPI的最低版本≥93就可以了。\n在AndroidManifest.xml里将xposedminversion的值改为93\n对于模块的Activity来说，我们只需要指定权限为Context.MODE_WORLD_READABLE即可\n1 val sharedPreferences : SharedPreferences = getSharedPreferences(\u0026#34;config\u0026#34;, Context.MODE_WORLD_READABLE) 对于hook的应用来说，我们使用原来的XSharedPreferences即可\n1 val xsp = XSharedPreferences(\u0026#34;top.lbqaq.nosese\u0026#34;,\u0026#34;config\u0026#34;) 结语 完整的项目代码可以在Github仓库中查看，通过这次的编写，我发现Xposed实际上还是一个工具，想要实现去广告等功能，都是通过反编译来找到突破口，有了Hook的目标后才需要Xposed。\n所以，之后的学习还是要以安卓逆向为主，只有打好基本功，才能写出优秀的代码。\n后续更新 2024.09.15 将项目使用了目前流行的Kotlin重构了一波，并添加了UI和模块的配置读取的内容\n参考文献 《安卓逆向这档事》七、Sorry，会Hook真的可以为所欲为-Xposed快速上手(上)模块编.. - 吾爱破解\nXposed模块开发入门保姆级教程 - 狐言狐语和仙贝的魔法学习记录\n《安卓逆向这档事》四、恭喜你获得广告\u0026amp;弹窗静默卡 - 吾爱破解\n《安卓逆向这档事》八、Sorry，会Hook真的可以为所欲为-Xposed快速上手(下)模块编.. - 吾爱破解\n","date":"2023-07-21T14:22:44+08:00","image":"https://lbqaq.top/p/init-xposed/109457609.webp","permalink":"https://lbqaq.top/p/init-xposed/","title":"从零开始编写Xposed模块"},{"content":"介绍 在大数据时代，机器学习（ML）为我们的生活提供了便利，并在各个领域发挥着不可或缺的作用。随着深度学习应用场景的丰富和数据的增长，主流云提供商（如谷歌、亚马逊和微软）推出了机器学习即服务（MLaaS）。\nMLaaS 顾名思义，MLaaS是一系列提供机器学习工具作为云计算服务一部分的服务。 这些服务的主要吸引力在于，就像其他任何云服务一样，客户无需安装软件或配置自己的服务器即可快速开始机器学习。它帮助资源和专业知识有限的数据所有者（小型企业或个人）解决数据处理、模型训练和评估等基础设施问题。模型提供者通过根据查询时间向用户收费来获得收益。\n然而，MLaaS却容易受到模型提取攻击的影响。如下图所示，虽然模型托管在安全的云服务中，客户通过基于云的API进行查询。但是，攻击者可以基于预测输出来训练具有目标私有模型类似功能的替代模型。用户可以通过访问替代模型而无需向模型提供者付费，从而破坏了其商业价值。此外，攻击者还可以利用替代模型来制作优秀的可转移对抗性示例，从而有效地欺骗原始模型做出错误的预测，构成严重的安全威胁。\n作者提出了APMSA来防御模型提取攻击。当攻击者窃取服务器中部署的 \u0026ldquo;model under attack\u0026rdquo; (MUA) 时，通过发散给定特定类别的特征空间中查询样本的置信向量距离，就会泄露足够的MUA内部信息，有利于替代模型的训练。对此，作者在MUA 之前将微妙的噪声注入每个传入的输入查询中，以限制其置信向量的多样性。\n相关研究 目前，将对于模型提取攻击的防御通常可分为两类：被动防御和主动防御。 前者是被动地检测恶意查询行为，然后限制或拒绝为更可能来自攻击者的恶意传入查询提供推理服务。 后者主要是指主动置信扰动技术。本文介绍的APMSA属于主动防御技术，作者将相关的文章进行了整理，如下表所示。\nModel extraction warning in MLaaS paradigm PRADA: Protecting against DNN model stealing attacks Defending against model stealing attacks with adaptive misinformation Defending against neural network model stealing attacks using deceptive perturbations BODAME: Bilevel optimization for defense against model extraction Prediction poisoning: Towards defenses against DNN model stealing attacks Model stealing defense with hybrid fuzzy models: Work-in-progress 与现有的直接置信扰动技术相比，APMSA不仅保留了MUA的可用性，还保留了MUA的实用性。与其他主动防御相比，APMSA可以简单地在MUA之前插入，而无需对MUA本身进行任何修改，因此它是通用的，易于部署的。\n贡献 通过建设性地最小化对训练替代模型至关重要的发散置信度信息来禁用被盗模型的可用功能。 通过形式化的优化实现了置信向量对 MUA 决策边界的限制。 APMSA不会对具有硬标签推理的普通用户造成效用损失 问题构造 威胁模型 假设攻击者不了解系统的模型体系结构。攻击者只能通过迁移学习发起攻击，即攻击者使用恶意样本查询黑盒模型，以标记这些将用于训练替代模型的样本。攻击者从公众中识别预训练模型，并基于预训练模型通过迁移学习构建替代模型;训练数据集是通过 MUA 上的查询的一组输入输出对。具体算法如下：\n攻击者只能通过 API 与模型交互，查询次数受预算限制。但是，他们可以自由选择任何样本进行查询（即未标记的公共数据集$X_{pub}$）。因此，攻击者完全了解输入（即样本类型）和输出（即标签集）的特征。但是，攻击者只能观察返回的预测置信向量，而不能观察模型架构和梯度信息。\n攻击者旨在获得与私有模型$f$具有相似功能的替代模型$f\u0026rsquo;$。替代模型$f\u0026rsquo;$在公共数据集 $\\mathbf{S}\\subseteq\\mathbf{X}_{pub}$ 的子集上进行训练：\n$$f^{\\prime}\\approx\\arg\\min\\mathcal{L}\\left(\\\\{(\\mathbf{x},f(\\mathbf{x})):\\mathbf{x}\\in\\mathbf{S}\\\\},f^{\\prime}(\\mathbf{x})\\right)$$防御者旨在将噪声注入每个查询的输入中，以间接干扰模型返回的预测。APMSA有两个主要目标。一方面，保留了模型的精度，即不使用APMSA时的精度应与原始精度相同。另一方面，被盗模型的准确性在很大程度上被破坏，使攻击者的免费私人查询不再有效。作者将使用 APMSA 前后模型准确性的下降程度作为指标。\nAPMSA的概述 APMSA的直觉是如果防御者策略性地混淆输入查询与其返回的置信度（向量）的输出之间的映射关系，则当攻击者利用这样的输入-输出对来训练其替代模型时，对攻击者有用的泄漏信息将被最小化甚至误导。\n上图是APMSA的流程。当向API查询输入时，APMSA不直接将该输入馈送到模型并返回置信向量。 相反，APMSA通过将对抗性噪声扰动注入到输入中来将该输入转换为对抗性输入。模型最终返回的是变换后的对抗性输入相对应的置信度向量。从攻击者的角度来看，其输入与返回的置信向量之间的关系映射已经被混淆。并且将给定类别样本的置信度向量约束在一个小的区域内，从而大大减少了泄漏信息，便于其替代模型的训练。同时，由于APMSA不会修改输入的硬标签，所以对于普通用户来说性能几乎没有损失。值得注意的是，APMSA是作为插件使用，不需要修改模型。\nAPMSA的实现 作者在此用一个例子来解释了APMSA。假设有一个二分类模型（性别分类），如果模型将$k$个男性类别的图像映射到$k$个不同的概率分布，则在给定不同分布的情况下，$k$个输入-输出对的映射关系将揭示更多关于模型的内部信息。 （如图a所示）但是，如果控制$k$个不同的男性图像映射到特征空间中的相邻区域，则泄露的信息将大大减少。 此外，这些混淆的输入-输出对将在很大程度上误导训练替代模型。（如图b所示）\n也就是说如果输出都堆在一起，就可以混淆输入和输出之间的关系，并且可以更好地保护模型的隐私。\n作者随后介绍了APMSA的详细原理。同样是以二分类的模型为例，$f$是原模型，$f\u0026rsquo;$是攻击者得到的替代模型。其中，攻击者利用查询$x$来获得预测$y=f(x)$，其中$y=\\{y_1,y_2\\}$，攻击者使用$(x,y)$来训练替代模型。APMSA则是通过将向输入空间中的$x$添加对抗性噪声来将样本$x$变为混淆样本$x_c$。这里应用了制作对抗性样本$x\u0026rsquo;$的技术。与$x\u0026rsquo;$不同的是，$x_c$的硬标签与APMSA中的$x$的硬标签相同。这样，攻击者通过$\\{x,y_c=f(x_c)\\}$训练出来的模型$f\u0026rsquo;$决策边界就会导致$x_t$被误分类，从而防止模型窃取攻击。\n与传入的查询输入$x$相比，经变换的对抗输入$x_c$接近决策边界。作者将其转化成了一个优化问题：\n混淆的输入$x\u0026rsquo;$与其对应的对抗示例$x_c$在特征空间中相似，但$x_c$的硬标签与原始输入$x$的类别相同 混淆输入$x_c$和原始输入$x$的置信向量之间的间隙应尽可能小 将其公式化表示为：\n$$\\begin{aligned}\\mathcal{L}\\_1\u0026=J\\left(\\mathbf{x}\\_c\\right)=J(\\mathbf{x}+\\delta)\\\\\\\\\u0026=\\min\\_\\delta\\max\\left(Z(\\mathbf{x}+\\delta)\\_s-Z(\\mathbf{x}+\\delta)\\_t,0\\right)\\end{aligned}$$其中$Z(x_c)_t$表示目标类别$t$的对数值，$Z(x_c)_s$表示原类别$s$。\n如果使$Z(x_c)_s-Z(x_c)_t$变小，就表明指定类别的对数值和源类别之间的差距越来越大，则混淆输入$x_t$更接近目标类别的对抗样本。作者提出了新的约束来提高优化速度。\n$$\\begin{cases}\\mathcal{L}\\_2=Clip\\_{(0,\\infty)}\\left(\\max\\left\\\\{Z(\\mathbf{x}+\\delta)\\_i:i\\neq t,o\\right\\\\}-Z(\\mathbf{x}+\\delta)\\_t\\right)\\\\\\\\ \\mathcal{L}\\_3=Clip\\_{(0,\\infty)}\\left(\\max\\left\\\\{Z(\\mathbf{x}+\\delta)\\_i:i\\neq t,s\\right\\\\}-Z(\\mathbf{x}+\\delta)\\_s\\right)\\end{cases}$$其中$Clip(·)$表示范围约束。\n为了确保 APMSA 不会影响模型的性能（即标签不会更改），优化目标是：\n$$\\begin{aligned} \\mathcal{L}\\_{4}\u0026 =\\text{distance }(\\mathbf{y},\\mathbf{y}\\_c)=\\min\\_\\delta\\|\\mathbf{y}-\\mathbf{y}\\_c\\| \\\\\\\\ \u0026=\\min\\_\\delta\\|f(\\mathbf{x})-f(\\mathbf{x}+\\delta)\\| \\end{aligned}$$这是为了测量扰动输入前后的置信差，以减轻APMSA对模型效用对普通用户的影响。综上，可以得到优化函数：\n$$\\begin{aligned}\\mathcal{L}\u0026=\\mathcal{L}\\_1+c\\_1\\cdot\\mathcal{L}\\_2+\\mathcal{L}\\_3+c\\_2\\cdot\\mathcal{L}\\_4\\\\\\\\\u0026=\\min\\_\\delta J(\\mathbf{x}+\\delta)+c\\_1\\cdot\\mathcal{L}\\_2+\\mathcal{L}\\_3+c\\_2\\cdot\\|f\\left(\\mathbf{x}\\right)-f\\left(\\mathbf{x}+\\delta\\right)\\|\\end{aligned}$$其中超参数$c_1$和$c_2$用于正则化损失函数，在实验中根据经验分别设置为2和0.01。 优化过程不是要找到对抗性样例，而是要识别以正确保存类别为条件的接近其对应对抗性样例的混淆输入$x_c$。\nAPMSA的具体过程如下：\n实验评价 数据集：\nCIFAR10 GTSRB 评估指标：\nTop-1 精度 模型提取攻击评估 选择VGG16作为攻击者初始替代模型的模型结构。使用学习率为 0.0001 的 SGD 来最小化均方误差的损失。\n使用CIFAR-10数据集训练了一个基于ResNet-18的模型，准确率为91.94%，并在不应用防御的情况下部署。 对于初始替代模型，作者选择了在ImageNet上预训练的VGG 16模型，并使用STL 10数据集作为公共查询样本。\n放宽限制，将查询样本设置为 CIFAR10 测试集的一小部分进行查询。\n使用GTSRB数据集训练了一个基于ResNet-18的MUA模型，准确率为95.40%，并在不应用防御的情况下部署。 对于初始替代模型，选择了在ImageNet上预训练的VGG 16模型。\n上述案例表明：\n查询样本的选择会影响模型窃取攻击的效率。具体来说，更接近目标域数据分布的查询样本始终有利于攻击。 基于决策边界的样本合成技术（即通过PGD、CW）可以提供比随机查询更有用的信息。 随着查询预算的增加，基于决策边界的样本生成并没有带来太大的性能提升。原因可能是所选样本分布与原始模型的训练集过于接近，基于决策边界的样本结构提供的信息量相对有限。 当样本数量较少时，基于迁移学习的模型窃取攻击可提高攻击效果。原因是样本越少，冗余信息越少。然而，由于获得的信息相似，更多的查询样本可能会导致信息冗余，这不会为促进攻击提供更多有用的信息。 作者进一步评估攻击者选择的不同替代模型架构对攻击效果的影响。替代模型的性能受所选模型架构的影响。如图所示，VGG16始终表现出优于CIFAR10其他模型的攻击性能。\n同样，在在GTSRB数据集上评估时，ResNet50表现出最好的攻击效果，略好于VGG16，使用AlexNet的性能最差。这表明选择合适的替代模型可以降低攻击成本。\n综上，查询样本的选择会影响模型窃取攻击的效率和替代模型的准确性。具体来说，攻击最好选择类似于目标域的数据分布的公共查询样本。\n此外，基于决策边界的样本合成技术（PGD、CW等）可以提供比随机查询更有用的信息。但是，随着查询次数的增加，基于决策边界的样本并没有带来太大的性能提升。原因可能是所选样本分布与原始模型的训练集太接近。\n防御验证 使用APMSA后，替代模型的准确率甚至低于基准，表明防御减少了模型预测引起的模型内部信息泄露。\nAPMSA的关键见解是，通过将输入映射到特征空间的小尺度区域，可以尽可能减少输入输出对携带的信息泄漏，甚至在很大程度上产生误导性信息。为了可视化这一关键见解，作者使用 t-SNE 和归一化操作来减少用于可视化的混淆输入的维度。\nCIFAR10 数据集上的混淆输入和查询样本之间存在明显的分离——每个混淆输入都是从传入的查询样本中找到的。在将原始查询样本与混淆输出相关联时，通过干扰模型预测中泄露的信息，以减少模型窃取攻击的影响。\n","date":"2023-07-20T14:57:05+08:00","image":"https://lbqaq.top/p/apmsa-adversarial-perturbation-against-model-stealing-attacks/108529802.webp","permalink":"https://lbqaq.top/p/apmsa-adversarial-perturbation-against-model-stealing-attacks/","title":"APMSA: Adversarial Perturbation Against Model Stealing Attacks"},{"content":"字体的分类 字体的数量可以说是成千上万，但一般在电脑上显示的基本为以下这三类1：\nmonospace [等宽]\n等宽字体是指字符宽度相同的字体，用于需要字符严格对齐的场合，例如控制台和源代码。与此相对，字符宽度各不相同的字体称为比例字体(其余四类字体都是)。不过，对于中文字体而言，并不存在等宽与比例的差别，因为所有中文字都是等宽的。中文字体中的“等宽”指的是字体的西文部分是等宽的，2个字母对应1个汉字。\nsans-serif [无衬线]\n是指笔画末端没有修饰(衬线)的字体，通常用于屏幕显示。中文的黑体与圆体就属于此类字体。\nserif [有衬线]\n是指笔画末端有修饰(衬线)的字体，通常用于打印。中文的宋体与仿宋就属于此类字体。\n我们要做的字体配置主要就是针对上面这三类字体。\n选字体 有了目标，下面就是选一个自己喜欢的字体了。不过，对于中文字体，目前现在 Linux 上常用的、在维护的开源中文字体就一套——“思源黑体”和“思源宋体”，同时被 Noto 和思源两个项目收录。Noto 系列字体是 Google 主导的，思源系列字体是 Adobe 主导的。2\n对于编程字体，可以选择的余地就多多了，像是Source Code Pro，Consolas，Menlo等等。我一开始选择的是 Iosevka 。但是，这款字体给我感觉太瘦了，看起来很是别扭。最后，我选择了广受好评的 Fira Code 。\n小结一下，我的选择是：\n无衬线：西文 Noto Sans，中文 Noto Sans CJK 衬线：西文 Noto Serif，中文 Noto Serif CJK 等宽：西文 Fira Code，中文 Noto Sans Mono CJK 在ArchLiunx上，我们只需要安装noto-fonts和noto-fonts-cjk这两个包即可，他们分别提供了西文字体 Noto Sans / Noto Serif和中文字体 Noto Sans CJK / Noto Serif CJK / Noto Sans Mono CJK 。3\n关于 emoji，我选择了 Twitter 推出的字体 Twemoji。\nttf-twemoji 另外，少不了人见人爱的图标字体 Nerd Fonts。\nttf-nerd-fonts-symbols 这里就有小伙伴开始好奇了，如何让西文和中文使用不同的字体呢？\n在 Windows 下，我们可以选择合成字体，即将各类字体打包到一起。例如更纱黑体就是由思源黑体和西文字体 Iosevka 整合而来的。这种字体的好处就是方便，直接选择使用即可。但是缺点也是显而易见，就是打包太麻烦了，引入 Iosevka 要打一次包，想要支持 Nerd Fonts，又要打一次包。如果是别人帮你提供好的合成字体那还好说， 从网上下载、从软件仓库安装就完事了，自己打包的话真的工作量巨大。\n而在 Liunx 下，我们只需要配置 fontconfig 就好了，无论想怎么搭配都可以实现，听起来是不是特别酷😎。可惜的是，有一些程序对 fontconfig 支持并不完善，这就达不到我们想要的效果。（说的就是你，Chrome😠）\nfontconfig 在我们开始正式配置前，还是有必要了解一些基本的知识。这里我就简单介绍一下，如果想要深入了解的话可以看看双猫大佬的这篇文章，里面详细介绍了Linux fontconfig 的字体匹配机制。\n字体的属性 字体有很多属性，常用的有字族（family）、倾斜（slant）、字重（weight）。后两者合一起叫样式（style）。\n字族就是它的名字啦。一个字体文件，可以提供多个字体族名 (family)。比如 Arch Linux 用户在安装 wqy-microhei 后，系统端增加了 wqy-microhei.ttc 这个字体文件，分别提供「WenQuanYi Micro Hei」「文泉驛微米黑」,「文泉驿微米黑」三个字体族名，它们是一个意思。我们可以运行 fontconfig 提供的命令行工具 fc-list 去查看系统上已安装的字体已经它们对应的字体族名。\n倾斜就是斜不斜，英文叫「Roman」「Italic」或者「Oblique」，Italic 是专门的斜体写法（更接近手写样式）， Oblique 是把常规写法倾斜一下完事。\n字重就更简单了，就是笔划的粗细。常见的有 Regular、Normal、Medium、Bold、Semibold、Black、Thin、Light、Extralight 等。\n通用字族名 很多时候，程序并不在乎用户具体使用的是哪款字体，像很多网站的 CSS 那样把各个平台的常见字体全部列出来太傻了，又容易出问题。所以，人们发明了「通用字族名」，也就是 sans-serif (sans)、serif 和 monospace (mono) 这些。它们不是真实存在的字体，而是分别指示程序去使用无衬线、衬线、等宽字体。那么桌面程序又是如何知道具体使用哪些字体呢？它只需要去查询 fontconfig 就行了。由于它们必定要经过 fontconfig 的查询流程后才能使用字体，所以我们可以通过 fontconfig 的配置去精准控制程序使用的字体。\n如何调试 传入环境变量FC_DEBUG=4即可，例如：\n1 FC_DEBUG=4 kitty fontconfig 就会打印调试信息，其中可以看到：\n1 2 3 4 5 6 7 FcConfigSubstitute Pattern has 6 elts (size 16) family: \u0026#34;monospace\u0026#34;(s) slant: 0(i)(s) weight: 80(i)(s) pixelsize: 19.1667(f)(s) lang: \u0026#34;en\u0026#34;(w) prgname: \u0026#34;kitty\u0026#34;(s) 除了启动一个程序来看它字体的调用日志，我们也可以手动调用。例如，我想看 monospace 在系统里被修改成了什么字体，就可以执行：\n1 FC_DEBUG=4 fc-match \u0026#39;monospace\u0026#39; 打印出的调试信息会很长，我们主要看几个部分：\n第一部分，Add Rule，指已添加的配置文件规则。这里面也包含了家目录下的配置文件，可以找来看看被解析成了什么。\n第二部分，在 Add Rule 之后，迎来了最关键的、我们应当关心的 FcConfigSubstitute Pattern，它包含了 font pattern。(s) 和 (w) 分别代表强弱绑定；prgname 代表程序名，此时就是 fc-match。至于 lang，由于没有对 fc-match 指定语言，所以默认是 en。\n接下来有很多条 FcConfigSubstitute editPattern，代表对 font pattern 的替换操作。但是必须当规则匹配的时候，也就是 Rule Set 不是 No match 的情况下，才执行 FcConfigSubstitute editPattern。那么，又应该怎么看 FcConfigSubstitute editPattern 呢？主要看 family，因为 family 代表着字体匹配顺序。它就是配置文件中的\u0026lt;edit target=\u0026quot;pattern\u0026quot;\u0026gt;操作。\n最后应该关心 FcConfigSubstitute donePattern，这是 fontconfig 执行完字体替换后的结果。\n配置文件 整个配置文件由如下几个部分依次拼接而成：\n目录设置(\u0026lt;dir\u0026gt;, \u0026lt;cachedir\u0026gt;, \u0026lt;include\u0026gt;) 杂项设置(\u0026lt;config\u0026gt;) 扫描阶段(\u0026lt;match target=\u0026quot;scan\u0026quot;\u0026gt;) 匹配阶段(\u0026lt;alias\u0026gt;, \u0026lt;match target=\u0026quot;pattern\u0026quot;\u0026gt;) 渲染阶段(\u0026lt;match target=\u0026quot;font\u0026quot;\u0026gt;) 想要实现合成字体的效果，一个最简单的思路，本文也基于该思路：不让程序使用某个具体的字体，而是使用通用字体族名 (Generic Font Family)。比如，让程序使用 sans-serif，也就是默认的无衬线字体。\n我们要关心第四个部分，即匹配阶段，使用 fontconfig 配置如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Noto Sans\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Twemoji\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 这种 font stack 的方式，即可让程序按照以下顺序渲染字体：\n1 Noto Sans CJK SC —\u0026gt; Noto Sans -\u0026gt; Twemoji 这里的\u0026lt;test\u0026gt;就是条件判断，mode=\u0026quot;prepend\u0026quot;指在前添加，binding=\u0026quot;strong\u0026quot;则是强绑定\n开始配置 我们的思路就是就是修改默认的字族，让其成为我们想要指定的字体。然后将所有程序的字体配置改为通用字体族名：sans-serif，serif，monospace。\n我们的配置都放在此目录中~/.config/fontconfig/fonts.conf，我的完整配置在此仓库中。\n设置默认字体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;!-- Default system-ui fonts --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;system-ui\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Default sans-serif fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Noto Sans\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Twemoji\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Default serif fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Serif CJK SC\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Noto Serif\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Twemoji\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Default monospace fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;monospace\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK SC\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Symbols Nerd Font\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Twemoji\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Source Code\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Fira Code\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 对 system-ui，sans-serif，serif，monospace 设置优先显示的字体。在这里我让 system-ui 默认为无衬线。注意，system-ui 必须在最前。由于 fontconfig 对 font pattern 的操作是按顺序执行的，所以必须先让 system-ui 能优先以 sans-serif 显示，然后才是对 sans-serif 的操作。\n所有的 Noto CJK 字体都以 SC 结尾，因为我希望在没指定语言的默认情况下，以简体中文显示中文字形。\n设置异形字 什么是异形字？Noto Sans CJK 中的异体字，是在 相同的 Unicode 码位下，不同的语言会使用不同的字形。\n可以在双猫大佬的这个测试网站中看到，不同的语言环境下，这些字的显示是不同的。\n我们想要实现在保留异体字的情况下，让它默认显示中国大陆字形；只在特定语言下显示异体字，比如用浏览器查看一个日文页面。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- Replace fonts for Japanese --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34;\u0026gt; \u0026lt;string\u0026gt;ja\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK JP\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 在字体匹配时，将 Noto Sans CJK SC 替换成 Noto Sans CJK JP。除了 ，你还需要照葫芦画瓢分别指定 zh-TW、zh-HK、ja、ko，以及对宋体和等宽字体进行重复的步骤。在此我就不重复了。\n解决全角引号 英文中的单引号有两种，'(U+0027) 和’(U+2019)。可能会觉得前一种出现在英文文本中，后一种出现在中文文本中，并且宽度和中文等宽。然而，英语世界中的一些人在英文文章中也是会使用后一种的。所以，字体在显示后一种引号的时候，究竟是和英文字母一样窄，还是该和中文字体等宽呢？如果在英文文章中显示成全宽字符则会显得突兀。\n比如，思源黑体其实也包含了拉丁字母的字形，可以完全使用思源黑体去显示西文。此时，后一种单引号的宽度会显示成中文字形的宽度。导致即使在全英文环境中，单引号也会突兀地在文本中过宽。\n同样地，‘(U+2018) “(U+201C) ”(U+201D) 也有类似的情况。\n我们的目标是在不同语言环境下字形会有所区别，让引号只在中文文本中全宽。\n同样，在双猫大佬的这个测试网站中可以进行测试：\n利用fontconfig，可以方便的解决此问题\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 解决全角引号 --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;en\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 覆盖西文字体 如果去观察 Noto Sans CJK 这个中文字体，会发现它的西文部分的字形其实和 Noto Sans 不一样，虽然它们都以 Noto 自称。中文字体携带的英文字符有可能十分糟糕，特别是 Windows 自带的 SimHei，也就是中易黑体，它的英文相当糟糕。另外，微软雅黑的字重实在是太少了，对于设计师来说很不友好。而各种流行的英文字体支持很多字重。\nNoto Sans CJK 的英文还是比较不错的，为了字体的样式统一，这里就不修改sans-serif和seri了。主要将编程用的等宽字体换成Fira Code。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- Replace english fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;prgname\u0026#34; compare=\u0026#34;not_eq\u0026#34;\u0026gt; \u0026lt;string\u0026gt;msedge\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans Mono CJK\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Fira Code\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 这里为什么要多加一句判断呢？这是因为有些程序居然只使用 font pattern 结果中的首个字体，比如 Chrome（以及衍生的Chromium），虽然 Chrome 接受了我们指定的西文字体，但是它忽略了紧接其后的中文字体，即使配置采用了强绑定！然后中文字体又不知道它 fallback 到哪去了，可能会出现你想要的中文字体，也可能不是。\n这里是 msedge 主要是我平时都用 edge 而不是 Chrome。可惜由于 Chromium 在 Linux 上小问题实在是太多了，还是老老实实的用 firefox 吧。\n在所有情况下，除了程序名为 msedge 的情况下，优先使用 Fira Code 显示西文，再用 Noto Sans Mono CJK 显示中文。虽然我不能让 msedge 使用 Fira Code，但它一定能用上 Noto Sans Mono CJK 显示中文。\n替换任意字体 当系统里已经安装了一些不需要的字体，但又不想删除或者屏蔽它怎么办呢？替换掉 font pattern 就可以了。\n我这里则是用来替换思源字体，毕竟它就是 Noto 嘛\n1 2 3 4 5 6 7 8 \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test qual=\u0026#34;any\u0026#34; name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Source Han Sans\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;assign\u0026#34; binding=\u0026#34;same\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 字体渲染参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!--rendering options--\u0026gt; \u0026lt;match target=\u0026#34;font\u0026#34;\u0026gt; \u0026lt;edit name=\u0026#34;autohint\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;bool\u0026gt;false\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;hinting\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;bool\u0026gt;true\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;hintstyle\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;const\u0026gt;hintslight\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;antialias\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;bool\u0026gt;true\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;lcdfilter\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;const\u0026gt;lcddefault\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026#34;rgba\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;const\u0026gt;rgb\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 这里主要设置了一些字体的渲染方式：\nautohint：优先使用内嵌微调 hinting：开启微调 hintstyle：微调的程度，轻微 antialias：开启抗锯齿功能 lcdfilter：LCD filter 的风格，默认 rgba：LCD 子像素的排列顺序，rgb 这里就直接抄作业了。\n遇到的问题 全角引号设置无效 一开始我遇到了这个问题，无论怎么设置都是半角，经过排查以及网友的留言后发现，这是由于系统变量中的LANG为en_US.utf-8，这会导致传递给 fontconfig 的 lang 是 lang: zh-cn(s) \u0026quot;en\u0026quot;(w)。于是就一直匹配西文字体。\n解决办法有两个，一个是直接修改LANG环境变量为zh_CN.UTF-8，我目前采用的就是这种形式。\n或者就是默认渲染英文，当网页声明是中文时再换字体，相关配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!-- Default sans-serif fonts--\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Noto Color Emoji\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- cn --\u0026gt; \u0026lt;match target=\u0026#34;pattern\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;lang\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;cn\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026#34;family\u0026#34; compare=\u0026#34;contains\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;family\u0026#34; mode=\u0026#34;prepend\u0026#34; binding=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 这样如果网页声明了lang=zh-cn，就会用Noto Sans CJK SC字体进行覆盖，也就实现了全宽引号。假如网页没有声明lang或者错误地声明了lang=en，这时就会出现半角引号+汉字的组合了。\n不能解决的问题 Linux 不强迫程序必须使用特定的依赖，而是程序主动选择了约定俗成的依赖。老话重谈，程序可以自由选择完全遵守 fontconfig，也可以选择部分使用 fontconfig 的配置，或者完全不遵守它。这也导致了对一些程序无法实现字体的修改。以及上面提到的 chrome 对 fontconfig 并不是很好，或许面对这种程序，就需要合成字体的出场了。\n参考文献 Linux字体美化实战(Fontconfig配置) [金步国]\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLinux 上的字体配置与故障排除 - 依云\u0026rsquo;s Blog\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n用 fontconfig 治理 Linux 中的字体 - 双猫CC\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-07-05T20:58:15+08:00","image":"https://lbqaq.top/p/linux-font/109572761.webp","permalink":"https://lbqaq.top/p/linux-font/","title":"fontconfig：Linux下的字体配置"},{"content":"最近打算将ArchLinux作为主力系统挑战一下，由于平时有用电脑挂明日方舟的习惯，于是打算安装模拟器在Linux上。相较于Windows下各种xx模拟器百花齐放，Linux下就惨不忍睹了。网上搜索到的知名模拟器中，Anbox已经被作者弃坑了，Android Studio模拟器则是面向开发者，想要使用还要安装Android Studio开发环境。\n在搜索中，我发现ReDroid可以满足我的需求。作为一个“云手机”的方案，自然是可以部署在本地，摸索明白了部署到服务器上也挺不错(雾。\n具体的安装的教程我参考的是Ivon大佬的这篇文章，在此基础上作了一些小小的修改。\nReDroid配置 安装环境 ReDroid需要Linux内核启用binderfs模块，Arch Liunx默认的linux内核并不包含此模块，需要安装linux-zen模块。\n1 pacman -S linux-zen 这里我强烈建议安装官方的安装指南来，我一开始按照Ivon大佬的教程尝试在默认的Linux内核里启用该模块，结果ReDroid一直启动不了。最后更换内核后就成功运行起来了QAQ。\n接着安装docker和docker-compose，用来运行ReDroid的容器\n1 sudo pacman -S docker docker-compose 还要安装ADB和Scrcpy，用于连接到安卓虚拟机\n1 2 sudo pacman -S android-tools sudo pacman -S scrcpy [可选]配置ARM转译器 大部分安卓应用都只有ARM版，这也意味着无法在X86的电脑上运行，这时就需要安装ARM转译器了。\n然而，明日方舟居然支持X86，我们可以通过压缩工具解压方舟的安装包，可以看到lib下有x86目录。这也意味着如果只是用来玩方舟的话，完全不需要配置ARM转译。\n同时，根据大佬的教程配置好转译器后，方舟反而会闪退，所以完全不用做此步😥。如果需要安装arm应用，可以看上面大佬的教程来做。\n我后面可能会考虑使用libhoudini来作为ReDroid的转译器。\n启动镜像 我这里就使用不包含ARM转译器的ReDroid继续了。通过下面的命令即可部署ReDroid：\n1 2 3 4 5 sudo docker run -itd --privileged \\ -v /home/luobo/redroid:/data \\ -p 5555:5555 \\ --name redroid11 \\ redroid/redroid:11.0.0-latest 然后使用adb连接，并执行Scrcpy，显示手机画面：\n1 2 adb connect localhost:5555 scrcpy -s localhost:5555 对于Google服务框架，我并不是刚需，就不安装了。如果需要安装，可以查看之前提到的教程。\nScrcpy2.0版本，已经自带了声音模块，无需再安装额外的软件。\n如果遇到报错Failed to initialize audio/opus, error 0xfffffffe\n只需要手动指定其他的音频解析器即可，如下面所示：\n1 scrcpy -s localhost:5555 --audio-codec=aac 如果不需要声音，只需要加上--no-audio，如下面所示：\n1 scrcpy -s localhost:5555 --no-audio 安装应用及开关机 向ReDroid安装应用，只需要使用adb即可\n1 adb -s localhost:5555 install \u0026#34;/mnt/data/Downloads/mrfz_2.0.11_20230605_102450_87eb5.apk\u0026#34; 开关机也很简单，我们只需对docker容器进行操作。\n1 2 sudo docker stop redroid11 #关机 sudo docker start redroid11 #开机 MAA配置 MAA作为自动化的挂机长草神器，肯定是要安排上的。\n安装MAA Arch用户直接aur安装即可\n1 yay -S maa-assistant-arknights 我使用yay安装时，会安装许多用不到的库，而且会因为依赖错误而无法安装。故还是去官网下载压缩包解压使用。\n配置MAA 我们需要修改./MAA-v{版本号}-linux-{架构}/Python/ 目录下的 sample.py 文件\n首先需要配置adb连接，由于我们之前已经安装过adb了，这里直接替换地址即可：\n1 if asst.connect(\u0026#39;adb\u0026#39;, \u0026#39;127.0.0.1:5555\u0026#39;): 我们可以执行python sample.py，如果输出连接成功则配置成功\n之后我们需要配置MAA的任务，这里可以参考官方的文档进行修改\n这里附上我的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 asst.append_task(\u0026#39;StartUp\u0026#39;) asst.append_task(\u0026#39;Fight\u0026#39;, { \u0026#39;stage\u0026#39;: \u0026#39;\u0026#39;, # 关卡名，可选，默认为空，识别当前/上次的关卡。 \u0026#39;report_to_penguin\u0026#39;: True, # 是否汇报企鹅数据 \u0026#34;expiring_medicine\u0026#34;: 999, # 最大使用 48 小时内过期理智药数量，可选，默认 0 # \u0026#39;penguin_id\u0026#39;: \u0026#39;1234567\u0026#39; }) asst.append_task(\u0026#39;Recruit\u0026#39;, { \u0026#39;enable\u0026#39;: True, # 是否启用本任务，可选，默认为 true \u0026#39;select\u0026#39;: [4, 5], # 会去点击标签的 Tag 等级，必选 \u0026#39;confirm\u0026#39;: [3, 4], \u0026#39;times\u0026#39;: 4 }) asst.append_task(\u0026#39;Infrast\u0026#39;, { \u0026#39;facility\u0026#39;: [ \u0026#34;Mfg\u0026#34;, \u0026#34;Trade\u0026#34;, \u0026#34;Control\u0026#34;, \u0026#34;Power\u0026#34;, \u0026#34;Reception\u0026#34;, \u0026#34;Office\u0026#34;, \u0026#34;Dorm\u0026#34; ], \u0026#39;drones\u0026#39;: \u0026#34;Money\u0026#34;, # 无人机用途 \u0026#34;_NotUse\u0026#34;、\u0026#34;Money\u0026#34;、\u0026#34;SyntheticJade\u0026#34;、\u0026#34;CombatRecord\u0026#34;、\u0026#34;PureGold\u0026#34;、\u0026#34;OriginStone\u0026#34;、\u0026#34;Chip\u0026#34; \u0026#39;replenish\u0026#39;: True, # 贸易站“源石碎片”是否自动补货, \u0026#39;dorm_trust_enabled\u0026#39;: True # 是否将宿舍剩余位置填入信赖未满干员 }) asst.append_task(\u0026#39;Visit\u0026#39;) asst.append_task(\u0026#39;Mall\u0026#39;, { \u0026#39;shopping\u0026#39;: True, \u0026#39;buy_first\u0026#39;: [\u0026#39;招聘许可\u0026#39;, \u0026#39;龙门币\u0026#39;], \u0026#39;blacklist\u0026#39;: [\u0026#39;家具\u0026#39;, \u0026#39;碳\u0026#39;], }) asst.append_task(\u0026#39;Award\u0026#39;) 配置好后只需要一行命令就可以执行脚本了\n1 python sample.py 至此，我们终于可以愉快的挂机了，再也不用担心体力被浪费了（雾\n由于ReDroid是基于Dokcer的，这也意味着可以将其配置到服务器上，就可以实现24小时自动挂机了。不过，要想流畅的运行方舟，最好还是有4G以上的内存，目前我的服务器还没有这么大的内存，之后有机会再尝试吧。\n","date":"2023-06-17T16:47:00+08:00","image":"https://lbqaq.top/p/redroid-maa/103123878.webp","permalink":"https://lbqaq.top/p/redroid-maa/","title":"ReDroid+MAA：在Linux下游玩明日方舟"},{"content":"最近需要构建属于自己的YOLO训练数据集，如果手动标注2k张图片这工作量太大了，于是就寻找有什么可以自动标注的方法。碰巧的是， 知乎正好推荐了一篇相关的文章，里面介绍了Grounding DINO这个项目完美符合我的需求。那就不用多说了，直接修改他来实现我所需的功能。\n需求 首先要明确一下我的需求：\n能根据prompt实现画框标注 能对文件夹内的数据进行批量处理 能将识别的结果保存为YOLO TXT格式 这个项目可以实现第一个功能，但对于第二和第三个功能就需要我自己来实现了。\n实现 Grounding DINO可以在CPU上运行，不过为了效率考虑，最好还是运行在GPU上，为此我所有的代码都在Colab上实现。\n首先是环境配置，我们要挂载Google云盘以及安装Grounding DINO。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from google.colab import drive drive.mount(\u0026#39;/content/drive\u0026#39;) import os HOME = os.getcwd() print(HOME) %cd {HOME} !git clone https://github.com/IDEA-Research/GroundingDINO.git %cd {HOME}/GroundingDINO !pip install -q -e . !pip install -q roboflow CONFIG_PATH = os.path.join(HOME, \u0026#34;GroundingDINO/groundingdino/config/GroundingDINO_SwinB.cfg.py\u0026#34;) print(CONFIG_PATH, \u0026#34;; exist:\u0026#34;, os.path.isfile(CONFIG_PATH)) %cd {HOME} !mkdir {HOME}/weights %cd {HOME}/weights !wget -q https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha2/groundingdino_swinb_cogcoor.pth WEIGHTS_NAME = \u0026#34;groundingdino_swinb_cogcoor.pth\u0026#34; WEIGHTS_PATH = os.path.join(HOME, \u0026#34;weights\u0026#34;, WEIGHTS_NAME) print(WEIGHTS_PATH, \u0026#34;; exist:\u0026#34;, os.path.isfile(WEIGHTS_PATH)) %cd {HOME}/GroundingDINO from groundingdino.util.inference import load_model, load_image, predict, annotate model = load_model(CONFIG_PATH, WEIGHTS_PATH) 通过上面这些代码，我们就成功配置好Grounding DINO并载入了模型。\n下面就是我自己实现的训练集自动标注代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 TRAIN_DATA_PATH = os.path.join(\u0026#34;/content/my_data/images\u0026#34;) print(TRAIN_DATA_PATH, \u0026#34;; exist:\u0026#34;, os.path.isdir(TRAIN_DATA_PATH)) TEXT_PROMPT = \u0026#34;face . phone\u0026#34; BOX_TRESHOLD = 0.35 TEXT_TRESHOLD = 0.25 for filename in os.listdir(TRAIN_DATA_PATH): if filename.endswith(\u0026#34;.png\u0026#34;): image_path = os.path.join(TRAIN_DATA_PATH, filename) image_source, image = load_image(image_path) boxes, logits, phrases = predict( model=model, image=image, caption=TEXT_PROMPT, box_threshold=BOX_TRESHOLD, text_threshold=TEXT_TRESHOLD ) save_path = os.path.join(TRAIN_DATA_PATH,os.path.splitext(filename)[0]) with open(save_path + \u0026#34;.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: for i in range(len(phrases)): class_id = 0 if phrases[i] == \u0026#39;face\u0026#39; else 1 f.write(f\u0026#34;{class_id} {boxes[i][0]} {boxes[i][1]} {boxes[i][2]} {boxes[i][3]}\\n\u0026#34;) print(f\u0026#34;{filename} is over\u0026#34;) 我们的代码会自动遍历文件夹下面所有的.png格式的文件，并调用Grounding DINO进行标注。在这段代码中，face的class_id为0，phone的class_id为1。\n特别的，参考这篇issue，我们的prompt使用了.分割，这是为了避免不同顺序对结果的影响。\n测试 由于拿到的数据是txt格式，人类很难识别，所以我们可以借助cv2将识别的结果在图片中框出，直接写个小脚本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import os import cv2 DATA_PATH = \u0026#34;D:\\Code\\Python\\yolo\u0026#34; for filename in os.listdir(DATA_PATH): if filename.endswith(\u0026#34;.png\u0026#34;): image_path = os.path.join(DATA_PATH, filename) txt_path = os.path.join(DATA_PATH,os.path.splitext(filename)[0]) + \u0026#39;.txt\u0026#39; with open(txt_path, \u0026#39;r\u0026#39;) as f: # 读取图像文件 image = cv2.imread(image_path) w = image.shape[1] h = image.shape[0]\twhile True: line = f.readline() if line: msg = line.split(\u0026#34; \u0026#34;) # print(x_center,\u0026#34;,\u0026#34;,y_center,\u0026#34;,\u0026#34;,width,\u0026#34;,\u0026#34;,height) x1 = int((float(msg[1]) - float(msg[3]) / 2) * w) # x_center - width/2 y1 = int((float(msg[2]) - float(msg[4]) / 2) * h) # y_center - height/2 x2 = int((float(msg[1]) + float(msg[3]) / 2) * w) # x_center + width/2 y2 = int((float(msg[2]) + float(msg[4]) / 2) * h) # y_center + height/2 print(x1,\u0026#34;,\u0026#34;,y1,\u0026#34;,\u0026#34;,x2,\u0026#34;,\u0026#34;,y2) if msg[0] == \u0026#39;0\u0026#39;: # 画出框 cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2) else: cv2.rectangle(image, (x1, y1), (x2, y2), (255, 0, 0), 2) else: break\t# 显示图像 cv2.imshow(\u0026#39;image\u0026#39;, image) cv2.waitKey(0) # cv2.destroyAllWindows() 这个模型识别的效果还是不错的，不过还是有些多余的识别需要手工去除。\n","date":"2023-04-14T10:07:42+08:00","image":"https://lbqaq.top/p/using-grounded-dino-label-data/75910823.webp","permalink":"https://lbqaq.top/p/using-grounded-dino-label-data/","title":"利用Grounding DINO自动标注数据"},{"content":"介绍 近年来，人们对利用来自多个组织的分布式源的数据来设计复杂的机器学习模型越来越感兴趣。\n但是，由于\n用户敏感数据的使用被迫遵守标准隐私规章或法律，例如GDPR或CCPA 数据是组织保持业务竞争优势的宝贵资产，应该受到高度保护 这两个原因，专有数据不能被直接共享。于是，联邦学习便被提出。联邦学习是一种新兴的数据协作范例，它允许多个数据所有者联合构建ML模型而不向彼此泄露其私有数据。\n联邦学习根据数据划分，被分为横向联邦学习、纵向联邦学习、联邦迁移学习三类。在本文中，作者主要考虑的是纵向联邦学习这一类。何为纵向联邦学习呢？也就是２个数据集的用户重叠部分较大，而用户特征重叠部分较小，作者给出了一个实例：\n一家银行希望构建一个机器学习模型，通过加入Fintech公司的更多特性来评估是否批准用户的信用卡申请。这家银行拥有“年龄”和“收入”的特征，而Fintech公司拥有“存款”和“平均在线购物次数”的特征。只有银行拥有训练数据集和测试数据集中的标签信息，即：是否应批准申请。我们将带有标签的一方称为主动方，其余没有标签值的一方或者几方称为被动方。\n在本篇文章中，把拥有标签值的一方看作进攻方，而没有标签值的一方或者几方所拥有的特征值看作目标值，进攻方通过一定的方法得到目标方的目标值，也就是通常模型中被动方的隐私数据。\n相关研究 Comprehensive privacy analysis of deep learning: Stand-alone and federated learning under passive and active white-box inference attacks The secret sharer: Measuring unintended neural network memorization \u0026amp; extracting secrets Exploiting unintended feature leakage in collaborative learning Deep models under the gan: information leakage from collaborative deep learning 等等，这些文章旨在推断横向联邦学习中参与方的特征值，其中各方具有相同的特征但具有不同的样本。 然而，这些攻击极大地依赖于在训练过程中交换的模型梯度，一旦模型梯度被安全地保护，这些攻击将是无效的。而且，对于预测阶段中的推理攻击，联邦学习模型事先不知道预测样本。于是，作者提出几种基于模型预测的特征推理攻击，研究了纵向联邦学习预测阶段的隐私泄露问题，该攻击方法在预测输出的计算过程中不依赖任何中间信息。\n本文贡献 首次提出了纵向联邦学习预测模型的特征推理攻击 提出了针对逻辑回归和决策树的两种特定的攻击思路 利用攻方积累的多种预测输出，来设计一种从中学习攻方特征和目标特征关联的通用攻击思路 在真实和合成的数据集上，实践了提出的方法并进行了大量的评估。结论显示了攻击的有效性，本文也分析和建议了几种潜在的应对思路 问题构造 系统模型 我们考虑一组m个分布方（或数据所有者）${P_1,\u0026hellip;,P_m}$，他们通过合并各自的数据集来训练纵向联邦学习模型。在获得经训练的纵向联邦学习模型参数$\\theta$之后，各方协作地对其联合预测数据集$D_{pred}={D_1,\u0026hellip;,D_m}$进行预测。 数据集中的每一行对应一个样本，每一列对应一个要素。 设$n$为样本数，$d_i$为$D_i$中的特征数，其中$i\\in{1,\u0026hellip;,m}$。我们表示$D_i={x^t_i}^n_{t=1}$，其中$x^t_i$表示$D_i$的第t个样本。在这篇文章中，作者考虑监督分类任务，并用$c$表示分类的数量。\n威胁模型 我们考虑半诚实模型，其中每一方都严格按照规定遵循协议，但可能试图基于接收到的消息推断其他方的私有信息。具体而言，本文着重研究了主动方为对抗方的情形。主动方还可以与其他被动方串通来推断一组目标被动方的私有特征值。最强的概念是m-1个参与方（包括主动方）合谋推断其余被动方的特征值。\n攻击方法 逻辑回归模型(LR)的等式求解攻击 给定预测输出$v$，对手$P_{adv}$可以构造一组方程，$P_{adv}$可以从该组方程推断出$P_{target}$所持有的特征值。也就是说攻击者利用纵向联邦学习预测结果以及自己所持有的参数推断数据其他提供方的参数。\n作者分别讨论了二分类逻辑回归以及多分类逻辑回归。\n二分类逻辑回归 将模型参数表示为$\\theta = \\theta (\\theta_{adv},\\theta_{target})$，其中$\\theta_{adv}$和$\\theta_{target}$分别是对应于$P_{adv}$和$P_{target}$所拥有的特征的权重。\n令$v$为给定样本$x=(x_{adv},x_{target})$的预测输出。对于二元LR分类，$v$中只有一个有意义的置信度分数，我们令其为$v_1$。\n给定$v_1$和对手自己的特征值$x_{adv}$，$P_{adv}$可以直接创建以$x_{target}$作为变量的方程，即，\n$$\\sigma\\left(x\\_{\\text {adv }} \\cdot \\theta\\_{\\text {adv }}+x\\_{\\text {target }} \\cdot \\theta\\_{\\text {target }}\\right)=v\\_{1}$$其中$\\sigma(\\cdot)$是S形函数。显然，如果只有一个未知特征，即，$d_{target} = 1$，则方程只有一个解，这意味着可以精确地推断未知特征值$x_{target}$。\n多分类逻辑回归 对于多分类逻辑回归，存在$c$个线性回归模型。设$\\theta = (\\theta^{(1)},\u0026hellip;,\\theta^{(c)})$分别为这些$c$模型的参数。\n为了发起特征推理攻击，对手的目标是构造$k\\in{1,\u0026hellip;,c}$的线性方程。\n$$x \\_ { a d v } \\cdot \\theta \\_ { a d v } ^ { ( k ) } + x \\_ { target } \\cdot \\theta \\_ { target } ^ { ( k ) } = z \\_ { k }$$其中$z_k$是第$k$个线性回归模型的输出。然而，$P_{adv}$只知道置信度向量$v =(v_1,\u0026hellip;,v_c)$，使得\n$$v \\_ { k } = \\frac { e x p ( z \\_ { k } ) } { \\sum \\_ { k' } exp ( z \\_ { k' } ) }$$上面两个式子是我们用逻辑回归解决多分类问题的通用的公式，其中作者在第一个式子中把x和θ分成了攻方和目标方的数据。\n作者将第二个式子双方取对数\n$$\\ln v \\_ { k } = z \\_ { k } - \\ln ( \\sum \\_ { k ^ { \\prime } } e x p ( z \\_ { k } ^ { \\prime } ) )$$等式右边的第二项对于所有$k\\in{1,\u0026hellip;,c}$是相同的。因此，对两个相邻类别概率v的对数取差值\n$$\\ln v \\_ { k } - \\ln v \\_ { k'} = z \\_ { k } - z \\_ { k' }$$最后可以得到一个无关z值的一个等式\n$$x\\_{\\text {adv }}\\left(\\theta\\_{\\text {adv }}^{(k)}-\\theta\\_{\\text {adv }}^{(k+1)}\\right)+x\\_{\\text {target }}\\left(\\theta\\_{\\text {target }}^{(k)}-\\theta\\_{\\text {target }}^{(k+1)}\\right)=a\\_{k}^{\\prime}$$其中$a^\\prime_k=\\ln v_k-\\ln v_{k+1},k\\in{1,\u0026hellip;,c}$。\n但是在后面推理的时候本文有一些为了逻辑上方便而采用了一个把纵向联邦限制减少的做法：把目标方或者说被动方的参数θ看作进攻方或者主动方能够得到的数据。\n实际情况中，主动方或者进攻方在一般的纵向联邦框架中是无法得到被动方的参数θ数据的。\n本文中我们姑且认为进攻方能得到，那么上式中的未知数只有$x_{target}$了，而$x_{target}$的维数为$d_{target}$，数量为目标方所用拥有的特征数。\n这里我们把$x_{target}$的未知数看作自变量，个数为目标放所拥有的特征数。那么也就是说，$d_{target}$个自变量，$c-1$个方程，当$d_{target}\\le c-1$，那么$x_{target}$只有一个解，可以精确地推断出来。\n决策树模型的路径限制攻击 攻击方可以根据自己的部分特征信息(蓝色方框) 限制树模型中可能的路径(灰色箭头 -\u0026gt; 蓝色箭头 5:2)，结合预测类别结果1进一步限制决策路径(蓝色 - \u0026gt; 红色箭头 2:1 )，可以推测目标方Target的deposit属性(绿色方框) \u0026gt; 5K。\n生成回归网络攻击 上面介绍的两种攻击方式都是基于单个模型预测。然而，这些攻击很难应用于复杂的模型，如神经网络（NN）和随机森林（RF）。\n针对上述缺陷，作者设计了一种基于多模型预测的通用特征推理攻击，即生成回归网络（GRN）攻击，这是本篇论文的重点。\n基本思想：\n计算出对手自身特征与攻击目标未知特征之间的总体相关性。在此基础上，推断未知特征值的问题等效于生成新值$\\hat{x}_{target}$以匹配垂直FL模型的决策的问题，其中$\\hat{x}_{target}$遵循由对手的已知特征值和特征相关性确定的概率分布。\n目标函数：\n$$\\min \\_{\\theta\\_{G}} \\frac{1}{n} \\sum\\_{t=1}^{n} \\ell\\left(f\\left(x\\_{\\mathrm{adv}}^{t}, f\\_{G}\\left(x\\_{\\mathrm{adv}}^{t}, r^{t} ; \\theta\\_{G}\\right) ; \\theta\\right), v^{t}\\right)+\\Omega\\left(f\\_{G}\\right)$$其中$\\theta$和$\\theta_G$分别是纵向联邦学习模型和生成模型的参数。此外，$f_G$表示$\\hat{x}_{target}^t$，即生成模型的输出,$f$表示给定所生成样本的纵向联邦学习模型的输出（由$x_{adv}^t$和$\\hat{x}_{target}^t$连接）。此外，$\\Omega(\\cdot)$是生成的未知特征值${\\hat{x}_{target}^t}_{t=1}^n$的正则化项。\n具体方法：\n把进攻方所拥有的数据（蓝色）和随机生成的数据（橙色），合成一个d维向量，其中d为进攻方的特征数量和目标方特征数量之和，随机生成的数据是为了初始化生成模型的初始输入。\n生成模型计算之后，输出生成模型对于目标方特征值的预测。\n把生成模型生成的目标方特征值的预测（橙色）与进攻方所拥有的数据（蓝色）合并，得到另一个d维的向量，作为已经生成的纵向联邦学习预测模型（比如神经网络）的输入。\n得到输出的对不同类别的预测概率矩阵（橙色），与真实的攻方特征值和目标方特征值得到的不同类别的预测概率矩阵（蓝色）求损失。\n对得到的损失进行反向传播，修改生成模型的参数，得到新的生成模型对目标放特征值的预测。\n这种方法对于目标函数为可微的情况下效果不错，也就说明可以用来对逻辑回归和神经网络进行生成模型攻击。\n随机森林的生成模型的攻击 路径限制攻击不适用于随机森林的模型，特别是当随机森林的树数量很大的时候。\n因此，在随机森林模型使用GRN攻击的思想。\n但是，因为随机森林（RF）模型的目标函数并不是可微的，所以不能通过随机森林（RF）把预测损失反向传播给生成模型。\n因此，本文在得到纵向联邦模型（比如随机森林RF）之后，攻方会另外训练一个可微的模型（比如神经网络NN）来近似RF模型。\n实验评价 数据集：\n四个数据集，分别是银行营销（20个特征的2分类），信用卡（23个特征的2分类），诊断（48个特征的11分类）和新闻流行（59个特征的5分类）。\n此外，利用sklearn库生成了两个合成数据集，用于评估预测数据集中样本数n对生成回归网络攻击性能的影响。\n指标：\n对于等式求解攻击（ESA）和生成回归网络攻击（GRNA），由于是回归任务，因此使用每个特征的均方误差（MSE）来衡量它们在重建多个目标特征时的总体准确性。具体而言，每个特征的MSE计算如下：\n$$\\mathrm{MSE}=\\frac{1}{n * d\\_{\\text {target }}} \\sum\\_{t=1}^{n} \\sum\\_{i=1}^{d\\_{\\text {target }}}\\left(\\hat{x}\\_{\\text {target }, i}^{t}-x\\_{\\text {target }, i}^{t}\\right)^{2}$$对于路径限制攻击（PRA），作者测量了正确分支率（CBR）。\n$d_{target}$对等式求解攻击的影响 对于所有数据集，如果满足阈值条件$d_{target}\\le c-1$（在每个子图中用“T”表示），则每个特征的MSE为0，这证明了上面讨论的性质正确。\n通过观察b和c，我们发现即使不满足阈值条件，等式求解攻击仍然可以找到$x_{target}$的良好推断，这大大优于随机猜测方法。\n还有一个明显的趋势，每个特征的MSE随着$d_{target}$分数的增加而增加，即攻方所掌握的特征数越少，供给的准确率越低。\n同时，作者还分析了为什么Bank数据集的MSE增量远大于其他数据集的MSE增量，这是因为不同数据集的数据分布差异。\n由伪逆矩阵计算出的解$\\hat{x}_{target}$在所有解中具有最小的欧几里德范数，即$||\\hat{x}_{target}||_2\\le||x_{target}||_2$\n其中\n$$\\sum\\_{i=1}^{d\\_{\\text {target }}} \\hat{x}\\_{\\text {target }, i}^{2} \\leq \\sum\\_{i=1}^{d\\_{\\text {target }}} x\\_{\\text {target }, i}^{2}$$因此，我们有\n$$\\begin{aligned} \\mathrm{MSE} \u0026 =\\frac{1}{d\\_{\\text {target }}} \\sum\\_{i=1}^{d\\_{\\text {target }}}\\left(\\hat{x}\\_{\\text {target }, i}-x\\_{\\text {target }, i}\\right)^{2} \\\\\\\\ \u0026 =\\frac{1}{d\\_{\\text {target }}} \\sum\\_{i=1}^{d\\_{\\text {target }}}\\left(\\hat{x}\\_{\\text {target }, i}^{2}+x\\_{\\text {target }, i}^{2}-2 \\hat{x}\\_{\\text {target }, i} x\\_{\\text {target }, i}\\right) \\\\\\\\ \u0026 \\leq \\frac{1}{d\\_{\\text {target }}} \\sum\\_{i=1}^{d\\_{\\text {target }}}\\left(\\hat{x}\\_{\\text {target }, i}^{2}+x\\_{\\text {target }, i}^{2}\\right) \\\\\\\\ \u0026 \\leq \\frac{1}{d\\_{\\text {target }}} \\sum\\_{i=1}^{d\\_{\\text {target }}} 2 x\\_{\\text {target }, i}^{2}, \\end{aligned}$$我们便推导出$\\mathrm{MSE}(\\hat{x}_{target},x_{target})$的上界。\n作者分别计算了Bank、Credit、Drive和News四个数据集的上界，分别为0.60、0.14、0.45和0.34。\n一般来说，上界越大，对手的攻击精度就越差。这就解释了为什么Bank的MSE比其他数据集增长得更快。\n$d_{target}$对路径限制攻击的影响 与等式求解攻击类似，攻击精度随着$d_{target}$的增加而降低。这是因为通常更多的目标特征将导致更多可能的预测路径，从而导致选择正确路径的概率降低。\n我们可以发现，第三个数据集是异常的，它甚至随着$d_{target}$的增加而增加了。这是因为Drive数据集有11个类，比其他数据集的类要多得多。因此，在Drive中，每个类别对应的树形路径数量较少。其次，决策树模型在训练过程中只选择信息量大的特征，这意味着Drive数据集中$d_{target}$的增加不一定会增加树中未知特征的数量，因为有些特征可能永远不会被选中。\n综上，较大的目标数据并不总是能降低路径限制攻击的CBR。\n$d_{target}$对生成回归网络攻击的影响 作者展示了生成回归网络攻击对三种模型的攻击性能（LR：逻辑回归、RF：随机森林、NN：神经网络）\n类似地，每个特征的MSE都随着$d_{target}$的增加而上升。这是因为生成回归网络攻击依赖于$x_{adv}$和$x_{target}$之间的特征相关性来推断未知特征值。如果$d_{target}$所占比例较大，学习到的相关性会变弱，导致攻击性能相对较差。然而，即使在$d_{target}$的分数为60%时，生成回归网络攻击仍然比随机猜测方法获得了更好的效果，证明了其有效性。\n作者发现，采用神经网络模型的生成回归网络攻击的性能优于逻辑回归和随机森林模型。原因在于神经网络模型比其他两种模型具有更复杂的决策边界，从而极大地限制了给定相同$x_{adv}$和$v$时$x_{target}$的可能分布。同时，神经网络模型本身具有更多的参数，可以捕获更多关于特征相关性的重要信息，从而获得更好的攻击性能。\n作者还将CBR度量用于评估RF模型上的GRNA，同样效果也比随机猜测方法优秀。\n需要预测的样本数对生成回归网络攻击的影响 四个数据集上的趋势表明，预测数据集中的样本越多，对手可以获得的每个特征的MSE越少。 换句话说，对手可以长期积累更多的预测输出，以提高其攻击精度。\n数据相关性对生成回归网络攻击的影响 由于LR和RF模型的性能低于NN模型，作者推断是因为一小部分推断出的特征值与真实相差甚远，导致整体攻击性能相对较低，于是作者研究数据相关性的影响。\n数据相关性定义如下：\n$$\\begin{aligned} \\operatorname{corr}\\left(x\\_{\\mathrm{adv}}, x\\_{\\mathrm{target}, i}\\right) \u0026 =\\frac{1}{d\\_{\\mathrm{adv}}} \\sum\\_{j=1}^{d\\_{\\mathrm{adv}}} a b s\\left(r\\left(x\\_{\\mathrm{adv}, j}, x\\_{\\mathrm{target}, i}\\right)\\right), \\\\\\\\ \\operatorname{corr}\\left(v, x\\_{\\mathrm{target}, i}\\right) \u0026 =\\frac{1}{c} \\sum\\_{j=1}^{c} a b s\\left(r\\left(v\\_{j}, x\\_{\\mathrm{target}, i}\\right)\\right), \\end{aligned}$$其中$r(a,b)$表示a和b之间的皮尔逊相关系数，$abs(\\cdot)$表示绝对值。 本质上，两个系数越大，对手越容易通过生成回归网络攻击学习特征相关性。\n我们可以观察到相关系数$x_{adv}$和$v$都会影响生成回归网络攻击的攻击性能。$x_{target}$，$i$与$x_{adv}$和$v$之间较弱的相关性导致较低的推断准确度，例如图10a中的特征1和3以及图10b中的特征4和6。\n对策 作者讨论了几种可能减轻所提出的特征推断攻击的潜在防御方法。\n策略名称 效果 Rounding confidence scores 等式求解攻击有效，但生成回归网络攻击效果甚微 Dropout for neural networks model 有效，但攻击者还是有一个很好的推断 Pre-processing before collaboration 未做测试 Post-processing for verification 导致模型预测计算的巨大开销 Hide the vertical FL model 可能会导致新的隐私泄露 Differential Privacy (DP) 不适用 参考文章 【论文阅读】Feature Inference Attack on Model Predictions in Vertical Federated Learning - linear345 - 博客园 (cnblogs.com) 纵向联邦学习VFL 属性推理攻击 Feature inference attack on model predictions in VFL (ICDE21） - 知乎 (zhihu.com) ","date":"2023-01-03T16:27:11+08:00","image":"https://lbqaq.top/p/feature-inference-attack-on-model-predictions-in-vertical-federated-learning/100018879.webp","permalink":"https://lbqaq.top/p/feature-inference-attack-on-model-predictions-in-vertical-federated-learning/","title":"Feature Inference Attack on Model Predictions in Vertical Federated Learning"},{"content":"继上文《在PowerPoint里优雅的插入LaTeX公式》后，没想到我又遇到了LaTeX相关的问题，这次是我博客无法正确的显示公式了。当然，最简单和粗暴的方法就是直接转成图片，但本着能折腾就折腾的精神，还是研究了一下如何优雅的解决。\n问题复现 由于在LaTeX语法中，_是用来表示下标，由于下标经常被使用，很容易就会导致一句话中出现两个_。而在Markdown语法里，下划线是表示斜体的意思，于是Hugo就会将其转义成\u0026lt;em\u0026gt;标签，导致公式格式错误，从而使KaTeX无法正确渲染。\n这就很笨了，本地的Markdown编辑器都没有出现这样的问题，怎么到你Hugo这就拉了呢？\nIs there any way to ignore underscore when rendering markdown? - support - HUGO (gohugo.io)\n有这样问题的人也不止我一个，官方论坛上早在2017年就有人提问了，那么官方的答复是：\n没错，官方并没有给出好的解决方案，只有在文档中稍微提到了一嘴，你可以使用pandoc来进行Markdown的转义。1\n🤔本来用你就是图你的生成速度快，这调用其他程序后，这速度不就慢了没优势了吗。\n没办法，还是自己动手解决吧。\n解决方案 在搜索过后，网上给出的解决方案是在下划线前面加上\\，避免被Hugo进行转义。但是如果在写文档的时候就加上的话，就会导致本地公式无法正确渲染，所以边写边加是肯定不可能了。写完后手动添加，如果是一两个还好，但下划线在LaTeX里实在是太常用了，所以手工修改也不现实。\n于是，我便决定写个小程序来自动修改。由于天天Apex大脑退化严重，我实在想不到什么比较好的字符串处理方法，只好用遍历大法。（这既视感，编译原理：……，什么……在想我的事情……？）\n不玩梗了，直接上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include \u0026lt;fstream\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const bool DEBUG = false; int main(int argc, char* argv[]) { string file; ifstream fin; if (argc \u0026lt;= 1) { cout \u0026lt;\u0026lt; \u0026#34;请输入文件名称：\u0026#34;; cin \u0026gt;\u0026gt; file; } else { file = argv[1]; } fin.open(file); if (!fin.is_open()) { cout \u0026lt;\u0026lt; \u0026#34;无法打开文件\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 1; } // 读入文件 string code((std::istreambuf_iterator\u0026lt;char\u0026gt;(fin)), std::istreambuf_iterator\u0026lt;char\u0026gt;()); fin.close(); if (DEBUG) { cout \u0026lt;\u0026lt; code \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------------\u0026#34; \u0026lt;\u0026lt; endl; } // 所有数学公式的开头和结尾 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; maths; cout \u0026lt;\u0026lt; \u0026#34;开始寻找所有数学公式\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; code.length(); i++) { if (code[i] == \u0026#39;$\u0026#39;) { i++; bool is_double = false; int start = i; if (code[i] == \u0026#39;$\u0026#39;) { is_double = true; i++; start = i; } while (i \u0026lt; code.length() \u0026amp;\u0026amp; code[i] != \u0026#39;$\u0026#39;) { i++; } if (is_double) { i++; } if (i \u0026gt;= code.length() || code[i] != \u0026#39;$\u0026#39;) { cout \u0026lt;\u0026lt; \u0026#34;错误：缺少结束符\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 1; } int end = i; maths.push_back(pair\u0026lt;int, int\u0026gt;(start, end)); cout \u0026lt;\u0026lt; start \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; end \u0026lt;\u0026lt; endl; if (DEBUG) { string math = code.substr(start, end - start); cout \u0026lt;\u0026lt; math \u0026lt;\u0026lt; endl; } } } cout \u0026lt;\u0026lt; \u0026#34;寻找完成，开始处理\u0026#34; \u0026lt;\u0026lt; endl; int count = 0; for (int i = 0; i \u0026lt; maths.size(); i++) { for (int j = maths[i].first + count; j \u0026lt; maths[i].second + count; j++) { if (code[j] == \u0026#39;_\u0026#39;) { code.insert(j, \u0026#34;\\\\\u0026#34;); count++; j++; } else if (code[j] == \u0026#39;\\\\\u0026#39;) { j++; if (code[j] == \u0026#39;\\\\\u0026#39;) { code.insert(j, \u0026#34;\\\\\\\\\u0026#34;); count += 2; j += 2; } else if (code[j] == \u0026#39;{\u0026#39; || code[j] == \u0026#39;}\u0026#39;) { code.insert(j, \u0026#34;\\\\\u0026#34;); count++; j++; } } } } if (DEBUG) { cout \u0026lt;\u0026lt; code \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;处理完成，开始写入文件\u0026#34; \u0026lt;\u0026lt; endl; ofstream fout; string location = file.substr(0, file.find_last_of(\u0026#39;\\\\\u0026#39;) + 1); fout.open(location + \u0026#34;index.md\u0026#34;); if (!fout.is_open()) { cout \u0026lt;\u0026lt; \u0026#34;无法打开文件\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 1; } fout \u0026lt;\u0026lt; code; return 0; } 由于只是随手写的小工具，所以也没有分函数啥的，直接全放一起了。\n这个程序会匹配$...$和$$...$$这两种格式，将其中所有的_替换为\\_，所有的\\\\替换为\\\\\\\\，同时将文件在原位置保存为index.md。\n这样每次写好文章，只要将其拖到该程序上就能自动转换完成了。\n这样就能确保本地查看编辑和网页都可以正确显示公式了。缺点则是每个有公式的文件都会多保存一份，不过文本文件并不是很大，所以也无伤大雅。\n当然，这个程序还有优化的空间，比如自动对含有公式的文章进行处理等等。不过看这我文章更新的速度🕊️，手动拖一下还是可以接受的。\n更新记录 2023.7.20：\n增加对\\{和\\}的处理 2023.1.3：\n增加对\\\\的处理 Content Formats |Hugo (gohugo.io)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-02T22:19:15+08:00","image":"https://lbqaq.top/p/latex-in-hugo/103706981.webp","permalink":"https://lbqaq.top/p/latex-in-hugo/","title":"让Hugo优雅的显示公式"},{"content":"最近，需要我在PPT中插入公式的次数越来越多了。最传统的办法自然是将公式生成好后直接进行截图插入，但这种方式还是不够优雅，如果需要调节大小也十分的麻烦，于是我便通过检索找到了两种插入公式的方法，在此做一个记录。\n使用原生的公式功能 2202年了，如果说PowerPoint本身不支持LaTeX公式那就大错特错了。\n将LaTeX代码插入到文本框中 选中刚刚输入的代码，依次点击功能区上的“插入”——“公式”——“专用” 只需要简单两步即可转换完成。然而，这种方法却存在很大的问题，就是支持的公式太少了，一些简单的公式还可以成功转换，但如果是公式块或者用了一些宏包，就会导致转换不出来。\n这种方式的优点就是无需额外配置，以及可以与文字放在一起，方便排版。但如果你的公式比较复杂，那我还是推荐下面的方法。\n使用IguanaTex插件 要说对LaTeX支持最好的，那肯定就是使用你电脑上安装好的发行版进行生成，IguanaTex插件就是基于这种方式实现的。\n所以想要使用IguanaTex，你必须要准备好一个LaTeX发行版，我这里推荐MiKTeX，它不会安装完整的宏包而是在你需要的时候进行安装，避免占用过大的空间，具体的安装方法这里就不展开了。\n在官网上下载最新版本，下载后缀名为ppam的文件放入C:\\Users\\%APPDATA%\\Microsoft\\AddIns目录中 打开PPT，依此选择： 文件-\u0026gt;选项-\u0026gt;加载项-\u0026gt;管理（下拉框中选择：PowerPoint加载项）-\u0026gt;转到 在弹出的对话框中选择： 添加-\u0026gt;选择刚下载的插件文件 此时功能区上面就已经有了IguanaTex，点击第一个New LaTeX display就可以插入公式了。我们现在可以点击Main Settings来进行修改相关设置。 我们在这里可以进行修改临时文件位置以及图片生成的方式 我推荐将Output修改成Vector，这样生成的公式就是矢量形状，即使放大也不会变形。\n下面就是生成的公式，可以看出每个字母都是图形。同时公式也可以使用该插件进行修改，还是比较方便的。\n综上，个人推荐还是使用第二种方式，唯一麻烦的地方就是你需要自备LaTeX环境。\n最近的文章真的是越来越水了QAQ\n","date":"2022-12-31T15:25:22+08:00","image":"https://lbqaq.top/p/latex-in-ppt/102317894.webp","permalink":"https://lbqaq.top/p/latex-in-ppt/","title":"在PowerPoint里优雅的插入LaTeX公式"},{"content":"由于运营商默认提供的DNS有很多的污染，许多域名直接0.0.0.0或者127.0.0.1伺候，导致上网体验并不是很好，故想到自建加密DNS来抵御污染。\n一开始使用的是AdGuardHome，然而在我看到了CloudflareSpeedTest这个项目后，就萌生了ip重定向这个需求，为此我又套了一层mosdns（经典为醋包饺子）。既然上了mosdns，就干脆做配上分流吧，于是现在的这套方案就形成了。虽然我的这些需求一个mosdns就可以解决，但AdGuardHome的前端ui、更方便的广告过滤、数据统计这些功能是mosdns所没有的。\n23.2.8新方案 由于CloudFlare的优选IP在不同设备上速度都不同，所以在设备本地搭建更优。于是，我现在将mosdns从服务器上移到了本地。当然，在路由器上部署要更好，但我家的路由器性能太弱了，就算了。同时，去广告就交给mosdns，这样就无需使用两个软件进行套娃了。\nmosdns在这段时间也更新了V5版本，原先的配置文件也无法使用了，正好做出V5可用的配置。\n在该配置文件中，需要用上以下项目提供的域名/IP文件：\nreject-list.txt 和 direct-list.txt CN-ip-cidr.txt cloudflare.txt：由ip.txt和ipv6.txt合并而来 ad-domains.txt：下载domains.txt并改名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 # Powered by luoboQAQ log: level: info plugins: # 缓存插件 - tag: cache type: cache args: size: 10240 lazy_cache_ttl: 86400 # 将缓存保存在磁盘 dump_file: ./cache.dump # 转发至本地服务器的插件 - tag: forward_local type: forward args: upstreams: - tag: alidns_doh addr: \u0026#34;https://223.5.5.5/dns-query\u0026#34; - tag: dnspod_doh addr: \u0026#34;https://120.53.53.53/dns-query\u0026#34; # 转发至远程服务器的插件 - tag: forward_remote type: forward args: upstreams: - tag: easymosdns addr: \u0026#34;https://doh.apad.pro/dns-query\u0026#34; bootstrap: \u0026#34;223.5.5.5\u0026#34; - tag: dns_sb addr: \u0026#34;https://45.11.45.11/dns-query\u0026#34; # fallback 用本地服务器 sequence # 返回不包含本地 ip 则 reject - tag: local_ip_sequence type: sequence args: - exec: $forward_local - matches: resp_ip \u0026amp;./data/CN-ip-cidr.txt exec: accept - exec: drop_resp # v5.1.2 以后不能用 reject # fallback 用远程服务器 sequence - tag: remote_sequence type: sequence args: - exec: $forward_remote # CloudFlare劫持到优选IP - matches: - resp_ip \u0026amp;./data/cloudflare.txt exec: black_hole 172.67.210.33 - exec: accept # fallback插件 - tag: fallback type: fallback args: primary: local_ip_sequence secondary: remote_sequence threshold: 500 always_standby: true # 主要运行逻辑插件 - tag: main type: sequence args: - matches: qtype 65 exec: reject 3 # 去广告 - matches: qname \u0026amp;./data/reject-list.txt exec: reject 3 - matches: qname \u0026amp;./data/ad-domains.txt exec: reject 3 - exec: prefer_ipv4 - exec: $cache - matches: has_resp exec: accept - matches: qname \u0026amp;./data/direct-list.txt exec: $forward_local - matches: has_resp exec: accept - exec: $fallback # 启动 udp服务器 - type: udp_server args: entry: main listen: 127.0.0.1:53 此配置文件参考了该回答\n方案设计 首先由AdGuardHome接受请求，判断是否为广告域名:\n是：直接拦截，结束流程 否：继续传入mosdns 判断是否为国内域名：\n是：向本地DNS查询 否：向远端DNS查询 判断是否为CloudFlare的IP：\n是：修改响应为优选的IP 否：不进行操作 系统搭建 搭建mosdns 如何安装和配置mosdns，官方文档已经写的非常详细了，直接看文档就好了。\n配置文件主要参考了pmkol/easymosdns\n这里主要分享一下我的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 # Powered by luoboQAQ log: file: \u0026#34;./mosdns.log\u0026#34; level: error # 数据源设置 data_providers: - tag: CloudFlareIP file: \u0026#34;./rules/cloudflare.txt\u0026#34; auto_reload: true - tag: chinalist file: \u0026#34;./rules/geosite_cn.txt\u0026#34; auto_reload: true plugins: # 缓存的插件 - tag: cache type: cache args: size: 10240 lazy_cache_ttl: 86400 cache_everything: true # 匹配PTR类型请求的插件 - tag: query_is_ptr type: query_matcher args: qtype: [12] # 匹配TYPE65类型请求的插件 - tag: qtype65 type: query_matcher args: qtype: [65] # 屏蔽请求的插件 - tag: black_hole type: blackhole args: rcode: 0 ipv4: \u0026#34;127.0.0.1\u0026#34; ipv6: \u0026#34;::1\u0026#34; # 匹配本地域名的插件 - tag: query_is_cn_domain type: query_matcher args: domain: - \u0026#34;provider:chinalist\u0026#34; # 转发至本地服务器的插件 # [local|alidns] - tag: forward_local type: fast_forward args: upstream: - addr: \u0026#34;udp://100.100.2.138\u0026#34; - tag: forward_alidns type: fast_forward args: upstream: - addr: \u0026#34;https://dns.alidns.com:443/dns-query\u0026#34; dial_addr: \u0026#34;223.5.5.5\u0026#34; # CloudFlare劫持的插件 - tag: response_is_cloudflare_ip type: response_matcher args: ip: - \u0026#34;provider:CloudFlareIP\u0026#34; - tag: hijack_cloudflare_ip type: blackhole args: ipv4: 104.16.111.240 # 转发至远端服务器的插件 - tag: forward_easymosdns type: fast_forward args: upstream: - addr: \u0026#34;https://doh.apad.pro/dns-query\u0026#34; bootstrap: \u0026#34;223.5.5.5\u0026#34; # 主要的运行逻辑插件 - tag: main_sequence type: sequence args: exec: # 缓存 - cache # 屏蔽TYPE65类型请求 - if: qtype65 exec: - black_hole - _return # 分流 - if: \u0026#34;(query_is_cn_domain) || (query_is_ptr)\u0026#34; exec: - forward_alidns else_exec: - forward_easymosdns # CloudFlare劫持到优选IP - if: response_is_cloudflare_ip exec: - hijack_cloudflare_ip - _return servers: - exec: main_sequence timeout: 5 listeners: - addr: 127.0.0.1:5533 protocol: udp 其中，cloudflare.txt来自于上面的CloudflareSpeedTest项目，是包含ipv4和ipv6的CloudflareIP段。\ngeosite_cn.txt是国内域名的集合，来自Loyalsoldier/v2ray-rules-dat，将geosite.dat使用mosdns v2dat unpack-domain 解包得到。\n这里我没有启用mosdns的缓存，因为我在AdGuardHome里启用，就不重复缓存了。如果你是直接使用mosdns，那么就可以启用缓存。\n事实上，还是要开启mosdns的缓存，以此来减小DNS查询的延时。\n搭建AdGuardHome 这里我为了方便，就直接使用了docker，其实可以不用的说\n1 2 3 4 5 6 docker run --name adguardhome\\ --restart unless-stopped\\ -v /root/adguardhome/work:/opt/adguardhome/work\\ -v /root/adguardhome/conf:/opt/adguardhome/conf\\ --net=host\\ -d adguard/adguardhome 我比较懒，就直接让容器使用了host模式，这样就不用配置端口了。\n设置方面\n上游DNS服务器填入127.0.0.1:5533，即mosdns的端口。\n启用启用 EDNS 客户端子网，使DNS查询附上用户的ip，使解析的ip地址靠近本地位置。\n开启乐观缓存，设置覆盖最小TTL值为600，覆盖最大TTL值为3600，避免每次都要查询\n开启启用加密（HTTPS、DNS-over-HTTPS、DNS-over-TLS），启用DoH\n根据自己的喜好添加过滤规则\n我推荐启用CHN: anti-AD，这个列表还是很不错的\nNginx反代配置 这里为了避免DoH被滥用，我修改了默认的路径，同时将默认路径返回444（中断连接）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 server { listen 80; listen 443 ssl http2; server_name you.domain; if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } ssl_certificate ./cert/xxx.pem; ssl_certificate_key ./cert/xxxx.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的加密套件的类型。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #表示使用的TLS协议的类型。 ssl_prefer_server_ciphers on; location /set/ { proxy_pass http://127.0.0.1:11451/; proxy_redirect / /set/; proxy_cookie_path / /set/; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location /query { proxy_http_version 1.1; proxy_pass https://127.0.0.1:11450/dns-query; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location / { return 444; } } 客户端配置 Windows 在win11 22H2中，在 设置——网络和Internet中 就可以设置加密DNS，输入服务器ip地址后选择手动模板就可以输入DoH地址了。\n如果还没有升级到这个版本，可以用管理员模式运行powershell执行下面的命令\n1 Add-DnsClientDohServerAddress -ServerAddress \u0026#39;123.xx.xx.xx\u0026#39; -DohTemplate \u0026#39;https://your.domain/dns-query\u0026#39; -AllowFallbackToUdp $False -AutoUpgrade $True 随后直接将你服务器的ip设置成DNS服务器就可以了，系统会自动使用DoH进行请求。\nAndroid 安卓系统从9开始支持DoT，只要在连接与共享——私人DNS填入服务器的域名即可。\n根据谷歌的公告，从13开始，安卓开始支持DoH。在此之前，想要使用DoH就只能依靠第三方软件了。\n后记 单独使用AdGuardHome的情况下，开启缓存平均处理时间是5ms；AdGuardHome+mosdns目前是11ms。\n折腾了两层解析，只是为了实现CloudFlare的IP优选，速度果然不出所料的慢了一点（当然也可能是缓存还没完全）。就当是学习了，正常使用留其一即可。_(:з)∠)_\n通过这次折腾，对DNS的认识更加深了一步，也水了一篇博客。\n","date":"2022-11-30T11:05:31+08:00","image":"https://lbqaq.top/p/mydns/100669875.webp","permalink":"https://lbqaq.top/p/mydns/","title":"自建DNS实现分流及广告过滤"},{"content":"前言 说到搞机，那肯定绕不开大名鼎鼎的Magisk。就我来说，root完后做的第一件事，就是安装各种各样的模块，但是，我却从来没有研究过Magisk的内容。同时，现在也有许多心怀不轨的人制作锁机模块骗人刷入。所以，了解Magisk模块的一些基本内容就显得比较重要了。\n认识Magisk模块 根据官方的文档，一个典型的Magisk模块的目录应该如下所示：1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 module.zip │ ├── META-INF │ └── com │ └── google │ └── android │ ├── update-binary \u0026lt;--- 从官方仓库上下载的module_installer.sh │ └── updater-script \u0026lt;--- 只有一行文字为 \u0026#34;#MAGISK\u0026#34; │ ├── module.prop \u0026lt;--- 模块的标识信息 ├── customize.sh \u0026lt;--- (可选)用于自定义模块安装过程 ├── ... ├── ... /* 模块的其余文件 */ │ 可以看出来，META-INF目录是由官方提供，并不需要我们进行修改。\nmodule.prop 这个文件是模块的标识信息，模块的基本信息就存放在这里，文件的格式如下。1\n1 2 3 4 5 6 7 id=\u0026lt;string\u0026gt; name=\u0026lt;string\u0026gt; version=\u0026lt;string\u0026gt; versionCode=\u0026lt;int\u0026gt; author=\u0026lt;string\u0026gt; description=\u0026lt;string\u0026gt; updateJson=\u0026lt;url\u0026gt; (optional) 各键值的作用说明如下：\n名称 说明 id 模块的唯一标识符，需符合该正则表达式^[a-zA-Z][a-zA-Z0-9._-]+$ name 模块名称 version 模块版本号 versionCode 模块版本标识，必须为整数，用于更新 author 作者信息 description 模块描述 updateJson 更新信息链接，现在Magisk移除了内部的更新功能，这个属性应该是无用了 system文件夹 Magisk的一个主要作用就是对系统文件进行注入或替换，只要将文件按顺序放入此目录中即可。例如我想修改hosts文件，只需要将修改好的hosts文件放入system/etc这个目录下，Magisk就会自动将其替换了。\n如果要替换/vendor、/product或/system_ext中的文件，只需将它们分别放在system/vendor、system/product和system/system_ext下。Magisk就会自动替换完成。\ncustomize.sh 这是自定义模块安装过程，如果只是简单的替换文件就不需要用到它。但是，很多时候我们并不是仅需替换文件，还需要执行一些脚本，这里就需要使用到它了。\n根据官方文档，这里支持以下的环境变量：\n变量名 作用 MAGISK_VER (string) 当前安装的Magisk的版本字符串（例如v20.0） MAGISK_VER_CODE (int) 当前安装的Magisk的版本代码（例如20000） BOOTMODE (bool) 如果模块正在Magisk应用程序中安装，则为true MODPATH (path) 安装模块文件的路径 TMPDIR (path) 可以临时存储文件的位置 ZIPFILE (path) 您的模块的安装zip ARCH (string) 设备的CPU架构，值可以是arm、arm 64、x86或x64 IS64BIT (bool) 如果$ARCH为arm 64或x64，则为true API (int) 设备的API级别（Android版本）（例如，Android 5.0为21） 以及以下的命令：\nui_print \u0026lt;msg\u0026gt;：在页面上显示信息 abort \u0026lt;msg\u0026gt;：将错误消息打印到控制台并终止安装 set_perm和set_perm_recursive：修改文件权限 实践 修改系统Hosts 我一开始想研究Magisk的契机，就是想要修改我手机的Hosts文件。一开始按百度的教程做，但没有效果，后来就尝试了一下Magisk模块，直接就成功了。\n有了前面知识的铺垫，想要实现这个功能就非常简单了，下面列出我们程序的目录树。\n1 2 3 4 5 6 7 8 9 10 11 ChangeHosts.zip ├── META-INF │ └── com │ └── google │ └── android │ └── update-binary │ └── updater-script ├── module.prop ├── system └── etc └── hosts 实际我们需要修改的部分只有module.prop和hosts，hosts是我们需要修改的文件，所以我们就只要关注module.prop。\n1 2 3 4 5 6 id=ChangeHosts name=ChangeHosts version=v1.0.0 versionCode=100 author=luoboQAQ description=修改hosts文件来屏蔽广告 如此看来，如果只要替换文件，基本没有任何难度。\n使用dnscrypt-proxy实现DoH 这部分我正在研究，等研究明白了就补上🕊️。\nMagisk官方开发指导\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-10-07T11:30:17+08:00","image":"https://lbqaq.top/p/%E7%AE%80%E6%98%93magisk%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%B6%E4%BD%9C/95936465.webp","permalink":"https://lbqaq.top/p/%E7%AE%80%E6%98%93magisk%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%B6%E4%BD%9C/","title":"简易Magisk模块的制作"},{"content":"之前在《如何优雅的看番》这篇文章中我提到了补帧的3款软件，在Windows系统上我使用的是dmitriRender这款软件，而其并没有提供Linux版本的程序。与之相反的是，SVP不但提供了Linux版本，而且还是免费的。\n由于官方文档是英文且有些地方没有表述清楚，这里我就将我安装和配置的方式记录下来供大家参考。\n安装 对于Arch用户非常简单，直接yay -S svp-bin即可完成安装。\n对于其他发行版，可以选择在官网上下载并安装。\n安装播放器，这里我推荐安装VLC，因为其安装简便，并且后面配置SVP也很容易。\n安装直接输入sudo pacman -S vlc即可\n如果需要GPU加速，还需要安装相应的插件sudo pacman -S ocl-icd。我之前就是没有安装，导致一直无法读取到我的显卡。\n安装好后就可以在SVP菜单——应用程序设置——GPU加速里看到你的显卡了\n配置 修改VLC插件目录权限，以便SVP写入插件。\n1 sudo chmod 777 /usr/lib/vlc/plugins/video_filter 在SVP的菜单里选择“工具”——“VLC的SVP插件”，将其选中\n检查/usr/lib/vlc/plugins/video_filter目录下的libsvpcontrol_plugin.so和libvapoursynth_plugin.so是否有可执行权限，我之前就是因为没有给执行权限，导致VLC一直不会调用SVP\n1 2 chmod +x /usr/lib/vlc/plugins/video_filter/libsvpcontrol_plugin.so chmod +x /usr/lib/vlc/plugins/video_filter/libvapoursynth_plugin.so 官网表示需要开启“反交错”才会启用，但实测好像不开启也可以运行。\n如果VLC偏好设置——显示设置——全部——控制界面有SVP control interface\n以及滤镜里有Vapoursynth filter即表明安装成功了。\n小结 官网上的安装文档写了很长，但实际上对于VLC使用SVP并不复杂，复杂的是MPV使用SVP。本来打算配几张图的，但实际写下来也没有发现需要图片辅助说明的，那就算了，相信聪明的你一定能看懂 _(:з)∠)_\n","date":"2022-08-23T09:58:00+08:00","image":"https://lbqaq.top/p/svp4inlinux/100213137.webp","permalink":"https://lbqaq.top/p/svp4inlinux/","title":"在Linux下安装SVP4"},{"content":"随着答辩的结束，智慧物流这个项目就算是彻底结束了。不出意外的话，这应该是我大学生涯的参加的最后一个比赛了。看了看git的记录，提交的代码超过了1k行，同时也花了不少的时间在上面。做了这么多东西，不留下点什么总觉得不好，想来想去，还是把比赛做的东西做个小结吧，也算是纪念我这不算丰富的比赛时光吧（雾）\n这里非常感谢我们队长，比赛里许多关键的问题是他解决的，他的动手能力和善于提出创新性想法的能力，都是值得我去学习的。也感谢另一位队友，在赛前紧张的准备时间里独自一人分担了制作PPT的工作，并且能做出如此精美的PPT。（大佬带带我 _(:з)∠)_ ）\n感想也就写这么多吧，下面主要介绍我们比赛时所做的一些工作和创新。\n程序的大体思路和流程 根据赛题要求，程序要实现下面几个功能：\n导航至邮件分拣台 运用视觉算法识别邮件 机械臂定位抓取邮件 机器人运送邮件投入正确的邮箱 所以程序大致的步骤就是：建图-\u0026gt;导航至分拣台-\u0026gt;识别-\u0026gt;抓取-\u0026gt;导航至投递点-\u0026gt;投递-\u0026gt;导航至分拣台-\u0026gt;\u0026hellip;\u0026hellip;\n这里我就按上面的要求一部分一部分的讲了。\n建图 建图算法是Gmapping算法，这是一种基于2D激光雷达通过使用RBPF粒子滤波方法所完成的二维栅格地图构建SLAM算法，它也是移动机器人中适用最多的算法。它对激光雷达频率要求相对较低，稳定性较高，且能够结合里程计、陀螺仪等进行定位与地图构建，构建小场景地图时速度快、计算量小，缺点就是非常依赖里程计，所以无法适应不平坦的地面，无法使用回环检测，在大场景、粒子多的情况下，特别消耗资源。\n当然我们并没有去仔细研究这个算法，建图的话按照官方提供的教程来一步步做就好了。不得不吐槽的是我们的小车一开始后轮是偏高的，导致雷达会打到地面，预选赛建图的时候一直建不好，最终只能靠侧边的雷达才把图建好，当时以为车就是这样的，直到正赛时才知道是车的问题。所以这种硬件问题一定要及时和厂商联系，不然全是泪啊😭。\n导航 导航这里不是我们写，而是使用了官方提供的导航包。根据培训文档，这里主要采用了AMCL自适应蒙特卡罗算法，它是机器人在二维移动过程中的一种概率定位系统，通过它实现了自适应（或 kld 采样）的蒙特卡罗定位方法。由于采用粒子滤波器来跟踪已经知道的地图中机器人位姿，故对于大范围的局部定位问题工作良好。路径规划则是最短路径规划算法，例如采用Floyd算法、Dijkstra算法、Bellman-Ford算法等。\n导航这里其实是有大坑的，我们最终比赛时就栽在这里了。我们发现小车运行时，激光雷达经常会发生错位，导致导航发生偏移。这种情况基本是出现在小车转向时，我们怀疑是轮子打滑，也调紧了后轮的弹簧，但也没有用。我们当时认为这就是小车本身的局限性，同时在小车运行时也会自动调整至正确位置，我们就没有特别重视这个问题。结果在正式比赛时导航就出现偏移，导致好几个包裹都错位抓取了，虽然最终都全部抓取上了，但浪费了很多时间，非常的可惜。所以有时间的话，一定要看看官方提供的导航定位算法，或者联系厂家看看雷达有无问题，不然程序没问题，却因为硬件问题而出错还是很难受的。( ‘-ωก̀ )\n图像识别 图像识别这里我们是调用是百度的PaddleOCR模块，由于ROS里的Python是2版本的，我们采用的也是PaddleOCR里的develop分支而非最新版本。\n我们一开始是打算自己训练PaddleOCR模型的，然而我尝试了一晚上，不是很清楚模型训练的方法，好不容易运行了一个公开的训练集，发现训练时间要一天多，同时还需要自己做训练集。考虑到时间的问题，最终还是选择采用官方的模型。当然，最主要的原因还是分布式图像识别提升了性能，这部分我在下面会提到，这里就先按下不表。\n机械臂抓取及投递 根据机械臂的官方文档，这里涉及的坐标系主要是两种，一种是关节坐标系，一直是笛卡尔坐标系。关节坐标系比较难以理解，我们还是采用比较直观的笛卡尔坐标系。\n同样，机械臂的抓取也有3种不同模式：MOVJ、MOVL、JUMP。MOVJ模式相较于MOVL模式，速度快；MOVJ模式相较于JUMP模式，稳定性高，不易越界。1\n综上，我们的机械臂控制都采用的是笛卡尔坐标系里的MOVEJ模式，这样能保证机械臂抓取时不会出现超出抓取范围的异常。\n控制机械臂基本就只要用到下面这几个话题，还是比较容易的：\nDobotServer/SetPTPCmd：移动机械臂到指定坐标 DobotServer/SetEndEffectorSuctionCup：机械臂气泵控制 DobotServer/ClearAllAlarmsState：清除机械臂警报 投递就没什么好说的了，根据文字识别的结果进行投递，只要能抓取到，基本上不会出现投递错位的情况。这里会出现的问题主要还是导航不准，容易偏或者撞。解决办法只能是不停的测试找准坐标以及将导航目的位置远离投递点。\n一些创新点 键盘操控程序 在我们的程序中，主要是通过开启两个线程来实现程序的暂停和恢复，如果使用input函数进行键盘输入的接收，则会阻塞线程，同时在输入完成后还需要按下回车，不是很合适。官方是提供了一个键盘控制程序的样例，然而这个程序有个我认为很大的BUG，会导致程序的输出偏移。\n作为一个对代码美观有洁癖的人，这怎么能忍，于是我开始了百度，下面是我找到的可以在Windows和Linux两种环境下实现类似C语言getchar()函数的代码。2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def getChar(): # figure out which function to use once, and store it in _func if\u0026#34;_func\u0026#34; not in getChar.__dict__: try: # for Windows-based systems import msvcrt # If successful, we are on Windows getChar._func=msvcrt.getch except ImportError: # for POSIX-based systems (with termios \u0026amp; tty support) import tty, sys, termios # raises ImportError if unsupported def _ttyRead(): fd = sys.stdin.fileno() oldSettings = termios.tcgetattr(fd) try: tty.setcbreak(fd) answer = sys.stdin.read(1) finally: termios.tcsetattr(fd, termios.TCSADRAIN, oldSettings) return answer getChar._func=_ttyRead return getChar._func() answer = getChar() 这里和官方提供的程序主要不同就在是tty.setcbreak(fd)，但我不知道原理，不过既然能用，就算了😇。\n上面的代码还包括在Windows环境下的情况，我们不需要如此复杂，稍作修改将其整合进我们的程序，就构成了一个多线程程序的模板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #!/usr/bin/env python # coding=utf-8 import rospy import threading import sys import termios import tty def main(): \u0026#39;\u0026#39;\u0026#39;程序主要逻辑入口\u0026#39;\u0026#39;\u0026#39; pass def getKey(): \u0026#39;\u0026#39;\u0026#39;获取输入的字符\u0026#39;\u0026#39;\u0026#39; fd = sys.stdin.fileno() oldSettings = termios.tcgetattr(fd) try: tty.setcbreak(fd) key = sys.stdin.read(1) finally: termios.tcsetattr(fd, termios.TCSADRAIN, oldSettings) return key def initKeyListener(): \u0026#39;\u0026#39;\u0026#39;输入监听程序\u0026#39;\u0026#39;\u0026#39; while(1): key = getKey() if key == \u0026#39;k\u0026#39;: rospy.loginfo(\u0026#34;退出程序\u0026#34;) os._exit(0) elif key == \u0026#39;a\u0026#39;: rospy.loginfo(\u0026#34;恢复导航\u0026#34;) elif key == \u0026#39;s\u0026#39;: rospy.loginfo(\u0026#39;取消导航\u0026#39;) elif key == \u0026#39;q\u0026#39;: rospy.loginfo(\u0026#39;开始执行程序\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: # 给本程序初始化一个节点名称 rospy.init_node(\u0026#39;match_topic\u0026#39;) # 开一个线程处理键盘监听 key_thread = threading.Thread(target=initKeyListener) key_thread.start() # 开一个线程处理任务 main_thread = threading.Thread(target=main) main_thread.start() 摄像头分辨率提升及去畸变 由于ROS默认从摄像头中获取的图像是640*480，且去畸变也是根据这个分辨率进行设置的，这会导致文字识别很容易识别不出文字。我们将小车上的摄像头接入电脑，发现是720P的，既然你能清晰，那为什么不用呢？于是，我们修改了相关的lanuch文件，将摄像头的分辨率提升到了720P，并使用我们自己打印的标定板进行标定。\n下面介绍一下修改的方法\n在moveit_ws/src/moveit/probot_vision/launch目录下，我们可以看到usb_cam_in_hand.launch文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;usb_cam\u0026#34; pkg=\u0026#34;usb_cam\u0026#34; type=\u0026#34;usb_cam_node\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;video_device\u0026#34; value=\u0026#34;/dev/video0\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;image_width\u0026#34; value=\u0026#34;1280\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;image_height\u0026#34; value=\u0026#34;720\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;pixel_format\u0026#34; value=\u0026#34;yuyv\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;camera_frame_id\u0026#34; value=\u0026#34;cameral_base\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;io_method\u0026#34; value=\u0026#34;mmap\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;camera_info_url\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;file://$(find probot_vision)/ost-720p.yaml\u0026#34; /\u0026gt; \u0026lt;!--rosparam file=\u0026#34;$(find probot_vision)/ost_4_new.yaml\u0026#34; command=\u0026#34;load\u0026#34; /--\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; 对其的image_width和image_height进行修改，改为1280和720即可实现摄像头画质提升至720P。\n对于手动标定，我们需要准备标定板，可以自己打印也可以上淘宝购买，就是像下面这样的黑白方格。\n然后在小车上启动标定程序（为什么不在自己电脑上启动呢，因为小车上已经帮你做好硬件端口绑定了，在自己电脑上还要再来一次）\n1 2 3 4 # 启动摄像头 roslaunch usb_cam usb_cam-test.launch # 启动标定程序 rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.024 image:=/usb_cam/image_raw camera:=/usb_cam 这里要注意修改size参数，改成你标定板的黑白格中间交点的个数。 square参数这里则是你标定板上方格的边长，单位是米。\n启动完成以后就可以看到标定界面了，通过调整标定板的上下左右以及角度，让右边的进度条全变绿就算标定完成了。点击计算按钮得到数据，将保存的yml文件路径替换上面的camera_info_url。\n仅仅是这样还不算是完成，我们还需要修改去畸变程序里的参数，将moveit_ws/src/moveit/probot_vision/src/image_correct.cpp里的相关参数按照yml文件的参数进行修改。（这里有疑似是自动读取的代码，但被注释了，我们也没测试能不能用）修改好后就可以执行编译了，我们在moveit_ws目录下执行catkin_make --pkg probot_vision，等待编译完成后这项工作就算完成了。\n后退距离判断 由于小车的后面是没有雷达的，为了避免碰撞，我们编写了基于摄像头的后退距离判断。当小车到达分拣台前时，调用摄像头进行拍照，对其进行蓝色区域的识别，得到分拣台在图像中的像素位置，再利用公式进行转化，得到小车当前距离分拣台的距离，最后使用check话题控制小车后退至距离分拣台5cm左右的位置，既避免了碰撞，又最大化了抓取范围。\n由消息驱动程序逻辑 在一开始，我们的程序是在函数里调用小车导航，并阻塞直到导航成功再继续执行。这样的程序有个问题，就是当小车出现错误时，无法立即停下小车并保存当前程序执行的进度。于是，我们便将程序修改为基于ROS消息来驱动。这样的好处是程序只有收到成功或者失败的消息后才会执行对应的逻辑，便于失败后状态的恢复。\n想要实现相关的功能，首先是导航不能采用原来基于动作的模式了，而是改成基于消息的模式。我们在程序运行的一开始注册相关的话题发布者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 def initPublisher(): # 微调发布器 global checkPub # 暂停导航发布器 global pauseNav # 目标点发布器 global goalPub goalPub = rospy.Publisher( \u0026#39;move_base/goal\u0026#39;, MoveBaseActionGoal, queue_size=1) # 目标点里面的goal_id的id与上一次的id不能相同 checkPub = rospy.Publisher(\u0026#39;check\u0026#39;, String, queue_size=1) pauseNav = rospy.Publisher( \u0026#39;move_base/cancel\u0026#39;, GoalID, queue_size=1) 同时，我们也需要注册相关话题的监听者以及对应的回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def initListener(): # 订阅导航结果话题数据 rospy.Subscriber(\u0026#39;move_base/result\u0026#39;, MoveBaseActionResult, navCallback) # 订阅（微调）走固定距离结果话题数据 rospy.Subscriber(\u0026#39;check_server/result\u0026#39;, check_msgActionResult, checkCallback) rospy.loginfo(\u0026#34;初始化订阅话题成功\u0026#34;) def checkCallback(data): \u0026#39;\u0026#39;\u0026#39;位置微移回调\u0026#39;\u0026#39;\u0026#39; if data.result.issuccess: rospy.loginfo(\u0026#34;位置微调完成\u0026#34;) pass def navCallback(data): \u0026#39;\u0026#39;\u0026#39;导航消息回调\u0026#39;\u0026#39;\u0026#39; PROVINCES = {\u0026#34;四川\u0026#34;, \u0026#34;安徽\u0026#34;, \u0026#34;湖南\u0026#34;, \u0026#34;广东\u0026#34;, \u0026#34;浙江\u0026#34;, \u0026#34;江苏\u0026#34;, \u0026#34;福建\u0026#34;, \u0026#34;河南\u0026#34;} if data.status.status == 3: rospy.loginfo(\u0026#34;导航到达指定地点\u0026#34;) goal_name = data.status.goal_id.id.split(\u0026#39;_\u0026#39;)[0] if goal_name[:9] == \u0026#34;分拣台\u0026#34;: # 到达分拣台前 pass elif goal_name[:6] in PROVINCES: # 到达投递点 pass else: rospy.logwarn(\u0026#34;未知的节点:{}\u0026#34;.format(data.status.goal_id.id)) elif data.status.status == 4: rospy.logwarn(\u0026#34;导航失败,当前id为:{}\u0026#34;.format(data.status.goal_id.id)) else: rospy.logwarn(\u0026#34;导航被取消:{}\u0026#34;.format(data.status.status)) 在导航消息回调中，我们使用goal_id.id来进行目标地点的传递，其构造模式为targetName +'_' + str(time.time())[-9:-3]。这样既有目标地点信息，也避免了id重复。这里一个汉字占3位，所以看到上面的[:6]的写法也就代表前2个字。\n分布式部署图像识别 对于图像识别，我们一开始是放在小车上进行的，结果发现在小车上识别速度并不是很快，平均每张图片需要5~6秒的时间才能完成。\n检查小车的CPU发现，这性能还是不要指望其来跑图像识别算法了，还是采用在自己的电脑上跑图像识别，将结果返回给小车吧。\n想要实现这样的功能，就需要在电脑里装好ROS环境，我们是直接使用虚拟机，里面已经配置好相关的环境了。\n在~/.bashrc里增加export ROS_MASTER_URI=http://192.168.31.200:11311，让虚拟机使用小车作为服务端。之后就是编写程序注册服务，供主程序调用了，为了方便调用，我们自己编写了相应的数据结构。\n我们注册了Province.msg，存放识别到的快递盒上所需的数据。name代表省份名称，x和y分别是相对偏移量。\n1 2 3 string name float32 x float32 y 然后注册了ProvinceList.srv，作为我们服务的消息。\n1 2 --- Province[] provinces 由于使用了自定义消息类型，要注意修改CMakeLists.txt，将相应的文件添加进去，并注意引入message_generation，否则不会生成供Python调用的消息类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 cmake_minimum_required(VERSION 3.0.2) project(imgocr) ## Compile as C++11, supported in ROS Kinetic and newer # add_compile_options(-std=c++11) ## Find catkin macros and libraries ## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz) ## is used, also find other catkin packages find_package(catkin REQUIRED COMPONENTS rospy std_msgs sensor_msgs message_generation ) ## System dependencies are found with CMake\u0026#39;s conventions # find_package(Boost REQUIRED COMPONENTS system) ## Uncomment this if the package has a setup.py. This macro ensures ## modules and global scripts declared therein get installed ## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html # catkin_python_setup() ## Generate messages in the \u0026#39;msg\u0026#39; folder add_message_files( FILES Province.msg ) ## Generate services in the \u0026#39;srv\u0026#39; folder add_service_files( FILES ProvinceList.srv ) ## Generate added messages and services with any dependencies listed here generate_messages( DEPENDENCIES std_msgs sensor_msgs ) catkin_package( CATKIN_DEPENDS rospy std_msgs message_runtime ) include_directories( # include ${catkin_INCLUDE_DIRS} ) 同样，在package.xml里也要添加message_generation等依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;package format=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;name\u0026gt;imgocr\u0026lt;/name\u0026gt; \u0026lt;version\u0026gt;0.0.0\u0026lt;/version\u0026gt; \u0026lt;description\u0026gt;The imgocr package\u0026lt;/description\u0026gt; \u0026lt;maintainer email=\u0026#34;eaibot@todo.todo\u0026#34;\u0026gt;eaibot\u0026lt;/maintainer\u0026gt; \u0026lt;license\u0026gt;TODO\u0026lt;/license\u0026gt; \u0026lt;buildtool_depend\u0026gt;catkin\u0026lt;/buildtool_depend\u0026gt; \u0026lt;build_depend\u0026gt;rospy\u0026lt;/build_depend\u0026gt; \u0026lt;build_depend\u0026gt;std_msgs\u0026lt;/build_depend\u0026gt; \u0026lt;build_depend\u0026gt;message_generation\u0026lt;/build_depend\u0026gt; \u0026lt;build_export_depend\u0026gt;rospy\u0026lt;/build_export_depend\u0026gt; \u0026lt;build_export_depend\u0026gt;std_msgs\u0026lt;/build_export_depend\u0026gt; \u0026lt;exec_depend\u0026gt;rospy\u0026lt;/exec_depend\u0026gt; \u0026lt;exec_depend\u0026gt;std_msgs\u0026lt;/exec_depend\u0026gt; \u0026lt;exec_depend\u0026gt;message_runtime\u0026lt;/exec_depend\u0026gt; \u0026lt;export\u0026gt; \u0026lt;/export\u0026gt; \u0026lt;/package\u0026gt; 这样，就可以完成一个文字识别节点了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #!/usr/bin/env python # encoding: utf-8 from imp import reload import sys import rospy import cv2 from imgocr.srv import ProvinceList, ProvinceListResponse from imgocr.msg import Province from sensor_msgs.msg import CompressedImage from cv_bridge import CvBridge, CvBridgeError import time # 支持中文 reload(sys) sys.setdefaultencoding(\u0026#34;utf8\u0026#34;) def getImage(): \u0026#39;\u0026#39;\u0026#39;获取摄像头的图片\u0026#39;\u0026#39;\u0026#39; data = rospy.wait_for_message( \u0026#39;/usb_cam/image_correct/compressed\u0026#39;, CompressedImage, timeout=15.0) try: cv_image = CvBridge().compressed_imgmsg_to_cv2(data, \u0026#34;bgr8\u0026#34;) except CvBridgeError as e: rospy.logerr(e) cv_image = cv2.rotate(cv_image, cv2.ROTATE_180) cv_image = cv2.flip(cv_image, 1) return cv_image def doReq(req): rospy.loginfo(\u0026#34;开始执行文字识别\u0026#34;) start_time = time.time() img = getImage() pass rospy.loginfo(\u0026#34;识别用时：{}\u0026#34;.format(time.time()-start_time)) resp = ProvinceListResponse() for pro in ans: a = Province() a.name = pro[\u0026#34;province\u0026#34;] a.x = pro[\u0026#34;x\u0026#34;] a.y = pro[\u0026#34;y\u0026#34;] resp.provinces.append(a) return resp def main(): rospy.init_node(\u0026#34;imgocr\u0026#34;) server = rospy.Service(\u0026#34;imgocr/getProvince\u0026#34;, ProvinceList, doReq) rospy.loginfo(\u0026#34;节点初始化完成\u0026#34;) rospy.spin() if __name__ == \u0026#34;__main__\u0026#34;: main() 这里我们一开始获取摄像头的图片是采用/usb_cam/image_correct这个话题，但这个话题得到的图片是未压缩的，使用rostopic bw /usb_cam/image_correct可以看出大小差不多是好几M，这就会导致获取图像的时长远超文字识别时长，甚至是无法获取到图片。我们根据探索，发现/usb_cam/image_correct/compressed话题提供的是压缩后的图片，使用后获取图像的时长大大减小。\n使用分布式图像识别后，识别时长基本控制在2S内。\n由于我们是使用虚拟机，无法调用真机的显卡，如果有机会的话，可以尝试在真机上装相应的环境，使用GPU来进行图像识别，速度应该会更进一步。\n机械臂异常自动检测和清除 在上面一小节中，我们获取到省份的坐标就可以送至机械臂进行抓取了。但是，机械臂的抓取范围是有限的，一旦超出抓取范围机械臂就会停止执行直至执行清除警报。一种思路是我们首先是在一个固定的定去识别邮件，首先记录这个点的高度，然后我们需要降到桌面去吸取邮件，这是第二个高度，我们只需要测定这两个高度Z的前提下，Y的移动范围就可以了。1\n这种思路确实可行，但如果后期更换了机械臂高度，又要手动测量，十分麻烦。于是，我想了另一个思路，通过查询API文档，我找到了警报检测的API，那就好说了。在执行可能越界的指令后接上异常检测，如果异常就自动清除，这样就能自动化的判断了。\n话不多说，直接上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/usr/bin/env python # coding=utf-8 import rospy from dobot.srv import GetAlarmsState, ClearAllAlarmsState def getAlarmsState(): \u0026#39;\u0026#39;\u0026#39; 查询机械臂报警状态，并自动进行清除 return 是否存在报警 \u0026#39;\u0026#39;\u0026#39; rospy.wait_for_service(\u0026#39;DobotServer/GetAlarmsState\u0026#39;) rospy.wait_for_service(\u0026#39;DobotServer/ClearAllAlarmsState\u0026#39;) try: client = rospy.ServiceProxy( \u0026#39;DobotServer/GetAlarmsState\u0026#39;, GetAlarmsState) client2 = rospy.ServiceProxy( \u0026#39;DobotServer/ClearAllAlarmsState\u0026#39;, ClearAllAlarmsState) a = client() isError = False if a.alarmsState != \u0026#34;\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\u0026#34;: rospy.loginfo(\u0026#34;检测到警报，自动进行清除\u0026#34;) client2() isError = True return isError except rospy.ServiceException as e: rospy.logerr(\u0026#34;查询机械臂报警状态失败: %s\u0026#34; % e) ROS日志输出级别控制 在上面我提到过，我对代码美观有洁癖，那程序输出也自然不能放过。这个项目里所有的输出我都使用rospy.log来输出，这就带来一个问题，有些输出我将其设为DEBUG级别，而ROS默认的日志级别为INFO，导致这些信息根本看不到。每次想看时手动将代码换为INFO再换回去，虽然可行，但不优雅。于是我研究了一下ROS的日志方面的文档，发现是有方法来实现日志输出级别的控制的。\n在终端运行rqt_logger_level，之后选择你的程序节点中的rosout，在后面修改就可以修改ROS日志输出的级别了。\n时间有限，我就找到了这一个可行的方法，其余方法我测试后并没生效，如果有更好的方法欢迎在评论区留言。\n一些小工具 在写程序时，为了避免重复工作，还是做了一些小工具，本着“不要重复造轮子”的精神，在此一并开源了，希望能帮助到有需要的同学。\n随机快递箱顺序生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/usr/bin/env python # coding=utf-8 import random provinces = [] for i in range(3): provinces.append(\u0026#39;四川\u0026#39;) for i in range(2): provinces.append(\u0026#39;安徽\u0026#39;) for i in range(2): provinces.append(\u0026#39;湖南\u0026#39;) for i in range(3): provinces.append(\u0026#39;广东\u0026#39;) for i in range(3): provinces.append(\u0026#39;浙江\u0026#39;) for i in range(2): provinces.append(\u0026#39;江苏\u0026#39;) for i in range(3): provinces.append(\u0026#39;福建\u0026#39;) for i in range(2): provinces.append(\u0026#39;河南\u0026#39;) random.shuffle(provinces) for pro in provinces: print(pro) EAI资源点坐标格式转yaml格式 将官方QTEAIBotDemoPub(VER2)这个程序创建的导航目标点转成yaml格式，方便人修改及程序调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/env python # coding=utf-8 loacate = input(\u0026#34;file loacate:\u0026#34;) file = open(loacate, \u0026#34;r\u0026#34;) file_data = file.readlines() for row in file_data: tmp_list = row.split(\u0026#39;,\u0026#39;) print(tmp_list[0]+\u0026#34;:\u0026#34;) positions = tmp_list[2].split(\u0026#39;#\u0026#39;) print(\u0026#34; x: \u0026#34;+positions[0]) print(\u0026#34; y: \u0026#34;+positions[1]) orientations = tmp_list[3].split(\u0026#39;#\u0026#39;) print(\u0026#34; z: \u0026#34;+orientations[2]) print(\u0026#34; w: \u0026#34;+orientations[3]) 小结 这个项目到此也就完全结束了，回头看来，这个项目也是涉及了许多知识，诸如图像识别、自主定位等等，不过时间有限，基本都没怎么了解其中原理，只是调用了相关的接口，如果以后有空，可以继续研究研究😇。\n第五天：了解越疆dobot机械臂，使用python，编写通过ros服务控制机械臂运动程序_瓜洲大大的博客-CSDN博客_dobot机械臂\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n关于输入：Python从用户读取单个字符 | 码农家园\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-08-21T21:20:00+08:00","image":"https://lbqaq.top/p/roslogistic/97096454.webp","permalink":"https://lbqaq.top/p/roslogistic/","title":"我的智慧物流之旅"},{"content":"前言 阿里云最近发短信给我，提示我之前免费申请的SSL证书要到期了。借此机会，正好将acme.sh配置到服务器上，一劳永逸的解决证书问题。相较于在阿里云上申请证书，使用acme.sh的优势在于可以申请泛域名证书及可以自动续期。\n下面我就记录一下我使用的步骤吧。我这里采用的是使用阿里云的API自动进行DNS方式的申请，不同的服务商命令有稍许不同，可以参考官方文档。\n步骤 在阿里云控制台申请api https://ram.console.aliyun.com/users\n在阿里云的角色控制里赋予刚刚申请的用户控制DNS的权限AliyunDNSFullAccess https://ram.console.aliyun.com/permissions\n安装acme.sh\n1 curl https://get.acme.sh | sh -s email=my@example.com 配置API环境\n1 2 export Ali_Key=\u0026#34;xxxx\u0026#34; export Ali_Secret=\u0026#34;xxxxx\u0026#34; 这里是配置API环境，填入刚刚申请的密钥。这步只需要做一次，acme.sh会将其保存下来。\n生成证书，这里填入刚刚申请API得到的密钥\n1 acme.sh --issue --dns dns_ali -d lbqaq.top -d \u0026#34;*.lbqaq.top\u0026#34; 通过上面命令，可以申请到包含lbqaq.top和*.lbqaq.top这两个DNS记录的证书。这里如果有*，是需要加双引号的，我之前没加就报错了。\n复制证书到nginx目录\n1 2 3 4 acme.sh --install-cert -d lbqaq.top \\ --key-file /usr/local/nginx/conf/cert/lbqaq.top.key \\ --fullchain-file /usr/local/nginx/conf/cert/lbqaq.top.pem \\ --reloadcmd \u0026#34;nginx -s reload\u0026#34; 这里key-file对应的是Nginx配置里的ssl_certificate_key，fullchain-file对应的是ssl_certificate\n接下来修改Nginx配置文件即可\n附上我的模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #如果不是https就跳转至https if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } ssl_certificate ./cert/lbqaq.top.pem; ssl_certificate_key ./cert/lbqaq.top.key; ssl_session_timeout 5m; #表示使用的加密套件的类型。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的TLS协议的类型。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; add_header Strict-Transport-Security \u0026#34;max-age=31536000\u0026#34;; 常用命令 在附上一些我用到的一些acme.sh相关的命令。才不是水字数呢\nacme.sh --list查看已申请的证书 acme.sh --remove -d example.com删除指定的证书 ","date":"2022-07-21T19:05:52+08:00","image":"https://lbqaq.top/p/%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7ssl%E8%AF%81%E4%B9%A6/99528942.webp","permalink":"https://lbqaq.top/p/%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7ssl%E8%AF%81%E4%B9%A6/","title":"一步到位，自动申请SSL证书"},{"content":"云计算的三个特点 资源池化\n大部分云计算资源，都是池化了的资源。什么叫池化？池化就是物理资源的基础上，通过软件平台，封装成虚拟的计算资源，也就是我们常说的虚拟化。\n弹性伸缩\n云计算的计算资源，可以按需付费。你想要用多少，就租多少，想什么时候要就什么时候要，配置是支持自定义的。\n安全可靠\n而云计算，从物理角度来说，所有的计算资源都汇集在大型互联网数据中心（IDC），那里有严格的安保、抗震的建筑、安全的供电，有非常全面的容灾设计和应急方案，能够更好地保护计算资源，不会轻易地中断服务。\n从软件上来说，云计算服务提供商有更专业的技术团队，更成熟的技术储备，能够更好地保护计算资源不被入侵或破坏。\n云计算服务 应该不考，为了完备性还是放进来吧\nInfrastructure as a Service (IaaS)：基础设施即服务 Platform as a Service (PaaS) ：平台即服务 Software as a Service (SaaS) ：软件即服务 云计算类型 公有云 公有云通常指第三方提供商用户能够使使用的云，公有云一般可通过 Internet 使用，可能是免费或成本低廉的。公有云的最大意义是能够以低廉的价格，提供有吸引力的服务给最终用户，创造新的业务价值，公有云作为一个支撑平台，还能够整合上游的服务（如增值业务，广告）提供者和下游最终用户，打造新的价值链和生态系统。它使客户能够访问和共享基本的计算机基础设施，其中包括硬件、存储和带宽等资源。\n公有云是为大众建的，所有入驻用户都称租户，不仅同时有很多租户，而且一个租户离开，其资源可以马上释放给下一个租户。\n优点：\n成本低 方便 易扩展 缺点：\n安全顾虑 性能超卖问题 管理要复杂 私有云 是为一个客户单独使用而构建的，因而提供对数据、安全性和服务质量的最有效控制。该公司拥有基础设施，并可以控制在此基础设施上部署应用程序的方式。私有云可部署在企业数据中心的防火墙内(本地私有云)，也可以将它们部署在一个安全的主机托管场所（托管私有云）。\n优点：\n安全 自主可控 缺点：\n成本高 远程访问困难 社区云 社区云的核心特征是云端资源只给两个或者两个以上的特定单位组织内的员工使用，除此之外的人和机构都无权租赁和使用云端计算资源。与私有云类似，社区云的云端也有两种部署方法，即本地部署和托管部署。\n混合云 是两个或两个以上不同类型的云（私有云、社区云、公共云）服务的结合，这种结合可以是计算的、存储的，也可以两者兼而有之。\n优点：\n操作灵活 弹性 成本效益。混合云模式具有成本效益，因为企业可以根据需要决定使用成本更昂贵的云计算资源。 缺点：\n安全性不强 费用高。 公有云+私有云管理费用高昂 兼容性问题 RDD的创建 使用makeRDD即可，例如val rdd = sc.makeRDD(List(1, 2, 3, 4)) 。在使用makeRDD时我们也可以指定分区数量，如val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4), 3)，这里我们就创建了3个分区。\n当然，除了从程序中创建，我们也可以从文件中读取数据，使用sc.textFile(\u0026quot;input\u0026quot;)函数来按行读取文件里的数据。如val lineRDD: RDD[String] = sc.textFile(\u0026quot;E:\\\\datas\u0026quot;)\nValue类型转换算子 map def map[U: ClassTag](f: T =\u0026gt; U ): RDD[U]\n将处理的数据逐条进行映射转换，这里的转换可以是类型的转换，也可以是值的转换。\n1 2 3 4 5 6 7 8 9 10 val rdd = sc.makeRDD(List(1, 2, 3, 4)) def mapFunction(num: Int): Int = {num * 2} //转换函数 val mapRDD1: RDD[Int] = rdd.map(mapFunction) val mapRDD2 = rdd.map((num: Int) =\u0026gt; {num * 2}) //匿名函数 val mapRDD3 = rdd.map((num: Int) =\u0026gt; num * 2) //函数的代码逻辑只有一行的时候，{}可省略 val mapRDD4 = rdd.map((num) =\u0026gt; num * 2) //参数类型可以推断出来，参数类型可以省略 val mapRDD5 = rdd.map(num =\u0026gt; num * 2) //参数列表中的参数只有一个，()可以省略 val mapRDD6 = rdd.map(_ * 2) //参数在逻辑中只出现一次，且顺序出现，参数可用_代替 注意要认识最后的简写形式。\nmapPartiotions def mapPartitions[U: ClassTag]( f: Iterator[T] =\u0026gt; Iterator[U],preservesPartitioning: Boolean = false): RDD[U]\n以分区为单位进行数据转换操作，但是会将整个分区的数据加载到内存进行引用，由于存在对象的引用，因此处理完的数据不会被释放掉。\n1 2 3 4 5 6 7 8 val lineRdd = sc.makeRDD(List(1, 2, 3, 4),2) val rdd2: RDD[Int] = lineRdd.mapPartitions( iter =\u0026gt; { println(\u0026#34;+++++++++++++++\u0026#34;) iter.map(_ * 2) } ) rdd2.collect().foreach(println) 结果：\n1 2 3 4 5 6 +++++++++++++++ +++++++++++++++ 2 4 6 8 上面代码的意思是将每个数据乘以2，并在每次计算时输出+++++，从输出两条+++++可知，mapPartiotions算子确实是按分区进行操作。\nmap 和 mapPartitions 的区别？\nMap 算子是分区内一个数据一个数据的执行，类似于串行操作。而 mapPartitions 算子是以分区为单位进行批处理操作。 Map 算子主要目的将数据源中的数据进行转换和改变。但是不会减少或增多数据。MapPartitions 算子需要传入一个迭代器，返回一个迭代器，没有要求的元素的个数保持不变， 所以可以增加或减少数据。 Map 算子因为类似于串行操作，所以性能比较低，而是 mapPartitions 算子类似于批处理，所以性能较高。但是mapPartitions 算子会长时间占用内存，那么这样会导致内存可能不够用，出现内存溢出的错误。 mapPartitionWithIndex def mapPartitionsWithIndex[U: ClassTag]( f: (Int, Iterator[T]) =\u0026gt; Iterator[U] ,preservesPartitioning: Boolean = false): RDD[U]\n将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据，在处理时同时可以获取当前分区索引。\n1 2 3 4 5 6 7 8 9 10 11 val lineRdd = sc.makeRDD(List(1, 2, 3, 4), 2) val rdd2: RDD[Int] = lineRdd.mapPartitionsWithIndex( (index, iter) =\u0026gt; { if (index == 1) { iter } else { Nil.iterator //Nil是空List } } ) rdd2.collect().foreach(println) 结果：\n1 2 3 4 在上面的程序中，我们对第0个分区进行抛弃，对第1个分区进行保留。如所示，程序仅输出了第1分区里的内容。\nflatMap def flatMap[U: ClassTag](f: T =\u0026gt; TraversableOnce[U]): RDD[U]\n将处理的数据进行扁平化后再进行映射处理，所以算子也称之为扁平映射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 val lineRdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4, 5), 2) val groupRDD: RDD[(Int, Iterable[Int])] = lineRdd.groupBy(_ % 2) groupRDD.foreach(println) val rdd1: RDD[Int] = groupRDD.flatMap( _._2) println(\u0026#34;Iterable[Int]的flatMap：\u0026#34; + rdd1.collect().mkString(\u0026#34;,\u0026#34;)) val data2: RDD[List[Int]] = groupRDD.map(_._2.toList) val rdd2: RDD[Int] = data2.flatMap(t =\u0026gt; t) println(\u0026#34;List[Int]的flatMap：\u0026#34; + rdd2.collect().mkString(\u0026#34;,\u0026#34;)) val lineRdd2 = sc.makeRDD(List(List(1, 2), 3, List(4,5)),2) val rdd22: RDD[Any] = lineRdd2.flatMap { case list: List[_] =\u0026gt; list case num: Int =\u0026gt; List(num) } rdd22.collect().foreach(println) 结果：\n1 2 3 4 5 6 7 8 9 (0,CompactBuffer(2, 4)) (1,CompactBuffer(1, 3, 5)) Iterable[Int]的flatMap：2,4,1,3,5 List[Int]的flatMap：2,4,1,3,5 1 2 3 4 5 在第一段程序中，我们看出RDD[List]和RDD[iterable]都可以被flaMap算子进行扁平化。在第二段程序中，我们将将 List(List(1,2),3,List(4,5))进行扁平化操作。\n重新分区与数据筛选 coalesce def coalesce(numPartitions: Int, shuffle: Boolean = false, partitionCoalescer: Option[PartitionCoalescer] = Option.empty) (implicit ord: Ordering[T] = null): RDD[T]\n根据数据量缩减分区，用于大数据集过滤后，提高小数据集的执行效率。\n当 spark 程序中，存在过多的小任务的时候，可以通过 coalesce 方法，收缩合并分区，减少分区的个数，减小任务调度成本。\ncoalesce方法默认情况下不会将分区的数据打乱重新组合，只是将多个分区合并为1一个分区。\n1 2 3 4 5 val rdd = sc.makeRDD(List(1, 2, 3, 4, 5,6),3) val rdd2: RDD[Int] = rdd.coalesce(2) //1:1 2 //2:3 4 5 6 上面代码的含义是将3个分区缩减成2个，可见成功执行，一个分区里有2个数，而另一个分区里有4个数。\nrepartition def repartition(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T]\n该操作内部其实执行的是 coalesce 操作，参数 shuffle 的默认值为 true。无论是将分区数多的RDD 转换为分区数少的RDD，还是将分区数少的 RDD 转换为分区数多的RDD，repartition 操作都可以完成，因为无论如何都会经 shuffle 过程。\n1 2 3 4 5 val rdd = sc.makeRDD(List(1, 2, 3, 4, 5,6),3) val rdd2: RDD[Int] = rdd.repartition(2) //1:1 4 5 //2:2 3 6 由于参数 shuffle 的值为 true，将分区的数据打乱重新组合以保证不会出现数据倾斜\ndistinct def distinct()(implicit ord: Ordering[T] = null): RDD[T]\n将数据集中重复的数据去重\n1 2 3 4 5 val rdd = sc.makeRDD(List(1, 2, 3, 4, 1, 2, 3, 4)) val disRDD = rdd.distinct() disRDD.collect().foreach(println) //4 1 3 2 filter def filter(f: T =\u0026gt; Boolean): RDD[T]\n将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。当数据进行筛选过滤后，分区不变，但是分区内的数据可能不均衡\n1 2 3 4 5 val lineRdd = sc.makeRDD(List(1,2,3,4),2) val filterRDD: RDD[Int] = lineRdd.filter((num =\u0026gt; num % 2 == 0)) filterRDD.collect().foreach(println) //2 4 在上面的程序中，我们过滤掉所有的奇数，仅仅保留偶数\ngroupBy 将数据根据指定的规则进行分组, 分区默认不变，但是数据会被打乱重新组合，我们将这样的操作称之为shuffle。极限情况下，数据可能被分在同一个分区中。\n1 2 3 4 5 6 7 8 9 10 val lineRdd = sc.makeRDD(List(1, 2, 3, 4), 2) def groupFunction(num: Int): Int = { num % 2 } //val groupRDD: RDD[(Int, Iterable[Int])] = lineRdd.groupBy(_ % 2) val groupRDD: RDD[(Int, Iterable[Int])] = lineRdd.groupBy(groupFunction) groupRDD.collect().foreach(println) 结果：\n1 2 (0,CompactBuffer(2, 4)) (1,CompactBuffer(1, 3)) 在上面的代码中，按奇偶数进行分组\nsortBy def sortBy[K] ( f: (T) =\u0026gt; K, ascending: Boolean = true, numPartitions: Int = this.partitions.length) (implicit ord: Ordering[K], ctag: ClassTag[K]): RDD[T]\n该操作用于排序数据。在排序之前，可以将数据通过 f 函数进行处理，之后按照 f 函数处理的结果进行排序，默认为升序排列。排序后新产生的 RDD 的分区数与原RDD 的分区数一致。中间存在 shuffle 的过程\n1 2 3 4 5 6 7 val rdd = sc.makeRDD(List((\u0026#34;11\u0026#34;, 2), (\u0026#34;1\u0026#34;, 1), (\u0026#34;2\u0026#34;, 3)), 2) val sortRDD: RDD[(String, Int)] = rdd.sortBy(t =\u0026gt; t._1) sortRDD.collect().foreach(println) //(1,1) //(11,2) //(2,3) 上面是字符串排序，按字典序。下面转换成数字，注意两者区别\n1 2 3 4 5 6 7 val rdd = sc.makeRDD(List((\u0026#34;11\u0026#34;, 2), (\u0026#34;1\u0026#34;, 1), (\u0026#34;2\u0026#34;, 3)), 2) val sortRDD: RDD[(String, Int)] = rdd.sortBy(t =\u0026gt; t._1.toInt) sortRDD.collect().foreach(println) //(1,1) //(2,3) //(11,2) 集合类型算子操作 intersection def intersection(other: RDD[T]): RDD[T]\n对源RDD 和参数RDD 求交集后返回一个新的RDD\n1 2 3 4 5 6 val rdd1 = sc.makeRDD(List(1, 2, 3, 4, 5,6),3) val rdd2 = sc.makeRDD(List(1, 2, 3),1) val rdd3 = rdd1.intersection(rdd2) rdd3.collect().foreach(println) //3 1 2 union def union(other: RDD[T]): RDD[T]\n对源RDD 和参数RDD 求并集后返回一个新的RDD\n1 2 3 4 5 6 val rdd1 = sc.makeRDD(List(1, 2, 3)) val rdd2 = sc.makeRDD(List(4, 5, 6)) val rdd3 = rdd1.union(rdd2) rdd3.collect().foreach(println) //1 2 3 4 5 6 subtract def subtract(other: RDD[T]): RDD[T]\n以一个 RDD 元素为主，去除两个 RDD 中重复元素，将其他元素保留下来。求差集\n1 2 3 4 5 6 val rdd1 = sc.makeRDD(List(1, 2, 3, 4, 5, 6)) val rdd2 = sc.makeRDD(List(4, 5, 6)) val rdd3 = rdd1.subtract(rdd2) rdd3.collect().foreach(println) //1 2 3 zip def zip[U: ClassTag](other: RDD[U]): RDD[(T, U)]\n将两个 RDD 中的元素，以键值对的形式进行合并。其中，键值对中的Key 为第 1 个 RDD中的元素，Value 为第 2 个 RDD 中的相同位置的元素。\n1 2 3 4 5 val rdd1 = sc.makeRDD(List(1, 2, 3, 4), 2) val rdd2 = sc.makeRDD(List(3, 4, 5, 6), 2) val zipRDD: RDD[(Int, Int)] = rdd1.zip(rdd2) println(zipRDD.collect().mkString(\u0026#34;,\u0026#34;)) //(1,3),(2,4),(3,5),(4,6) 如果两个RDD 数据类型不一致 ，对于交集，并集，差集，两个RDD的数据类型必须相同。对于拉链操作，两个RDD的数据类型可以不同。 如果两个RDD的分区中数据量不一致，对于交集，并集，差集，两个RDD的分区中数据量不需要相同；对于拉链操作分区中数据量必须相同。 Key-Value类型算子 reduceByKey def reduceByKey(func: (V, V) =\u0026gt; V): RDD[(K, V)]\n可以将数据按照相同的Key 对Value 进行聚合，聚合操作是两两进行聚合的。reduceByKey中如果key的数据只有一个，是不会参与运算的。\n1 2 3 4 5 val rdd: RDD[(String)] = sc.makeRDD(List(\u0026#34;Hello Scala\u0026#34;, \u0026#34;Hello Spark\u0026#34;, \u0026#34;Hello Spark\u0026#34;, \u0026#34;Hello 123\u0026#34;),2) val wordRDD: RDD[String] = rdd.flatMap(_.split(\u0026#34; \u0026#34;)) val wordOneRDD: RDD[(String, Int)] = wordRDD.map((_, 1)) val result: RDD[(String, Int)] = wordOneRDD.reduceByKey(_ + _) result.collect().foreach(println) 结果：\n1 2 3 4 (Hello,4) (123,1) (Scala,1) (Spark,2) 在上面的代码中，根据参数_+_，即表示将两个value进行相加。\ngroupByKey def groupByKey(): RDD[(K, Iterable[V])]\n将数据源的数据根据 key， 对 value 进行分组，将数据源中相同key的数据分在一个组中，行成一个对偶元祖，元组中的第一个元素就是key，元组中的第二个元素就行相同key的value的集合。\n1 2 3 4 5 6 val rdd = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 1), (\u0026#34;b\u0026#34;, 1), (\u0026#34;b\u0026#34;, 1), (\u0026#34;b\u0026#34;, 1), (\u0026#34;a\u0026#34;, 1)), 2) val groupRDD: RDD[(String, Iterable[Int])] = rdd.groupByKey() groupRDD.collect().foreach(println) //(b,CompactBuffer(1, 1, 1, 1)) //(a,CompactBuffer(1, 1, 1, 1)) aggregateByKey def aggregateByKey[U: ClassTag](zeroValue: U)(seqOp: (U, V) =\u0026gt; U, combOp: (U, U) =\u0026gt; U): RDD[(K, U)]\n将数据根据不同的规则进行分区内计算和分区间计算。\naggregateByKey存在函数柯里化，有两个参数列表。\n第一个参数列表，需要传递一个参数，表示初始值。主要用于当碰见第一个key的时候，和value进行分区内计算。\n第二个参数列表需要传递两个参数\n参数2.1：分区内的计算规则 参数2.2：分区间的计算规则 1 2 3 4 5 6 7 8 9 10 11 val rdd = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 2), (\u0026#34;b\u0026#34;, 3), (\u0026#34;b\u0026#34;, 4), (\u0026#34;b\u0026#34;, 5), (\u0026#34;a\u0026#34;, 6)), 2) //同分区获取最大值，不同分区相加求和 val rdd2: RDD[(String, Int)] = rdd.aggregateByKey(0)( (x, y) =\u0026gt; math.max(x, y), (x, y) =\u0026gt; x + y ) rdd2.collect().foreach(println) //(b,8) //(a,8) foldByKey def foldByKey(zeroValue: V)(func: (V, V) =\u0026gt; V): RDD[(K, V)]\n当分区内计算规则和分区间计算规则相同时，aggregateByKey 就可以简化为foldByKey\n1 2 3 4 5 6 7 8 val rdd = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 2), (\u0026#34;b\u0026#34;, 3), (\u0026#34;b\u0026#34;, 4), (\u0026#34;b\u0026#34;, 5), (\u0026#34;a\u0026#34;, 6)), 2) //同分区相加求和，不同分区相加求和 val rdd2: RDD[(String, Int)] = rdd.foldByKey(0)(_ + _) rdd2.collect().foreach(println) //(b,12) //(a,9) combineByKey def combineByKey[C]( createCombiner: V =\u0026gt; C, mergeValue: (C, V) =\u0026gt; C, mergeCombiners: (C, C) =\u0026gt; C): RDD[(K, C)]\n对key-value 型 rdd 进行聚集操作的聚集函数（aggregation function）。类似于aggregate()，combineByKey()允许用户返回值的类型与输入不一致。\ncombineByKey方法需要三个参数\n第一个参数：表示将相同key的第一个数据进行结构的转换，实现操作 第二个参数：表示分区内的计算规则 第三个参数：表示分区间的计算规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 val rdd = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 2), (\u0026#34;b\u0026#34;, 3), (\u0026#34;b\u0026#34;, 4), (\u0026#34;b\u0026#34;, 5), (\u0026#34;a\u0026#34;, 6)), 2) val rdd2: RDD[(String, (Int, Int))] = rdd.combineByKey( (t) =\u0026gt; (t, 1), (t: (Int, Int), v) =\u0026gt; { (t._1 + v, t._2 + 1) }, (t1: (Int, Int), t2: (Int, Int)) =\u0026gt; { (t1._1 + t2._1, t1._2 + t2._2) } ) val rdd3: RDD[(String, Int)] = rdd2.map { case (str, (t1, t2)) =\u0026gt; { (str, t1 / t2) } } rdd3.collect().foreach(println) //(b,4) //(a,3) 在上面的例子中，首先将相同key的格式转为(t,1)，分区内计算对于第一个数据进行相加，第二个数据+1，分区间将第一和第二个数据对应相加。\njoin def join[W](other: RDD[(K, W)]): RDD[(K, (V, W))]\n在类型为(K,V)和(K,W)的RDD 上调用，返回一个相同 key 对应的所有元素连接在一起的(K,(V,W))的RDD\n两个RDD中的元素对进行笛卡尔乘积性质的匹配，但只会打印出匹配成功的。\n1 2 3 4 5 6 7 8 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;c\u0026#34;, 3)), 2) val rdd2 = sc.makeRDD(List((\u0026#34;b\u0026#34;, 5), (\u0026#34;a\u0026#34;, 4), (\u0026#34;c\u0026#34;, 6)), 2) var joinRDD: RDD[(String, (Int, Int))] = rdd1.join(rdd2) joinRDD.collect().foreach(println) //(b,(2,5)) //(a,(1,4)) //(c,(3,6)) 在上面的例子里，成功将a,b,c后面的值合在一起了\n如果两个数据源中有多个相同的key，那么数据源a中的key会与数据源b中相同的key多次匹配成功，因此会数据量会几何性质增长\n1 2 3 4 5 6 7 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;,1), (\u0026#34;b\u0026#34;, 2),(\u0026#34;c\u0026#34;, 3)),2) val rdd2 = sc.makeRDD(List((\u0026#34;b\u0026#34;, 5), (\u0026#34;d\u0026#34;,4), (\u0026#34;b\u0026#34;, 6)),2) var joinRDD: RDD[(String, (Int, Int))] = rdd1.join(rdd2) joinRDD.collect().foreach(println) //(b,(2,5)) //(b,(2,6)) leftOuterJoin def leftOuterJoin[W](other: RDD[(K, W)]): RDD[(K, (V, Option[W]))]\n类似于 SQL 语句的左外连接，根据左边第一个元素将两个RDD连接起来，和join算子类似，但这个可以支持key不匹配的情况。\n1 2 3 4 5 6 7 8 9 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;c\u0026#34;, 3)), 2) val rdd2 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 5), (\u0026#34;b\u0026#34;, 4)), 2) val leftJoinRDD: RDD[(String, (Int, Option[Int]))] = rdd1.leftOuterJoin(rdd2) leftJoinRDD.collect().foreach(println) //(b,(2,Some(4))) //(a,(1,Some(5))) //(c,(3,None)) 1 2 3 4 5 6 7 8 9 10 11 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;c\u0026#34;, 3)), 2) val rdd2 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 5), (\u0026#34;b\u0026#34;, 4), (\u0026#34;b\u0026#34;, 5), (\u0026#34;b\u0026#34;, 6)), 2) val leftJoinRDD: RDD[(String, (Int, Option[Int]))] = rdd1.leftOuterJoin(rdd2) leftJoinRDD.collect().foreach(println) //(b,(2,Some(4))) //(b,(2,Some(5))) //(b,(2,Some(6))) //(a,(1,Some(5))) //(c,(3,None)) rightOuterJoin 类似于左外连接，两者区别在于左连接是以左边的RDD为主，右连接以右边的RDD为主。\n1 2 3 4 5 6 7 8 9 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;,1), (\u0026#34;b\u0026#34;, 2)),2) val rdd2 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 5), (\u0026#34;b\u0026#34;,4),(\u0026#34;c\u0026#34;, 3)),2) val rightJoinRDD: RDD[(String, (Option[Int], Int))] = rdd1.rightOuterJoin(rdd2) rightJoinRDD.collect().foreach(println) //(b,(Some(2),4)) //(a,(Some(1),5)) //(c,(None,3)) 行动算子 reduce def reduce(f: (T, T) =\u0026gt; T): T\n聚集RDD 中的所有元素，先聚合分区内数据，再聚合分区间数据\n1 2 3 4 5 val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4)) // 聚合数据 val reduceResult: Int = rdd.reduce(_+_) println(reduceResult) //10 在上面的例子中，10=1+2+3+4\ncollect def collect(): Array[T]\n在驱动程序中，方法会将不同分区的数据按照分区顺序采集到Driver端内存中，形成数组。\n1 2 3 4 5 val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4), 2) //收集数据到Driver rdd.collect().foreach(println) //1 2 3 4 first def first(): T\n返回RDD 中的第一个元素\n1 2 3 4 val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4)) val firstResult: Int = rdd.first() println(firstResult) //1 take def take(num: Int): Array[T]\n返回一个由RDD 的前 n 个元素组成的数组\n1 2 3 4 5 val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4)) val takeResult: Array[Int] = rdd.take(2) println(takeResult.mkString(\u0026#34;,\u0026#34;)) //1,2 takeOrdered def takeOrdered(num: Int)(implicit ord: Ordering[T]): Array[T]\n返回该 RDD 排序后的前 n 个元素组成的数组\n1 2 3 4 val rdd: RDD[Int] = sc.makeRDD(List(1, 3, 2, 4)) val result: Array[Int] = rdd.takeOrdered(2) result.foreach(println) //1 2 aggregate def aggregate[U: ClassTag](zeroValue: U)(seqOp: (U, T) =\u0026gt; U, combOp: (U, U) =\u0026gt; U): U\n分区的数据通过初始值和分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合；即，初始值不仅参与分区内计算，同时也参与分区间计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4), 8) /* * 组内： * 初值10,分区1(1)，组内结果11 * 初值10,分区2(2)，组内结果12 * 初值10,分区3(3)，组内结果13 * 初值10,分区4(4)，组内结果14 * 初值10,分区5(0)，组内结果10 * 初值10,分区6(0)，组内结果10 * 初值10,分区7(0)，组内结果10 * 初值10,分区8(0)，组内结果10 * * 组间： * 初值10,分区(11,12,13,14,10,10,10,10)，结果100 */ val result: Int = rdd.aggregate(10)(_ + _, _ + _) println(result) //100 fold def fold(zeroValue: T)(op: (T, T) =\u0026gt; T): T\n折叠操作，aggregate的简化版操作\n1 2 3 4 val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4)) val foldResult: Int = rdd.fold(0)(_ + _) println(foldResult) //10 countByKey def countByKey(): Map[K, Long]\n统计每种 key 的个数\n1 2 3 4 5 val rdd: RDD[(Int, String)] = sc.makeRDD(List((1, \u0026#34;a\u0026#34;), (1, \u0026#34;a\u0026#34;), (1, \u0026#34;a\u0026#34;), (2, \u0026#34;b\u0026#34;), (3, \u0026#34;c\u0026#34;), (3, \u0026#34;c\u0026#34;))) // 统计每种 key 的个数 val result: collection.Map[Int, Long] = rdd.countByKey() println(result) //Map(1 -\u0026gt; 3, 2 -\u0026gt; 1, 3 -\u0026gt; 2) RDD 依赖关系 窄依赖 窄依赖表示每一个父(上游)RDD 的 Partition 最多被子（下游）RDD 的一个 Partition 使用， 窄依赖我们形象的比喻为独生子女。\n宽依赖 宽依赖表示同一个父（上游）RDD 的 Partition 被多个子（下游）RDD 的 Partition 依赖，会引起 Shuffle，总结：宽依赖我们形象的比喻为多生。\nWordCount 典中典程序，必考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import org.apache.spark.rdd.RDD import org.apache.spark.{SparkConf, SparkContext} object WordCount { def main(args: Array[String]): Unit = { val sparkConf = new SparkConf().setMaster(\u0026#34;local\u0026#34;).setAppName(\u0026#34;WordCount\u0026#34;); val sc = new SparkContext(sparkConf) val rdd: RDD[String] = sc.textFile(\u0026#34;spark-core/src/main/resources/words\u0026#34;) val wordRDD: RDD[String] = rdd.flatMap(_.split(\u0026#34; \u0026#34;)) val wordOneRDD: RDD[(String, Int)] = wordRDD.map((_, 1)) val result: RDD[(String, Int)] = wordOneRDD.reduceByKey(_ + _) result.collect().foreach(println) //关闭连接 sc.stop(); } } 有向无环图 DAG(Directed Acyclic Graph)叫做有向无环图，原始的RDD通过一系列的转换就形成了DAG。\nstage的划分 一个Job会被拆分为多组Task，每组任务被称为一个stage。stage表示不同的调度阶段，一个spark job会对应产生很多个stage。\n根据RDD之间依赖关系的不同将DAG划分成不同的Stage(调度阶段)\n对于窄依赖，partition的转换处理在一个Stage中完成计算 对于宽依赖，由于有Shuffle的存在，只能在parent RDD处理完成后，才能开始接下来的计算 划分stage的依据就是宽依赖\n首先根据rdd的算子操作顺序生成DAG有向无环图，接下里从最后一个rdd往前推，创建一个新的stage，把该rdd加入到该stage中，它是最后一个stage。 在往前推的过程中运行遇到了窄依赖就把该rdd加入到本stage中，如果遇到了宽依赖，就从宽依赖切开，那么最后一个stage也就结束了。 重新创建一个新的stage，按照第二个步骤继续往前推，一直到最开始的rdd，整个划分stage也就结束了 划分完stage之后，每一个stage中有很多可以并行运行的task，后期把每一个stage中的task封装在一个taskSet集合中，最后把一个一个的taskSet集合提交到worker节点上的executor进程中运行。\nrdd与rdd之间存在依赖关系，stage与stage之前也存在依赖关系，前面stage中的task先运行，运行完成了再运行后面stage中的task，也就是说后面stage中的task输入数据是前面stage中task的输出结果数据。\n缓存和检查点区别 必考，也是非常重要\nCache 缓存只是将数据临时保存起来。Cache 缓存的数据通常存储在内存，可靠性低。不切断血缘依赖，只会在血缘关系中添加新的依赖，一旦出现问题，可以重头读取数据。 persisit：将数据临时存储在磁盘文件中进行数据重用，涉及到磁盘IO，性能较低，但是数据安全。如果作业执行完毕，临时保存的数据文件就会丢失。 CheckPoint：将数据长久地保存在磁盘文件中进行数据重用，涉及到磁盘IO，性能较低，但是数据安全。为了包装数据安全，所以一般情况下，会独立执行作业，就是把当前需要持久化的RDD重新创建并保存。为了能够提高效率，通常和cache联合使用。 Checkpoint 检查点会切断血缘依赖，重新建立新的血缘关系。 cache 机制是每计算出一个要 cache 的 partition 就直接将其 cache 到内存了。但 checkpoint 没有使用这种第一次计算得到就存储的方法，而是等到 job 结束后另外启动专门的 job 去完成 checkpoint 。 也就是说需要 checkpoint 的 RDD 会被计算两次。因此，在使用checkpoint() 的时候，建议加上 rdd.cache()， 这样第二次运行的 job 就不用再去计算该 rdd 了，直接读取 cache 写磁盘。建议对checkpoint()的RDD 使用Cache 缓存，这样 checkpoint 的 job 只需从 Cache 缓存中读取数据即可，否则需要再从头计算一次RDD。Checkpoint 检查点切断血缘依赖。 combineByKey和aggregateByKey的异同 相同点 都有三个参数 第二个和第三个参数都是分区内操作和分区间操作 都属于聚合操作，使数据量减少 都是转换算子，不触发程序执行 不同点 对于第一个参数，aggregateByKey是设置初始值，combineByKey是进行转换 combineByKey组内计算和组间计算数据格式不一样； aggregateByKey组内计算和组间计算数据格式一样 aggregate和aggregateByKey的异同 相同点 都是具有分区内操作和分区间操作 都是聚合类型的算子 不同点 aggregateByKey的初始值不会参与分区间计算；对key进行操作，需要键值对 aggregate的初始值会参与分区间计算，会触发程序运行，进行读数据 求平均值 典中典程序，这也是必考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import org.apache.spark.rdd.RDD import org.apache.spark.{SparkConf, SparkContext} object exam { def main(args: Array[String]): Unit = { val sparkConf = new SparkConf().setMaster(\u0026#34;local\u0026#34;).setAppName(\u0026#34;exam\u0026#34;); val sc = new SparkContext(sparkConf) val lineRdd: RDD[(String, Int)] = sc.makeRDD(List((\u0026#34;Spark\u0026#34;, 5), (\u0026#34;Hadoop\u0026#34;, 3), (\u0026#34;Scala\u0026#34;, 4), (\u0026#34;Spark\u0026#34;, 3), (\u0026#34;Hadoop\u0026#34;, 1))) val rdd1: RDD[(String, (Int, Int))] = lineRdd.map(t =\u0026gt; (t._1, (t._2, 1))) val rdd2: RDD[(String, (Int, Int))] = rdd1.reduceByKey((t, k) =\u0026gt; ((t._1 + k._1), (t._2 + k._2))) val rdd3: RDD[(String, Int)] = rdd2.map( t =\u0026gt; (t._1, t._2._1 / t._2._2) ) rdd3.collect().foreach(println) sc.stop() } } 算子补充 glom def glom(): RDD[Array[T]]\n将同一个分区的数据直接转换为一个相同类型的内存数组进行处理，分区不变\n1 2 3 4 5 val lineRdd = sc.makeRDD(List(1, 2, 3, 4),2) val glomRDD: RDD[Array[Int]] = lineRdd.glom() glomRDD.collect().foreach(data =\u0026gt; println(data.mkString(\u0026#34;,\u0026#34;))) //1,2 //3,4 sample def sample( withReplacement: Boolean, fraction: Double, seed: Long = Utils.random.nextLong): RDD[T]\n根据指定的规则从数据集中抽取数据\n第1个参数withReplacement表示：抽取后是否将数据返回，true（放回），false（丢弃） 第2个参数fraction表示： 当第一参数为true，第二个参数表示：抽取不放回的概率；基准值的概念（每个数有一个0~1随机值，用随即值与基准值进行比较）； 当第一个参数为false，第二个参数表示，可能抽取的次数。 第3个参数seed表示：抽取数据时，随机算法的种子；如果不传第三个参数，那么使用的当前系统时间 1 2 3 4 5 6 7 8 9 10 11 12 13 val dataRDD = sparkContext.makeRDD(List( 1,2,3,4),1) // 抽取数据不放回（伯努利算法） // 伯努利算法：又叫 0、1 分布。例如扔硬币，要么正面，要么反面。 // 具体实现：根据种子和随机算法算出一个数和第二个参数设置几率比较，小于第二个参数要，大于不要 // 第一个参数：抽取的数据是否放回，false：不放回 // 第二个参数：抽取的几率，范围在[0,1]之间,0：全不取；1：全取； // 第三个参数：随机数种子 val dataRDD1 = dataRDD.sample(false, 0.5) // 抽取数据放回（泊松算法） // 第一个参数：抽取的数据是否放回，true：放回；false：不放回 // 第二个参数：重复数据的几率，范围大于等于 0.表示每一个元素被期望抽取到的次数 // 第三个参数：随机数种子 val dataRDD2 = dataRDD.sample(true, 2) partitionBy def partitionBy(partitioner: Partitioner): RDD[(K, V)]\n将数据按照指定的Partitioner规则 重新进行重新分区。Spark 默认的分区器是HashPartitioner\n太冷门了，应该不考，就不放代码了\ncogroup def cogroup[W](other: RDD[(K, W)]): RDD[(K, (Iterable[V], Iterable[W]))]\n在类型为(K,V)和(K,W)的RDD 上调用，返回一个(K,(Iterable\u0026lt;V\u0026gt;,Iterable\u0026lt;W\u0026gt;))类型的 RDD\n1 2 3 4 5 6 7 8 9 10 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;,1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;x\u0026#34;, 44)),2) val rdd2 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 5), (\u0026#34;b\u0026#34;,4),(\u0026#34;c\u0026#34;, 3), (\u0026#34;c\u0026#34;, 99)),2) val cgRDD: RDD[(String, (Iterable[Int], Iterable[Int]))] = rdd1.cogroup(rdd2) cgRDD.collect().foreach(println) //(x,(CompactBuffer(44),CompactBuffer())) //(b,(CompactBuffer(2),CompactBuffer(4))) //(a,(CompactBuffer(1),CompactBuffer(5))) //(c,(CompactBuffer(),CompactBuffer(3, 99))) 下面都是行动算子\ncount def count(): Long\n返回RDD 中元素的个数\nsaveAsTextFile def saveAsTextFile(path: String): Unit\n保存成 Text 文件\n1 rdd.saveAsTextFile(\u0026#34;output\u0026#34;) ","date":"2022-06-08T09:33:43+08:00","image":"https://lbqaq.top/p/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/97475626.webp","permalink":"https://lbqaq.top/p/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"云计算学习笔记"},{"content":"卷积神经网络(CNN) CNN的基本架构 一个典型的卷积网络是由卷积层、 汇聚层、 全连接层交叉堆叠而成。\n一个卷积块为连续 𝑀 个卷积层和 𝑏 个汇聚层（ 𝑀 通常设置为2 ∼ 5，𝑏为0或1）。 一个卷积网络中可以堆叠𝑁 个连续的卷积块， 然后在后面接着 𝐾 个全连接层（ 𝑁 的取值区间比较大， 比如 1 ∼ 100 或者更大；𝐾 一般为0 ∼ 2）。\n上面这张图里的汇聚层也就是下面图中的池化层\n输入层。在上图中就是最左边的船的图像，计算机理解为输入若干个矩阵。 卷积层(Convolution Layer)。卷积层的激活函数使用的是ReLU，$ReLU(x) = max(0,x)$。 池化层(Pooling layer)。池化层没有激活函数。 卷积层+池化层的组合可以在隐藏层出现很多次，上图中出现两次。这里卷积层+池化层可随意组合，如卷积层+卷积层，或者卷积层+卷积层+池化层。不过我们一般都是若干卷积层+池化层的组合。\n全连接层(Fully Connected Layer, 简称FC)，输出层使用了Softmax激活函数来做图像识别的分 为了统一起见，我们下面对于Pooling layer的中文翻译都为汇聚层。\n卷积 对于一维卷积，我们假设滤波器长度为$K$， 它和一个信号序列$x_1,x_2,\u0026hellip;$的卷积为：\n$$ y_t=\\sum_{k=1}^{K}w_kx_{t-k+1} $$为了简单起见， 这里假设卷积的输出$y_t$ 的下标$t$从$k$开始\n信号序列$x$和滤波器$w$（也叫卷积核）的卷积定义为：\n$$ y=w*x $$其中$*$表示卷积运算。\n对于二维矩阵，给定图像$X(M\\times N)$，滤波器$W(U \\times V)$我们定义：\n$$ y_{ij}=\\sum_{u=1}^{U}\\sum_{v=1}^{V} w_{uv}x_{i-u+1,j-v+1} $$光看公式还是比较抽象的，还是要举个例子：\n图中的输入是一个二维的3x4的矩阵，而卷积核是一个2x2的矩阵。这里我们假设卷积是一次移动一个像素来卷积的，那么首先我们对输入的左上角2x2局部和卷积核卷积，即各个位置的元素相乘再相加，得到的输出矩阵S的$S_{00}$的元素，值为$aw+bx+ey+fz$。接着我们将输入的局部向右平移一个像素，现在是(b,c,f,g)四个元素构成的矩阵和卷积核来卷积，这样我们得到了输出矩阵S的$S_{01}$的元素，同样的方法，我们可以得到输出矩阵S的$S_{02}，S_{10}，S_{11}， S_{12}$的元素。\n最终我们得到卷积输出的矩阵为一个2x3的矩阵S。\n如果这个例子还是不直观，可以看下面这个动图：\n可是，考试时可不仅仅会考二维的矩阵，还会考三维矩阵。\n在介绍三维矩阵之前，我们先引入两个概念：\n步长(Stride)：指卷积核在滑动时的时间间隔。说人话就是矩阵每次右移的长度，比如下面要说的例子中步长为2就右移2个像素。 零填充(Zero Padding)：是在输入向量两端进行补零。比如下面要说的例子pad=1，就在矩阵周围填一圈0 在斯坦福大学的cs231n的课程上，有一个动态的例子，我们就看这个例子。\nConvolution demo\n可以看出来，对于三维的矩阵，我们是将其拆成3个二维的矩阵，然后对应的将输入$X$和卷积核$W$进行卷积运算。\n汇聚层 其作用是进行特征选择，降低特征数量， 从而减少参数数量。说人话就是输入张量的各个子矩阵进行压缩。假如是2x2的汇聚，那么就将子矩阵的每2x2个元素变成一个元素，如果是3x3的汇聚，那么就将子矩阵的每3x3个元素变成一个元素，这样输入矩阵的维度就变小了。\n要想将输入子矩阵的每nxn个元素变成一个元素，那么需要一个汇聚标准。常见的汇聚标准有2个，MAX或者是MEAN。即取对应区域的最大值或者平均值作为汇聚后的元素值。\n下面这个例子采用取最大值的汇聚方法。同时采用的是2x2的汇聚。步幅为2。\n首先对红色2x2区域进行汇聚，由于此2x2区域的最大值为6。那么对应的汇聚输出位置的值为6，由于步幅为2，此时移动到绿色的位置去进行汇聚，输出的最大值为8。同样的方法，可以得到黄色区域和蓝色区域的输出值。最终，我们的输入4x4的矩阵在汇聚后变成了2x2的矩阵，进行了压缩。\n例题 有了上面这些内容的铺垫，我们就会惊喜的发现，下面这道题可以轻松的完成了\n循环神经网络(RNN) 在前面讲到的DNN和CNN中，训练样本的输入和输出是比较的确定的。但是有一类问题DNN和CNN不好解决，就是训练样本输入是连续的序列,且序列的长短不一，比如基于时间的序列：一段段连续的语音，一段段连续的手写文字。这些序列比较长，且长度不一，比较难直接的拆分成一个个独立的样本来通过DNN/CNN进行训练。\n这时就需要RNN了。RNN是一类具有短期记忆能力的神经网络，RNN的模型如下：\n单一神经元的RNN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SingleLayerRNN(nn.Module): def __init__(self, inputSize, hiddenSize): super(SingleLayerRNN, self).__init__() # inputSize x hiddenSize : 4 x 1 self.Wx = torch.randn(inputSize, hiddenSize) # hiddenSize x hiddenSize : 1 x 1 self.Wy = torch.randn(hiddenSize, hiddenSize) self.b = torch.zeros(1, hiddenSize) # 1 xhiddenSize : 1 x 4 def forward(self, X0, X1): # batchSize x hiddenSize : 1 x 4 self.Y0 = torch.tanh(torch.mm(X0, self.Wx) + self.b) # batchSize x hiddenSize : 1 X 4 self.Y1 = torch.tanh(torch.mm(X1, self.Wx) + self.b + torch.mm(self.Y0, self.Wy)) return self.Y0, self.Y1 INPUT_SIZE = 4 HIDDEN_SIZE = 1 # t=0 =\u0026gt; batchSize x inputSize : 4 x 4 X0_batch = torch.tensor([[0, 1, 2, 0], [3, 4, 5, 0], [6, 7, 8, 0], [9, 0, 1, 0]], dtype=torch.float) # t=1 =\u0026gt; batchSize x inputSize : 4 x 4 X1_batch = torch.tensor([[9, 8, 7, 0], [0, 0, 0, 0], [6, 5, 4, 0], [3, 2, 1, 0]], dtype=torch.float) model = SingleLayerRNN(INPUT_SIZE, HIDDEN_SIZE) Y0_batch, Y1_batch = model(X0_batch, X1_batch) print(Y0_batch) print(Y1_batch) 使用RNN进行MNIST训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 import torch import torch.nn as nn import torchvision import torchvision.transforms as transforms import matplotlib.pyplot as plt import numpy as np import torch.optim as optim import os os.environ[\u0026#34;KMP_DUPLICATE_LIB_OK\u0026#34;]=\u0026#34;TRUE\u0026#34; BATCH_SIZE = 64 DOWNLOAD_DATASET = False # list all transformations transform = transforms.Compose([ transforms.Resize((28, 28)), transforms.ToTensor(), ]) # download and load training dataset trainDataset = torchvision.datasets.MNIST(root=\u0026#39;./MNIST/\u0026#39;, train=True, download=DOWNLOAD_DATASET, transform=transform) trainLoader = torch.utils.data.DataLoader(trainDataset, batch_size=BATCH_SIZE, shuffle=True) # download and load testing dataset testDataset = torchvision.datasets.MNIST(root=\u0026#39;./MNIST/\u0026#39;, train=False, download=DOWNLOAD_DATASET, transform=transform) testLoader = torch.utils.data.DataLoader(testDataset, batch_size=BATCH_SIZE, shuffle=False) # functions to show an image def imshow(img): # img = img / 2 + 0.5 # unnormalize npimg = img.numpy() plt.imshow(np.transpose(npimg, (1, 2, 0))) # get some random training images dataIter = iter(trainLoader) images, labels = dataIter.next() # show images imshow(torchvision.utils.make_grid(images)) # parameters INPUT_SIZE = 28 HIDDEN_SIZE = 150 OUTPUT_SIZE = 10 TIME_STEP = 28 MAX_EPOCH = 10 class ImageRNN(nn.Module): def __init__(self, batchSize, timeStep, inputSize, hiddenSize, outputSize): super(ImageRNN, self).__init__() self.hiddenSize = hiddenSize self.batchSize = batchSize self.timeStep = timeStep self.inputSize = inputSize self.outputSize = outputSize self.RNN = nn.RNN(self.inputSize, self.hiddenSize) self.fc = nn.Linear(self.hiddenSize, self.outputSize) def initializeHidden(self, ): # (num_layers, batch_size, hidden_size) return torch.zeros(1, self.batchSize, self.hiddenSize) def forward(self, X): # transforms X to dimensions: timeStep x batchSize x inputSize X = X.permute(1, 0, 2) self.batchSize = X.size(1) self.hidden = self.initializeHidden() # rnnOutput =\u0026gt; timeStep, batchSize, hiddenSize (hidden states for each time step) # self.hidden =\u0026gt; 1, batchSize, hiddenSize (final state from each rnnOutput) rnnOutput, self.hidden = self.RNN(X, self.hidden) out = self.fc(self.hidden) return out.view(-1, self.outputSize) # batchSize x outputSize dataIter = iter(trainLoader) images, labels = dataIter.next() model = ImageRNN(BATCH_SIZE, TIME_STEP, INPUT_SIZE, HIDDEN_SIZE, OUTPUT_SIZE) ypred = model(images.view(-1, 28, 28)) print(ypred[0:10]) # Device device = torch.device(\u0026#34;cuda:0\u0026#34; if torch.cuda.is_available() else \u0026#34;cpu\u0026#34;) # Model instance model = ImageRNN(BATCH_SIZE, TIME_STEP, INPUT_SIZE, HIDDEN_SIZE, OUTPUT_SIZE) criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=0.001) def computeAccuracy(output, target): \u0026#39;\u0026#39;\u0026#39; Obtain accuracy for training round \u0026#39;\u0026#39;\u0026#39; corrects = (torch.max(output, 1)[1].view(target.size()).data == target.data).sum() accuracy = 100.0 * corrects / torch.numel(target) return accuracy.item() for epoch in range(MAX_EPOCH): # loop over the dataset multiple times trainLoss = 0.0 trainAccuracy = 0.0 model.train() # TRAINING ROUND for i, data in enumerate(trainLoader): # reset hidden states model.hidden = model.initializeHidden() # get the inputs inputs, labels = data inputs = inputs.view(-1, 28, 28) # forward ypred = model(inputs) loss = criterion(ypred, labels) # backward + optimize optimizer.zero_grad() loss.backward() optimizer.step() trainLoss += loss.detach().item() trainAccuracy += computeAccuracy(ypred, labels) model.eval() print(\u0026#39;Epoch: {:2d} | Loss: {:8.4f} | Train Accuracy: {:5.2f}\u0026#39;.format(epoch, trainLoss / i, trainAccuracy / i)) model.eval() testAccuracy = 0.0 for i, (images, labels) in enumerate(testLoader, 0): images = images.to(device) labels = labels.to(device) outputs = model(images.view(-1, 28, 28)) testAccuracy += computeAccuracy(outputs, labels) print(\u0026#39;Test Accuracy: {:6.2f}\u0026#39;.format(testAccuracy / len(testLoader))) 参考资料 卷积神经网络(CNN)模型结构 - 刘建平Pinard - 博客园 神经网络与深度学习 ","date":"2022-05-20T13:18:58+08:00","image":"https://lbqaq.top/p/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/98259515.webp","permalink":"https://lbqaq.top/p/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"特征工程学习笔记"},{"content":"线性回归 线性回归遇到的问题一般是这样的。我们有m个样本，每个样本对应于n维特征和一个结果输出，如下：\n$$ (x_1^{(0)}, x_2^{(0)}, ...x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, ...x_n^{(1)},y_1), ... (x_1^{(m)}, x_2^{(m)}, ...x_n^{(m)}, y_m) $$我们的问题是，对于一个新的$(x_1^{(x)}, x_2^{(x)}, \u0026hellip;x_n^{(x)})$, 他所对应的$y_x$是多少呢？ 如果这个问题里面的y是连续的，则是一个回归问题，否则是一个分类问题。\n对于n维特征的样本数据，如果我们决定使用线性回归，那么对应的模型是这样的：\n$h_\\theta(x_1, x_2, \u0026hellip;x_n) = \\theta_0 + \\theta_{1}x_1 + \u0026hellip; + \\theta_{n}x_{n}$, 其中$\\theta_i$ (i = 0,1,2\u0026hellip; n)为模型参数，$x_i$ (i = 0,1,2\u0026hellip; n)为每个样本的n个特征值。这个表示可以简化，我们增加一个特征$x_0 = 1$，这样$h_\\theta(x_0, x_1, \u0026hellip;x_n) = \\sum\\limits_{i=0}^{n}\\theta_{i}x_{i}$。\n💡 均方误差(MSE)\n$$ \u003e MSE=\\frac{1}{n}\\sum_{i=1}^{m}w_i(y_i-\\widehat{y_i})^2 \u003e $$ 其中$y_i$是真实数据，$\\widehat{y_i}$是拟合的数据，$w_i\u0026gt;0$\n得到了模型，我们需要求出需要的损失函数，一般线性回归我们用 均方误差(MSE) 作为损失函数。损失函数的代数法表示如下：\n$$ J(\\theta_0, \\theta_1..., \\theta_n) = \\sum\\limits_{i=1}^{m}(h_\\theta(x_0^{(i)}, x_1^{(i)}, ...x_n^{(i)}) - y_i)^2 $$由于矩阵形式不好理解，这里就不列出了。\n如何求损失函数最小化时候的$\\mathbf{\\theta}$参数，这时就需要使用梯度下降法了。\n梯度下降法 梯度 在微积分里面，对多元函数的参数求∂偏导数，把求得的各个参数的偏导数以向量的形式写出来，就是梯度。那么这个梯度向量求出来有什么意义呢？他的意义从几何意义上讲，就是函数变化增加最快的地方。\n梯度下降的直观解释 首先来看看梯度下降的一个直观的解释。比如我们在一座大山上的某处位置，由于我们不知道怎么下山，于是决定走一步算一步，也就是在每走到一个位置的时候，求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。这样一步步的走下去，一直走到觉得我们已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山峰低处。\n从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。\n梯度下降法的代数方式描述 在上面的内容中，我们知道了线性回归的函数为：\n$$ h_\\theta(x_0, x_1, ...x_n) = \\sum\\limits_{i=0}^{n}\\theta_{i}x_{i} $$损失函数为：\n$$ J(\\theta_0, \\theta_1..., \\theta_n) = \\sum\\limits_{i=1}^{m}(h_\\theta(x_0^{(i)}, x_1^{(i)}, ...x_n^{(i)}) - y_i)^2 $$算法相关参数初始化：主要是初始化$\\theta_0, \\theta_1\u0026hellip;, \\theta_n$ ,算法终止距离$\\varepsilon$ 以及步长$\\alpha$ 。在没有任何先验知识的时候，我喜欢将所有的$\\theta$ 初始化为0， 将步长初始化为1，在调优的时候再优化。\n算法过程：\n确定当前位置的损失函数的梯度，对于$\\theta_i$ ,其梯度表达式如下：\n$$ \\frac{\\partial}{\\partial\\theta_i}J(\\theta_0, \\theta_1..., \\theta_n)= \\frac{1}{m}\\sum\\limits_{j=0}^{m}(h_\\theta(x_0^{(j)}, x_1^{(j)}, ...x_n^{(j)}) - y_j)x_i^{(j)} $$ 用步长乘以损失函数的梯度，得到当前位置下降的距离，即 $\\alpha\\frac{\\partial}{\\partial\\theta_i}J(\\theta_0, \\theta_1\u0026hellip;, \\theta_n)$ 对应于前面登山例子中的某一步。\n确定是否所有的 $\\theta_i$ ,梯度下降的距离都小于 $\\varepsilon$ ，如果小于 $\\varepsilon$ 则算法终止，当前所有的 $\\theta_i$ (i=0,1,\u0026hellip;n)即为最终结果。否则进入步骤4.\n更新所有的$\\theta$ ，对于 $\\theta_i$ ，其更新表达式如下。更新完毕后继续转入步骤1.\n$$ \\theta_i = \\theta_i - \\alpha\\frac{\\partial}{\\partial\\theta_i}J(\\theta_0, \\theta_1..., \\theta_n) = \\theta_i - \\alpha (h_\\theta(x_0^{(j)}, x_1^{(j)}, ...x_n^{(j)}) - y_j)x_i^{(j)} $$ 从这个例子可以看出当前点的梯度方向是由所有的样本决定的，加 $\\frac{1}{m}$ 是为了好理解。由于步长也为常数，他们的乘机也为常数，所以这里 $\\alpha\\frac{1}{m}$ 可以用一个常数表示。\n在下面第4节会详细讲到的梯度下降法的变种，他们主要的区别就是对样本的采用方法不同。这里我们采用的是用所有样本。\n随机梯度下降法(SGD) 随机梯度下降法，其实和批量梯度下降法原理类似，区别在与求梯度时没有用所有的m个样本的数据，而是仅仅选取一个样本j来求梯度。对应的更新公式是\n$$ \\theta_i = \\theta_i - \\alpha (h_\\theta(x_0^{(j)}, x_1^{(j)}, ...x_n^{(j)}) - y_j)x_i^{(j)} $$随机梯度下降法，和批量梯度下降法是两个极端，一个采用所有数据来梯度下降，一个用一个样本来梯度下降。自然各自的优缺点都非常突出。对于训练速度来说，随机梯度下降法由于每次仅仅采用一个样本来迭代，训练速度很快，而批量梯度下降法在样本量很大的时候，训练速度不能让人满意。对于准确度来说，随机梯度下降法用于仅仅用一个样本决定梯度方向，导致解很有可能不是最优。对于收敛速度来说，由于随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。\n编程实现 网上找的代码，没验证，看个思路就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function [ theta,J_history ] = StochasticGD( X, y, theta, alpha, num_iter ) m = length(y); J_history = zeros(20, 1); temp = 0; n = 0; for iter = 1:num_iter temp = temp + 1; index = randi(m); theta = theta -alpha * (X(index, :) * theta - y(index)) * X(index, :)\u0026#39;; if temp\u0026gt;=100 temp = 0; n = n + 1; J_history(n) = ComputeCost(X, y, theta); end end end 小批量梯度下降法(Mini-Batch SGD) 也就是对于m个样本，我们采用x个样子来迭代，1\u0026lt;x\u0026lt;m。一般可以取x=10，当然根据样本的数据，可以调整这个x的值。\n岭回归 助教妹说就是不考 反转了，居然要考\n在原先的线性回归的代价函数上加入了一个L2正则项，就是岭回归\n$$ J(\\theta_0, \\theta_1..., \\theta_n) = \\sum\\limits_{i=1}^{m}(h_\\theta(x_0^{(i)}, x_1^{(i)}, ...x_n^{(i)}) - y_i)^2+\\lambda \\sum_{i=1}^m\\theta_i^2 $$非线性形式 助教妹说就是不考\n参考链接 梯度下降（Gradient Descent）小结 - 刘建平Pinard - 博客园 线性回归原理小结 - 刘建平Pinard - 博客园 ","date":"2022-05-20T12:50:16+08:00","image":"https://lbqaq.top/p/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/95446530.webp","permalink":"https://lbqaq.top/p/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"回归分析学习笔记"},{"content":"主成分分析(PCA) 基本思想 PCA顾名思义，就是找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。具体的，假如我们的数据集是n维的，共有m个数据$(x^{(1)},x^{(2)},\u0026hellip;,x^{(m)})$。我们希望将这m个数据的维度从n维降到n\u0026rsquo;维，希望这m个n\u0026rsquo;维的数据集尽可能的代表原始数据集。\n通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。\n由于得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵、奇异值分解协方差矩阵，所以PCA算法有两种实现方法：基于特征值分解协方差矩阵实现PCA算法、基于SVD分解协方差矩阵实现PCA算法。\n特征值分解(EVD) 特征值和特征向量的定义如下：\n$$ Ax=\\lambda x $$其中A是一个$n \\times n$的实对称矩阵，$x$是一个$n$维向量，则我们说$\\lambda$是矩阵A的一个特征值，而$x$是矩阵A的特征值$\\lambda$所对应的特征向量。\n求出特征值和特征向量有什么好处呢？ 就是我们可以将矩阵A特征分解。如果我们求出了矩阵A的$n$个特征值$\\lambda_1 \\leq \\lambda_2 \\leq \u0026hellip; \\leq \\lambda_n$,以及这$n$个特征值所对应的特征向量${q_1,q_2,\u0026hellip;q_n}$，如果这$n$个特征向量线性无关，那么矩阵A就可以用下式的特征分解表示：$A=Q\\Sigma Q^{-1}$ 。\n其中，Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。\n注意到要进行特征分解，矩阵A必须为方阵。那么如果A不是方阵，即行和列不相同时，我们还可以对矩阵进行分解吗？答案是可以，此时我们的SVD登场了。\n奇异值分解(SVD) SVD也是对矩阵进行分解，但是和特征分解不同，SVD并不要求要分解的矩阵为方阵。假设我们的矩阵A是一个$m \\times n$的矩阵，那么我们定义矩阵A的SVD为：\n$$ A = U\\Sigma V^T $$其中U是一个$m \\times m$的矩阵，$\\Sigma$是一个$m \\times n$的矩阵，除了主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值，V是一个$n \\times n$的矩阵。\n计算方法：\n我们将A的转置和A做矩阵乘法，那么会得到$n \\times n$的一个方阵$A^TA$。对其进行特征值分解，得到n个特征值和对应的n个特征向量$v$了。将$A^TA$的所有特征向量张成一个$n \\times n$的矩阵V，就是我们SVD公式里面的V矩阵了。 对$AA^T$进行特征值分解，得到m个特征值和对应的m个特征向量$u$了。将$AA^T$的所有特征向量张成一个$m \\times m$的矩阵U，就是我们SVD公式里面的U矩阵了。一般我们将U中的每个特征向量叫做A的左奇异向量。 由于奇异值矩阵$\\Sigma$除了对角线上是奇异值其他位置都是0，那我们只需要求出每个奇异值$\\sigma$就可以了。求解奇异值可以用$\\sigma_i = Av_i / u_i$或$\\sigma_i = \\sqrt{\\lambda_i}$ 算法过程 输入：n维样本集$D=(x^{(1)}, x^{(2)},\u0026hellip;,x^{(m)})$，要降维到的维数n'.\n输出：降维后的样本集$D'$\n对所有的样本进行中心化： $x^{(i)} = x^{(i)} - \\frac{1}{m}\\sum\\limits_{j=1}^{m} x^{(j)}$ 计算样本的协方差矩阵$XX^T$ 对矩阵$XX^T$进行特征值分解 取出最大的n\u0026rsquo;个特征值对应的特征向量$(w_1,w_2,\u0026hellip;,w_{n\u0026rsquo;})$, 将所有的特征向量标准化后，组成特征向量矩阵W。 对样本集中的每一个样本$x^{(i)}$,转化为新的样本$z^{(i)}=W^Tx^{(i)}$ 得到输出样本集$D\u0026rsquo; =(z^{(1)}, z^{(2)},\u0026hellip;,z^{(m)})$ 上面是采用EVD，如果采用SVD，在第二第三步时就用SVD进行解决。\n编程实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 load fisheriris; X = meas; %% 中心化 meanX = ones(size(X,1), 1) * mean(X); centredX = X - meanX; % 直接调用cov直接计算协方差矩阵即可 C = cov(centredX); %% 特征值分解 [W, Lambda] = eig(C); % 提取特征值 ev = (diag(Lambda))\u0026#39;; % eig计算出的特征值是升序的，这里手动倒序（W同理） ev = ev(:, end:-1:1); W = W(:, end:-1:1); % 提取前两个主成分的特征向量 Wr = W(:, 1:2); % 新坐标空间的数据点 Tr = centredX * Wr; %% 作图 figure(1); scatter(Tr(:,1), Tr(:,2), 130, categorical(species), \u0026#39;.\u0026#39;); colormap(winter); xlabel(\u0026#39;Principal Component 1\u0026#39;); ylabel(\u0026#39;Principal Component 2\u0026#39;); %% SVD分解 % 可以检验，W和V完全相同（向量的正负号不影响） [U, Sigma, V] = svd(X); % 提取前两个主成分的特征向量 Vr = V(:, 1:2); % 新坐标空间的数据点 Tr = X * Vr; %% 作图 figure(2); scatter(Tr(:,1), Tr(:,2), 130, categorical(species), \u0026#39;.\u0026#39;); colormap(winter); xlabel(\u0026#39;Principal Component 1\u0026#39;); ylabel(\u0026#39;Principal Component 2\u0026#39;); MATLAB三维数据绘图 三维线 使用plot3()函数即可绘制三维线,输入应为三个向量\n1 2 3 4 5 6 7 8 turns = 40*pi; t = linspace(0,turns,4000); x = cos(t).*(turns-t)./turns; y = sin(t).*(turns-t)./turns; z = t./turns; plot3(x,y,z); grid on; axis square; 三维图形绘制及等高线 我们可以通过使用mesh()命令绘制三维面，使用contour()命令可以绘制三维图形的等高线。 与之前的命令一样，我们也可以通过向其传递不同的参数来改变图形的细节。\n1 2 3 4 5 6 7 8 9 10 x = -3.5:0.2:3.5; y = -3.5:0.2:3.5; [X,Y] = meshgrid(x,y); Z = 10.*X.*exp(-X.^2-Y.^2); grid on; axis square; subplot(1,2,1); mesh(X,Y,Z); subplot(1,2,2); contour(X,Y,Z,\u0026#39;ShowText\u0026#39;, \u0026#39;on\u0026#39;, \u0026#39;LevelStep\u0026#39;, 1); 三维图形绘制及等高线\n参考资料 主成分分析（PCA）原理详解 - 知乎 奇异值分解(SVD)原理与在降维中的应用 - 刘建平Pinard - 博客园 ","date":"2022-05-17T22:45:18+08:00","image":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/94861285.webp","permalink":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/","title":"数据可视化笔记"},{"content":"分类算法的作用 分类是在一群已经知道类别标号的样本中，训练一种分类器，让其能够对某种未知的样本进行分类。分类算法属于一种有监督的学习。分类算法的分类过程就是建立一种分类模型来描述预定的数据集或概念集，通过分析由属性描述的数据库元组来构造模型。分类的目的就是使用分类对新的数据集进行划分，其主要涉及分类规则的准确性、过拟合、矛盾划分的取舍等。\n有监督学习和无监督学习的区别 有监督学习是指数据集的正确输出已知情况下的一类学习算法。因为输入和输出已知，意味着输入和输出之间有一个关系，监督学习算法就是要发现和总结这种“关系”。 无监督学习是指对无标签数据的一类学习算法。因为没有标签信息，意味着需要从数据集中发现和总结模式或者结构。 简单来说，是否有监督（supervised），就看输入数据是否有标签（label） 交叉验证 基本思想 交叉验证的基本思想是把在某种意义下将原始数据(dataset)进行分组，一部分做为训练集(train set)，另一部分做为验证集(validation set or test set)，首先用训练集对分类器进行训练，再利用验证集来测试训练得到的模型(model)，以此来做为评价分类器的性能指标。用交叉验证的目的是为了得到可靠稳定的模型。\nK折交叉验证(K-fold cross-validation) K折交叉验证就是进行多次train_test_split划分；每次划分时，在不同的数据集上进行训练、测试评估，从而得出一个评价结果；如果是10折交叉验证，意思就是在原始数据集上，进行10次划分，每次划分进行一次训练、评估，最后得到10次划分后的评估结果，一般在这几次评估结果上取平均得到最后的评分。其中，k一般取5或10。\nK折交叉验证的步骤：\n将原始数据集划分为相等的K部分（“折”） 将第1部分作为测试集，其余作为训练集 训练模型，计算模型在测试集上的准确率 每次用不同的部分作为测试集，重复步骤2和3 K次 将平均准确率作为最终的模型准确率 💡 要会给定数据集进行K折交叉验证 要会计算模型准确率（每次的准确率、最终的准确率）\n支持向量机(SVM) 基本思想 SVM学习的基本思想是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。\n用我自己的理解，就是找一条线将两个数据集分开，要保证这条线到两边的数据集距离最大。那么，如何才能保证距离最大呢，这就是下面要讨论的难点了。\n支持向量 在支持向量机中，距离超平面最近的且满足一定条件的几个训练样本点被称为支持向量。\n在上图中，处于虚线上的点（即红色的点）我们就将其定义为支持向量。那么，如何得到支持向量到超平面的距离呢？我们引入几何间隔的概念：\n$$ \\gamma = \\frac{y(w^Tx + b)}{||w||_2} = \\frac{\\gamma^{'}}{||w||_2} $$一般我们都取函数间隔$\\gamma^{\u0026rsquo;}$为1，这样我们就可以得到支持向量到超平面的距离为$\\frac{1}{||w||_2}$，两个支持向量之间的距离为$\\frac{2}{||w||_2}$\nSVM模型目标函数 SVM的模型是让所有点到超平面的距离大于一定的距离，也就是所有的分类点要在各自类别的支持向量两边。用数学式子表示为：\n$$ max \\\\;\\\\; \\frac{1}{||w||_2} \\\\;\\\\; s.t \\\\;\\\\; y_i(w^Tx_i + b) \\geq 1 (i =1,2,...m) $$其中，$||w||_2$为向量$w$的L2范数，即：\n$$ ||w||_2=\\sqrt{w_1^2+w_2^2} $$为了去除根号方便计算，我们将原式转化为：\n$$ min \\\\;\\\\; \\frac{1}{2}||w||_2^2 \\\\;\\\\; s.t \\\\;\\\\; y_i(w^Tx_i + b) \\geq 1 (i =1,2,...m) $$由于目标函数$\\frac{1}{2}||w||_2^2$是凸函数，同时约束条件不等式是仿射的，根据凸优化理论，我们可以通过拉格朗日函数将我们的优化目标转化为无约束的优化函数。于是根据拉格朗日乘子法，我们得到：\n$$ L(w,b,\\alpha) = \\frac{1}{2}||w||_2^2 - \\sum \\limits _{i=1}^{m} \\alpha_i [y_i(w^Tx_i + b) - 1] \\\\; 满足\\alpha_i \\geq 0 $$其中$\\alpha_i$为拉格朗日乘子。\nKKT条件 我们对上面的式子求偏导，可以得到\n$$ \\frac{\\partial L }{\\partial w}=0,\\frac{\\partial L }{\\partial b}=0 $$解得\n$$ \\boldsymbol{w}=\\sum_{i=1}^N{\\alpha_iy_i\\boldsymbol{x}_{\\boldsymbol{i}}} $$$$ \\sum_{i=1}^N{\\alpha_iy_i}=0 $$解方程可得\n$$ \\begin{cases} \\alpha_i\\geq 0 \\\\\\\\ y_i(\\overrightarrow{w_i}\\cdot \\overrightarrow{x_i}+b)-1\\geq 0 \\\\\\\\ \\alpha_i(y_i(\\overrightarrow{w_i}\\cdot\\overrightarrow{x_i}+b)-1)=0 \\end{cases} $$上面的式子即为KKT条件\nSVM对偶性 现在我们令\n$$ \\theta \\left( \\boldsymbol{w} \\right) =\\underset{\\alpha _{_i}\\ge 0}{\\max}\\ L\\left( \\boldsymbol{w,}b,\\boldsymbol{\\alpha } \\right) $$当样本点不满足约束条件时，即在可行解区域外$y_i\\left(\\boldsymbol{w}\\cdot \\boldsymbol{x}_{\\boldsymbol{i}}+b\\right)\u0026lt;1$。此时，将$\\alpha_i$设置为无穷大，则$\\theta \\left( \\boldsymbol{w} \\right)$也为无穷大。\n当样本点不满足约束条件时，即在可行解区域内$y_i\\left(\\boldsymbol{w}\\cdot \\boldsymbol{x}_{\\boldsymbol{i}}+b\\right)\\ge1$。此时，$\\theta \\left( \\boldsymbol{w} \\right)$为原函数本身。\n于是，将两种情况合并起来就可以得到我们新的目标函数：\n$$ \\theta \\left( \\boldsymbol{w} \\right) =\\begin{cases} \\frac{1}{2}\\lVert \\boldsymbol{w} \\rVert ^2\\ ,\\boldsymbol{x}\\in \\text{可行区域}\\\\\\\\ +\\infty \\ \\ \\ \\ \\ ,\\boldsymbol{x}\\in \\text{不可行区域}\\\\\\\\ \\end{cases} $$于是原约束问题就等价于：\n$$ \\underset{\\boldsymbol{w,}b}{\\min}\\ \\theta \\left( \\boldsymbol{w} \\right) =\\underset{\\boldsymbol{w,}b}{\\min}\\underset{\\alpha _i\\ge 0}{\\max}\\ L\\left( \\boldsymbol{w,}b,\\boldsymbol{\\alpha } \\right) $$由上小节，我们可以知道该函数满足拉格朗日函数对偶性：\n优化问题是凸优化问题 满足KKT条件 于是，我们可以将其最小和最大的位置交换一下，这样就变成了：\n$$ \\underset{\\alpha _i\\ge 0}{\\max}\\underset{\\boldsymbol{w,}b}{\\min}\\ L\\left( \\boldsymbol{w,}b,\\boldsymbol{\\alpha } \\right) $$从上式中，我们可以先求优化函数对于$w$和$b$的极小值。接着再求拉格朗日乘子$\\alpha$的极大值。\n通过在上节中由偏导推出的两个式子，我们得到了$w$和$\\alpha$的关系，就可以带入优化函数$L(w,b,\\alpha)$消去$w$了\n此时原式为\n我们对目标式子加一个负号，将求解极大转换为求解极小\nSVM核（Kernel）方法 基本概念 在上节我们推导出的式子中，我们可以看到上式低维特征仅仅以内积$x_i \\bullet x_j$ 的形式出现，如果我们定义一个低维特征空间到高维特征空间的映射$T$，将所有特征映射到一个更高的维度，让数据线性可分，我们就可以求出分离超平面和分类决策函数了。\n但是，将数据从低维映射到高维，将会大大增加计算的复杂度，如果遇到无穷维的情况，就根本无从计算了。这时，就需要引入核函数了。\n我们定义果存在函数$K(x,z)$，对于任意$x, z$ ，都有：\n$$ K(x, z) = T(x) \\bullet T(z) $$那么我们就称$K(x, z)$为核函数。\n通过核函数，就避免了在刚才我们提到了在高维维度空间计算内积的恐怖计算量。也就是说，我们可以好好享受在高维特征空间线性可分的红利，却避免了高维特征空间恐怖的内积计算量。\n下面我们来看看常见的核函数, 选择这几个核函数介绍是因为scikit-learn中默认可选的就是下面几个核函数。\n线性核函数（Linear Kernel） 其实就是线性可分SVM，表达式为：\n$$ K(x, z) = x \\bullet z $$也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。\n多项式核函数（Polynomial Kernel） 多项式核函数是线性不可分SVM常用的核函数之一，表达式为：\n$$ K(x, z) = （\\gamma x \\bullet z + r)^d $$其中，$\\gamma, r,d$都需要自己调参定义。\n高斯核函数（Gaussian Kernel） 在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：\n$$ K(x, z) = exp(-\\gamma||x-z||^2) $$其中，$\\gamma$大于0，需要自己调参定义。\n💡 高斯核函数很重要，一定要记住\nSigmoid核函数 也是线性不可分SVM常用的核函数之一，表达式为：\n$$ K(x, z) = tanh（\\gamma x \\bullet z + r) $$其中，$\\gamma, r$都需要自己调参定义。\nSVM软间隔 有时候本来数据的确是可分的，也就是说可以用 线性分类SVM的学习方法来求解，但是却因为混入了异常点，导致不能线性可分，比如下图\n这种情况下，SVM引入了软间隔最大化的方法来解决。\nSVM对训练集里面的每个样本$(x_i,y_i)$引入了一个松弛变量$\\xi_i \\geq 0$,使函数间隔加上松弛变量大于等于1，也就是说：\n$$ y_i(w\\bullet x_i +b) \\geq 1- \\xi_i $$对比硬间隔最大化，可以看到我们对样本到超平面的函数距离的要求放松了，之前是一定要大于等于1，现在只需要加上一个大于等于0的松弛变量能大于等于1就可以了。当然，松弛变量不能白加，这是有成本的，每一个松弛变量$\\xi_i$, 对应了一个代价$\\xi_i$，这个就得到了我们的软间隔最大化的SVM学习条件如下：\n$$ min\\\\;\\\\; \\frac{1}{2}||w||_2^2 +C\\sum\\limits{i=1}^{m}\\xi_i $$$$ s.t. \\\\;\\\\; y_i(w^Tx_i + b) \\geq 1 - \\xi_i \\\\;\\\\;(i =1,2,...m) $$$$ \\xi_i \\geq 0 \\\\;\\\\;(i =1,2,...m) $$这里，$C\u0026gt;0$为惩罚参数，可以理解为我们一般回归和分类问题正则化时候的参数。$C$越大，对误分类的惩罚越大，$C$越小，对误分类的惩罚越小。\n也就是说，我们希望$\\frac{1}{2}||w||_2^2$尽量小，误分类的点尽可能的少。C是协调两者关系的正则化惩罚系数。在实际应用中，需要调参来选择。\nSVM编程实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 %% 生成测试数据 classCount= 2; p= 100; bound =[0 10]; data =[... [2,2]+ randn(p,2),-1*ones(p,1);... [6,6]+ randn(p,2),+1*ones(p,1);... ]; X= data(:,1:end-1); Y = data(:,end); %% 显示生成的测试数据 figure(1) clf; gscatter(X(:,1), X(:,2), Y, \u0026#39;rb\u0026#39;, \u0026#39;X+\u0026#39;); legend({\u0026#39;分类-1\u0026#39;, \u0026#39;分类+1\u0026#39;}); title(\u0026#34;原始数据散点图\u0026#34;); xlim(bound); ylim(bound); %% 拆分训练集和测试集 trainIndex = (mod(1:size(X,1),3)==1); testIndex = ~trainIndex; Xtrain=X(trainIndex,:); Ytrain=Y(trainIndex,:); Xtest=X(testIndex,:); Ytest=Y(testIndex,:); %% 将拆分的结果展示 figure(2) clf; hold on; gscatter(Xtrain(:,1),Xtrain(:,2),Ytrain,\u0026#39;rb\u0026#39;,\u0026#39;X+\u0026#39;); scatter(Xtest(:,1),Xtest(:,2),\u0026#39;k.\u0026#39;); hold off; legend({\u0026#39;分类-1\u0026#39;,\u0026#39;分类+1\u0026#39;,\u0026#39;测试数据\u0026#39;}); title(\u0026#34;划分测试数据后的散点图\u0026#34;); xlim(bound); ylim(bound); %% 使用SVM进行训练 svm=fitcsvm(Xtrain,Ytrain); %% 展示SVM训练的结果 figure(3) clf; gscatter(Xtrain(:,1), Xtrain(:, 2), Ytrain, \u0026#39;rb\u0026#39;, \u0026#39;X+\u0026#39;); hold on; gscatter(svm.SupportVectors(:,1), svm.SupportVectors(:,2),svm.SupportVectorLabels,\u0026#39;rb\u0026#39;,\u0026#39;oo\u0026#39;,13); xg = bound; yg = [-svm.Bias/svm.Beta(2) -svm.Beta(1)/svm.Beta(2) * bound(2)-svm.Bias/svm.Beta(2)]; plot(xg, yg, \u0026#39;g\u0026#39;, \u0026#39;Linewidth\u0026#39;, 2); delta = -svm.Beta(1)/svm.Beta(2)*svm.SupportVectors(1,1)-svm.SupportVectors(1,2)-svm.Bias/svm.Beta(2); plot(xg, yg-delta, \u0026#39;--g\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); plot(xg, yg+delta, \u0026#39;--g\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); hold off; xlim(bound); ylim(bound); legend({\u0026#39;分类-1\u0026#39;, \u0026#39;分类+1\u0026#39;, \u0026#39;支持向量-1\u0026#39;, \u0026#39;支持向量+1\u0026#39;, \u0026#39;超平面\u0026#39;, \u0026#39;超平面-1\u0026#39;, \u0026#39;超平面+1\u0026#39;}); title(\u0026#34;SVM训练后的散点图\u0026#34;); %% 使用训练好的模型进行预测 Ypred = predict(svm, Xtest); %% 绘制预测后的结果 figure(4) clf; gscatter(Xtest(:,1), Xtest(:, 2), Ypred, \u0026#39;rb\u0026#39;, \u0026#39;X+\u0026#39;); hold on; g = gscatter(svm.SupportVectors(:,1), svm.SupportVectors(:,2), svm.SupportVectorLabels, \u0026#39;rb\u0026#39;,\u0026#39;oo\u0026#39;,13); plot(xg, yg, \u0026#39;g\u0026#39;, \u0026#39;Linewidth\u0026#39;, 2); plot(xg, yg-delta, \u0026#39;--g\u0026#39;, \u0026#39;Linewidth\u0026#39;, 2); plot(xg, yg+delta, \u0026#39;--g\u0026#39;, \u0026#39;Linewidth\u0026#39;, 2); hold off; xlim(bound); ylim(bound); legend({\u0026#39;分类-1\u0026#39;, \u0026#39;分类+1\u0026#39;, \u0026#39;支持向量-1\u0026#39;, \u0026#39;支持向量+1\u0026#39;, \u0026#39;超平面\u0026#39;, \u0026#39;超平面-1\u0026#39;, \u0026#39;超平面+1\u0026#39;}); title(\u0026#34;SVM预测后的散点图\u0026#34;); %% 计算误差 fprintf(\u0026#39;正确率为：%.2f%%\\n\u0026#39;,(sum(Ypred==Ytest)/numel(Ytest)).*100); SVM实现多分类 SVM算法最初是为二值分类问题设计的，当处理多类问题时，就需要构造合适的多类分类器。\n目前，构造SVM多类分类器的方法主要有两类：\n（1）直接法，直接在目标函数上进行修改，将多个分类面的参数求解合并到一个最优化问题中，通过求解该最优化问题“一次性”实现多类分类。这种方法看似简单，但其计算复杂度比较高，实现起来比较困难，只适合用于小型问题中；\n（2）间接法，主要是通过组合多个二分类器来实现多分类器的构造，常见的方法有one-against-one和one-against-all两种。\n一对多法（OVR） 训练时依次把某个类别的样本归为一类,其他剩余的样本归为另一类，这样k个类别的样本就构造出了k个SVM。分类时将未知样本分类为具有最大分类函数值的那类。\n假如我有四类要划分（也就是4个Label），他们是A、B、C、D。\n于是我在抽取训练集的时候，分别抽取\nA所对应的向量作为正集，B，C，D所对应的向量作为负集； B所对应的向量作为正集，A，C，D所对应的向量作为负集； C所对应的向量作为正集，A，B，D所对应的向量作为负集； D所对应的向量作为正集，A，B，C所对应的向量作为负集； 使用这四个训练集分别进行训练，然后的得到四个训练结果文件。在测试的时候，把对应的测试向量分别利用这四个训练结果文件进行测试。最后每个测试都有一个结果f1(x),f2(x),f3(x),f4(x)。\n于是最终的结果便是这四个值中最大的一个作为分类结果。\n一对一法（OVO） 一般都是用一对多法，这里就不展开了，知道有这个东西就行。\n参考资料 支持向量机（SVM）——原理篇 - 知乎 支持向量机原理(一) 线性支持向量机 - 刘建平Pinard - 博客园 等同系列文章 【数之道25】机器学习必经之路-SVM支持向量机的数学精华_哔哩哔哩_bilibili 等同系列视频 ","date":"2022-05-10T14:00:16+08:00","image":"https://lbqaq.top/p/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/86368113.webp","permalink":"https://lbqaq.top/p/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"分类算法学习笔记"},{"content":"Kmeans 算法步骤 从样本中选择 K 个点作为初始质心（完全随机） 计算每个样本到各个质心的距离，将样本划分到距离最近的质心所对应的簇中 计算每个簇内所有样本的均值，并使用该均值更新簇的质心 重复步骤 2 与 3 ，直到达到以下条件之一： 质心的位置变化小于指定的阈值（默认为 0.0001） 达到最大迭代次数 欧氏距离 衡量的是多维空间中两个点之间的绝对距离\n在二维和三维空间中的欧氏距离就是两点之间的实际距离\n计算方法：对应坐标值相减的平方和再开方\n$$ dist(X,Y)=\\sqrt{\\sum_{i=1}^{n}(x_i-y_i)^2} $$对于二维来说，就是\n$$ dist(X,Y)=\\sqrt{(x_1-y_1)^2+(x_2-y_2)^2} $$注意理解输入？输出？类别中心？迭代过程中做什么？\n编程实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 %% 生成测试数据 clear p=100; % 每簇的样本数 sigma = [0.1 0;0 0.1]; % 协方差矩阵 R = chol(sigma); % 生成测试数据集 data=[... [0 0] + randn(p,2)*R,1*ones(p,1);... [0 2] + randn(p,2)*R,2*ones(p,1);... [2 0] + randn(p,2)*R,3*ones(p,1);... [2 2] + randn(p,2)*R,4*ones(p,1);... ]; %% 绘制样本散点图 figure(1) scatter(data(:,1),data(:,2),\u0026#39;r.\u0026#39;) title(\u0026#34;无样式样本散点图\u0026#34;) X=data(:,1:end-1); g=data(:,end); n=size(X,1); %% K-means实现 k=4; % 指定分成的簇数 %从n个数据样本中不重复地随机选择k个样本作为质 centerIndex = randperm(n, k); C = X(centerIndex, :); result = struct(\u0026#39;y\u0026#39;,[],\u0026#39;C\u0026#39;,[],\u0026#39;objectives\u0026#39;,[]); iter = 0; maxIter = 10; % 指定最大迭代的次数 while (iter \u0026lt; maxIter) iter = iter + 1; % 求出每个样本到中心点的距离，按照距离自身最近的中心点进行聚类 D = pdist2(X, C); [d, ypred] = min(D, [], 2); % 保存结果 result(iter).y = ypred; result(iter).C = C; result(iter).objectives = sum(d.*d); % 当距离没变时结束迭代 if(iter \u0026gt; 1 \u0026amp;\u0026amp; result(iter).objectives == result(iter-1).objectives) break; end % 依据上次聚类结果，求出新的中心点 for cid = 1: size(C,1) C(cid, :) = mean (X(ypred == cid, :)); end end %% 绘制结果散点图 figure(2); for t = 1: numel(result) figure(2); clf % 绘制聚类结果 gscatter(X(:,1), X(:,2), result(t).y,\u0026#39;rgbm\u0026#39;); hold on; Ct = result(t).C; % 绘制聚类中心 h=gscatter(Ct(:,1), Ct(:,2), (1: size(Ct,1)), \u0026#39;kkkk\u0026#39;, \u0026#39;x+od\u0026#39;, 10); title(\u0026#34;第\u0026#34;+t+\u0026#34;次迭代后散点图\u0026#34;) set(h,\u0026#39;LineWidth\u0026#39;, 2.0); waitforbuttonpress; %pause(1); end %% 计算误差 % 输出混淆矩阵 confusionmat(g,ypred) 缺点 容易受初始质心的影响；算法聚类时，容易产生空簇；算法可能收敛到局部最小值。\n解决办法：重新执行K-means算法，重新分配质心\n谱聚类(Spectral Clustering) 算法思想 把所有的数据看做空间中的点，这些点之间可以用边连接起来。距离较远的两个点之间的边权重值较低，而距离较近的两个点之间的边权重值较高，通过对所有数据点组成的图进行切图，让切图后不同的子图间边权重和尽可能的低，而子图内的边权重和尽可能的高，从而达到聚类的目的。\n度矩阵D 对于一个图$G$，我们一般用点的集合$V$和边的集合$E$来描述。即为$G(V,E)$。其中$V$即为我们数据集里面所有的点$(v_1, v_2,\u0026hellip;v_n)$。对于$V$中的任意两个点，可以有边连接，也可以没有边连接。我们定义权重$w_{ij}$为点$v_i$和点$v_j$之间的权重。由于我们是无向图，所以$w_{ij} = w_{ji}$。\n对于有边连接的两个点$v_i$和$v_j$，$w_{ij} \u0026gt; 0$,对于没有边连接的两个点$v_i$和$v_j$，$w_{ij} = 0$。对于图中的任意一个点$v_i$，它的度$d_i$定义为和它相连的所有边的权重之和，即\n$$ d_i = \\sum\\limits_{j=1}^{n}w_{ij} $$利用每个点度的定义，我们可以得到一个nxn的度矩阵$D$,它是一个对角矩阵，只有主对角线有值，对应第i行的第i个点的度数，定义如下：\n$$ \\mathbf{D} = \\left( \\begin{array}{ccc} d_1 \u0026 \\ldots \u0026 \\ldots \\\\\\\\ \\ldots \u0026 d_2 \u0026 \\ldots \\\\\\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \\\\\\\\ \\ldots \u0026 \\ldots \u0026 d_n \\end{array} \\right) $$利用所有点之间的权重值，我们可以得到图的邻接矩阵$W$，它也是一个nxn的矩阵，第i行的第j个值对应我们的权重$w_{ij}$。\n除此之外，对于点集$V$的的一个子集$A \\subset V$，我们定义：\n$$ |A|: = 子集A中点的个数 $$$$ vol(A): = \\sum\\limits_{i \\in A}d_i $$相似矩阵 构建邻接矩阵$W$的方法有三类：\n$\\epsilon$-邻近法\n它设置了一个距离阈值$\\epsilon$，然后用欧式距离$s_{ij}$度量任意两点$x_i$和$x_j$的距离。 然后根据$s_{ij}$和$\\epsilon$的大小关系，来定义邻接矩阵$W$。距离小于$\\epsilon$为$\\epsilon$，距离大于$\\epsilon$为0\nK邻近法\n利用KNN算法遍历所有的样本点，取每个样本最近的k个点作为近邻，只有和样本距离最近的k个点之间的$w_{ij} \u0026gt; 0$。但是这种方法会造成重构之后的邻接矩阵W非对称。\n全连接法（最常用）\n相比前两种方法，第三种方法所有的点之间的权重值都大于0，因此称之为全连接法。可以选择不同的核函数来定义边权重，常用的有多项式核函数，高斯核函数和Sigmoid核函数，最常用的是高斯核函数RBF。\n$$ w_{ij}=s_{ij}=exp(-\\frac{||x_i-x_j||_2^2}{2\\sigma^2}) $$ 💡 exp(x)表示$e^x$\n拉普拉斯矩阵 拉普拉斯矩阵$L= D-W$\n$D$即为度矩阵，它是一个对角矩阵。$W$为邻接矩阵。\n无向图切图 对于无向图$G$的切图，我们的目标是将图$G(V,E)$切成相互没有连接的k个子图，每个子图点的集合为：$A_1,A_2,..A_k$，它们满足$A_i \\cap A_j = \\emptyset$,且$A_1 \\cup A_2 \\cup \u0026hellip; \\cup A_k = V$.\n对于任意两个子图点的集合$A, B \\subset V$, $A \\cap B = \\emptyset$, 我们定义A和B之间的切图权重为：\n$$ W(A, B) = \\sum\\limits_{i \\in A, j \\in B}w_{ij} $$ 最小化切图\n$$ \\min cut(A,B)=\\sum\\limits_{i \\in A, j \\in B}w_{ij} $$ RatioCut切图\n$$ RatioCut(A,B)=cut(A,B)(\\frac{1}{|A|}+\\frac{1}{|B|}) $$ Ncut切图\n$$ Ncut(A,B)=cut(A,B)(\\frac{1}{vol(A)}+\\frac{1}{vol(B)}) $$ 算法流程 最常用的相似矩阵的生成方式是基于高斯核距离的全连接方式，最常用的切图方式是Ncut。而到最后常用的聚类方法为K-Means。\n输入：样本集D=$(x_1,x_2,\u0026hellip;,x_n)$，相似矩阵的生成方式, 降维后的维度$k_1$, 聚类方法，聚类后的维度$k_2$\n输出： 簇划分$C(c_1,c_2,\u0026hellip;c_{k_2})$.\n根据输入的相似矩阵的生成方式构建样本的相似矩阵S 根据相似矩阵S构建邻接矩阵W，构建度矩阵D 计算出拉普拉斯矩阵L 构建标准化后的拉普拉斯矩阵$D^{-1/2}LD^{-1/2}$ 计算$D^{-1/2}LD^{-1/2}$最小的$k_1$个特征值所各自对应的特征向量$f$ 将各自对应的特征向量$f$组成的矩阵按行标准化，最终组成$n \\times k_1$维的特征矩阵F 对F中的每一行作为一个$k_1$维的样本，共n个样本，用输入的聚类方法进行聚类，聚类维数为$k_2$ 得到簇划分$C(c_1,c_2,\u0026hellip;c_{k_2})$ 编程实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 rng(\u0026#39;default\u0026#39;) %% 生成测试数据 p= 200; theta = linspace(0,2*pi,p)\u0026#39;; data =[... 2*[cos(theta) sin(theta)]+ rand(p,1),1*ones(p,1); 4*[cos(theta) sin(theta)]+ rand(p,1),2*ones(p,1); ]; X = data(:,1:end-1); y = data(:,end); gscatter(X(:,1),X(:,2),y,\u0026#39;rg\u0026#39;); %% 距离矩阵 Q = pdist2(X, X); imagesc(Q); colorbar; %% 构造图的相似度矩阵A sigma = 0.1; A = exp(-Q.*Q / (2*sigma*sigma)); imagesc(A); colorbar; %% 构造图的拉普拉斯矩阵L D = diag(sum(A,2)); L = D - A; imagesc(L); colorbar; %% 对拉普拉斯矩阵进行特征值分解 [V,S] = eig(L); s = diag(S); plot(s); %% 取最小的k个特征值对应的特征向量 k = 2; Vr = V(:,1:k); Vr([1:2, end-1:end],:) %% 对映射后的特征矩阵Vr进行kmeans聚类 idx = kmeans(Vr,k); gscatter(X(:,1),X(:,2),idx,\u0026#39;rg\u0026#39;); title([\u0026#39;谱聚类 \\sigma = \u0026#39;,num2str(sigma)]) 简化考试专用代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 % 数据为X,y %% 距离矩阵 Q = pdist2(X, X); %% 构造图的相似度矩阵A sigma = 0.1; A = exp(-Q.*Q / (2*sigma*sigma)); %% 构造图的拉普拉斯矩阵L D = diag(sum(A,2)); L = D - A; %% 对拉普拉斯矩阵进行特征值分解 [V,S] = eig(L); %% 取最小的k个特征值对应的特征向量 k = 2; Vr = V(:,1:k); %% 对映射后的特征矩阵Vr进行kmeans聚类 idx = kmeans(Vr,k); gscatter(X(:,1),X(:,2),idx,\u0026#39;rg\u0026#39;); title([\u0026#39;谱聚类 \\sigma = \u0026#39;,num2str(sigma)]) 参考文档 K-Means(K均值聚类算法) - 知乎 谱聚类（spectral clustering）原理总结 - 刘建平Pinard - 博客园 ","date":"2022-05-10T08:23:41+08:00","image":"https://lbqaq.top/p/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/97701948.webp","permalink":"https://lbqaq.top/p/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"聚类算法学习笔记"},{"content":"打了两次力扣的周赛，都败在了第三题上，而且都是二分查找的题目。这下不能忍了，必须来总结一波。\n第一次二分查找 二分查找是用来在一个有序数组中查找某一元素的算法。它的工作原理如下：\n它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。\n使用二分查找就能将原先$\\Omicron(n)$时间复杂度的线性查找降低为$\\Omicron(\\log(n))$。但是一定要注意，二分查找一定要在有序的数组上进行。\n下面放上模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int binary_search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size() - 1; int ret = -1; // 未搜索到数据返回-1下标 int mid; while (left \u0026lt;= right) { mid = left + ((right - left) \u0026gt;\u0026gt; 1); // 直接平均可能会溢出，所以用这个算法 if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid - 1; else { // 最后检测相等是因为多数搜索情况不是大于就是小于 ret = mid; break; } } return ret; // 单一出口 } 在上面的代码中，我们每次搜索的是[left,right]这个闭区间，所以在while中要使用\u0026lt;=。\n但是，这样的算法还是存在一些缺陷。比如对于条件nums = [1,2,2,2,3],target=2，使用上面的算法返回的下标是2。虽然答案是正确的，但我们想要得到target的左侧边界或右侧边界就不能使用上面的算法了。虽然可以先查出结果再向左或右线性搜索，但这样时间复杂度就被提高了。\n寻找左侧边界的二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int left_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.size() == 0) return -1; int left = 0; int right = nums.size(); // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid; // 注意 } } // target 比所有数都大 if (left == nums.size()) return -1; // 未查到目标值 return nums[left] == target ? left : -1; } 在这里我们搜索的区间变成了左闭右开[left,right)，所以在while中使用\u0026lt;。\n由于搜索区间变为[left,right)，所以当 nums[mid]被检测之后，下一步的搜索区间应该去掉 mid分割成两个区间，即 [left, mid)或 [mid + 1, right)。在代码中体现为left = mid + 1;和right = mid;\n那么，这个模板为什么能找到左边界呢？关键在于nums[mid] == target这种情况的处理：\nright = mid;\n我们找到 target 时没有立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid)中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\n寻找右侧边界的二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int right_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.size() == 0) return -1; int left = 0, right = nums.size(); while (left \u0026lt; right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid; } } if (left == 0) return -1; return nums[left - 1] == target ? (left - 1) : -1; // 注意要-1 } 由于我们对 left的更新必须是 left = mid + 1，这就导致了 while 循环结束时，nums[left]一定不等于 target了，而 nums[left-1]可能是 targe。所以我们在返回结果时要进行-1操作。\n第二次二分查找 虽说上面的模板已经够好了，但是有些题目并不是只考一个二分，如果照着敲一遍模板还是比较费时的。这是就不得不祭出\u0026lt;algorithm\u0026gt;里的两个内置函数了：\nlower_bound 返回指向范围 [first, last) 中首个不小于（即大于或等于） value 的元素的迭代器，或若找不到这种元素则返回 last 。\n仔细考虑一下，就会发现这就是上面提到的寻找左侧边界的二分查找，一下就把原来那么长的代码变成了一行，太香了。（但是上面的模板还是要掌握，有些题目是无法调库）\n使用举例：\n1 2 3 4 5 6 int main() { vector\u0026lt;int\u0026gt; nums = {1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6}; auto lower = lower_bound(nums.begin(), nums.end(), 3); cout \u0026lt;\u0026lt; lower - nums.begin() \u0026lt;\u0026lt; endl; //3 return 0; } 一个小细节，lower_bound返回的是迭代器，所以lower的真实类型是vector\u0026lt;int\u0026gt;::iterator，太长了所以我们用的时候还是使用auto让编译器来补全QuQ。\nupper_bound 返回指向范围 [first, last) 中首个大于 value 的元素的迭代器，或若找不到这种元素则返回 last 。\n其实就是上面寻找右侧边界的二分查找，只不过我们进行了-1操作而该函数没有而已。\n使用举例：\n1 2 3 4 5 6 int main() { vector\u0026lt;int\u0026gt; nums = {1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6}; auto upper = upper_bound(nums.begin(), nums.end(), 3); cout \u0026lt;\u0026lt; upper - nums.begin() \u0026lt;\u0026lt; endl; //7 return 0; } 终极二分查找 上面的都是对一个数组进行二分查找，我们也可以把思路放开一点，对答案进行二分查找。我们都知道暴力法就是枚举答案然后检验枚举的值是否正确，当答案满足单调性时，我们就可以将枚举换为二分，这样能大大降低时间复杂度。\n放两道例题，就是引言里我说的周赛题\n2187. 完成旅途的最少时间 - 力扣（LeetCode） 5219. 每个小孩最多能分到多少糖果 - 力扣（LeetCode） 参考资料 二分 - OI Wiki 二分查找细节详解，顺便赋诗一首 - 二分查找 - 力扣（LeetCode） ","date":"2022-04-04T22:54:54+08:00","image":"https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/89247070.webp","permalink":"https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/","title":"二分查找是个啥啊"},{"content":"进制转换 在数学中，不止只有我们常见的10进制，最近刷了几道关于进制转换的题目，在这里做个总结和记录吧。\n基本概念 首先我们要先了解进制的基本概念，这里我直接从LeetCode官方这里引用了。\n任何一种进位计数制都有一个基数，基数为 X 的进位计数制称为 X 进制，表示每一个数位上的数运算时都是逢 X 进一。\n对于一个 X 进制的数，其具体数值由其中的每个数码和数码所在的数位决定。整数部分从右往左的第 m 个数位表示的权重是 $X^m$，其中 m 最小为 0；小数部分从左往右的第 n 个数位表示的权重是$X^{-n}$，其中 n 最小为 1。\n八进制的 $720.5$ 可以写成如下形式：\n$720.5_{(8)} = 7 \\times 8^2 + 2 \\times 8^1 + 0 \\times 8^0 + 5 \\times 8^{-1}$\n用我自己的话来说，就是数值*权重\n进制转换的一般思路 一般来说，我们习惯将进制转换成十进制，这样便于理解和手算。当然，我们也可以不通过十进制作为中间态过度，比如我们熟悉的二进制和十六进制的转换。\n非十进制转十进制 将非十进制数转成十进制数，只要将每个数位的加权和即可。\n例如，将八进制数 $720.5_{(8)}$ 转成十进制：\n$720.5_{(8)} = 7 \\times 8^2 + 2 \\times 8^1 + 0 \\times 8^0 + 5 \\times 8^{-1} = 464.625$\n下面是程序的实现(只考虑整数)，我们可以从高位到低位进行读取，按照下面的方式读入,其中n表示是几进制数\n1 2 3 4 5 6 7 8 9 10 11 int read() { char c = getchar(); int k = 0; while (isint(c) == -1) c = getchar(); while (isint(c) != -1) { k *= n; k += isint(c); c = getchar(); } return k; } 十进制转非十进制 首先我们先来看手算，将十进制数转成 X 进制数，需要对整数部分和小数部分分别转换。\n对于整数部分，转换方式是将十进制数的整数部分每次除以 X 直到变成 0，并记录每次的余数，反向遍历每次的余数即可得到 X 进制表示。\n对于小数部分，转换方式是将十进制数的小数部分每次乘以 X 直到变成 0，并记录每次的整数部分，正序遍历每次的整数部分即可得到 X 进制表示。\n下面是整数转换的过程，这里要注意的是转换时是从低位到高位，如果要输出的话要进行倒序，体现在程序中就是先递归再输出。\n1 2 3 4 5 6 void print(int a) { if (!a) return; print(a / m); putchar(itc(a % m)); } 负进制 [NOIP2000 提高组] 进制转换\n在洛谷的这道题中，我们遇到了一个新的概念：负进制\n在负进制数中是用 $-R$ 作为基数，例如 $−15$（十进制）相当于 $110001$ （$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：\n$110001=1\\times (-2)^5+1\\times (-2)^4+0\\times (-2)^3+0\\times (-2)^2+0\\times (-2)^1 +1\\times (-2)^0$\n如果按照上面所写的转换过程，就会出现一个问题，比如在C++里对$-15$进行取模和相除的结果是：\n$-15%-2=-1$ ； $-15\\div-2=7$ ； $7\\times-2+(-1)=-15$\n虽然式子是成立的，但我们得到的余数是负数，这肯定是不行的，所以我们要想办法进行转换。\n所以我们可以将余数减去一个除数，同时将商+1。由于除数（绝对值）肯定是大于余数的，此时余数就会转换成正数。\n下面是具体实现的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void slove(int n, int r) { if (n == 0) return; int m = n % r; // m为余数 if (m \u0026lt; 0) // 如果余数小于0，转化为正数 m -= r, n += r; //商+1 =\u0026gt; 被除数+除数 if (m \u0026gt;= 10) m = \u0026#39;A\u0026#39; + m - 10; else m += \u0026#39;0\u0026#39;; slove(n / r, r); putchar(m); } 位运算 位运算的基本概念在组成原理这些课上已经讲过不知道多少遍了，这里就只提一下我觉得重要的点。\n位运算共有6种，分别是：与(\u0026amp;)、或(|)、异或(^)、取反(~)、左移(\u0026lt;\u0026lt;)和右移(\u0026gt;\u0026gt;)。\n这里要特别注意一下右移运算，它分为逻辑右移和算术右移：\n算术右移时，高位补最高位 逻辑右移时，高位补0 在C++中，数据类型包含有符号类型和无符号类型，其中有符号类型使用关键字 signed 声明，无符号类型使用关键字 unsigned 声明，两个关键字都不使用时，默认是有符号类型。对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。\n在学习和刷题时，我们容易发现，左移运算对应乘法运算。将一个数左移 $k$ 位，等价于将这个数乘以 $2^k$。例如，$29$ 左移 $2$ 位的结果是 $116$，等价于 $29 \\times 4$。\n算术右移运算对应除法运算。将一个数右移 $k$ 位，相当于将这个数除以 $2^k$。例如，$50$ 右移 $2$ 位的结果是 $12$，等价于 $50 / 4$，结果向下取整。\n这里要注意，对于负数，整数除法是向 $0$ 取整，右移运算是向下取整，两者就不相同了。例如，$(-50)\u0026raquo;2$的结果是 $−13$，而 $(-50) / 4$ 的结果是$-12$，两者是不相等的。\n参考资料 位运算和数学 - LeetBook ","date":"2022-04-03T09:45:04+08:00","image":"https://lbqaq.top/p/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/95490521.webp","permalink":"https://lbqaq.top/p/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/","title":"进制转换和位运算"},{"content":"最近看了很多篇关于如何刷题的文章，其中都不约而同的提到了\u0026quot;总结\u0026quot;这个关键词。仔细想想自己确实是从来没有做过一篇总结，刷过的题目就过去了，导致同样的题目再做一次又不会了。\n我的第一篇总结就以最近刷到的「区间求和」问题展开吧。首先，先上一般问题的模板（其中加粗的为最佳方案）：\n数组不变，区间查询：前缀和、树状数组、线段树； 数组单点修改，区间查询：树状数组、线段树； 数组区间修改，单点查询：差分、线段树； 数组区间修改，区间查询：线段树。 前缀和 前缀和的作用就是为了帮助我们快速求某一段的和，是「差分」的逆运算。\n前缀和数组的每一位记录的是当前位置距离起点位置，这连续一段的和区间和。\n一维前缀和 假设有一个一维数组$x$和该数组的一维前缀和数组$y$，则$x$和$y$满足以下关系：\n$$y_0=x_0、y_1=x_0+x_1、y_2=x_0+x_1+x_2、......、y_n=x_0+x_1+...+x_n$$所以我们可以通过 $y_n=y_{n-1}+x_n$ 这个公式计算出前缀和，代码实现如下：\n1 2 3 4 for (int i = 0; i \u0026lt; n; i++) { if (i == 0) y[i] = x[i]; else y[i] = y[i - 1] + x[i]; } 但是在实际使用中，常常会遇到左边界溢出的情况，为了避免这种情况，我们可以将前缀和数组整体向后移动一位，下面给出前缀给计算代码：\n1 2 3 4 int n = x.size(); vector\u0026lt;int\u0026gt; y(n + 1); for (int i = 1; i \u0026lt;= n; i++) y[i] = y[i - 1] + x[i - 1]; 这样当我们想求区间$[a,b]$之和时只需要计算$y[b+1]-y[a]$即可。\n二维前缀和 有一个二维数组$a$和该数组的二维前缀和数组$b$（其同样是个二维数组)\n右侧标注橙色的二维前缀和元素，其值是左侧的原二维数组中标注橙色的所有元素的和。\n二维前缀和实际上就是一个矩阵内值的和，而矩阵又可以由两个行数或列数少一的子矩阵组合后，删去重合部分再加上右下角的值来构成，也就是以下式子：\n$$b_{x,y}=b_{x-1,y}+b_{x,y-1}-b_{x-1,y-1}+a_{x,y}$$详细的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 for (int y = 0; y \u0026lt; n; y++) // n行 for (int x = 0; x \u0026lt; m; x++) // m列 { if (x == 0 \u0026amp;\u0026amp; y == 0) b[y][x] = a[y][x]; //左上角的值 else if (x == 0) b[y][x] = b[y - 1][x] + a[y][x]; //第一列 else if (y == 0) b[y][x] = b[y][x - 1] + a[y][x]; //第一行 else b[y][x] = b[y - 1][x] + b[y][x - 1] - b[y - 1][x - 1] + a[y][x]; } 通过二维前缀和，我们可以很方便的计算出给定矩阵的和，即上面求前缀和的逆运算。假设所求矩阵的左上角点为$(x1,y1)$，右下角点为$(x2,y2)$，则有公式：\n$sum=B[y2][x2]+B[y1-1][x1-1]-B[y1-1][x2]-B[y2][x1-1]$\n这里结合图形会更好理解一点。\n例题 力扣303. 区域和检索 - 数组不可变\n就是一维前缀和的模板题，直接上模板即可做出。\n差分 差分是一种处理数据的巧妙而简单的方法，它应用于区间的修改和询问问题。如果我们要经常对数组A某个区间内的所有元素做相同的加减操作，如果一个一个修改效率很差，但是使用差分数组后，这个操作的时间复杂度就能降到$\\Omicron(1)$,当所有的修改操作结束后，再利用差分数组，计算出新的A。\n一维差分 我们定义原数组为$a[]$、差分数组为$D[]$，则有计算公式：$D[k]=a[k]-a[k-1]$,即原数组$a[]$的相邻元素的差。从定义我们可以推出$a[k]=D[0]+D[1]+\u0026hellip;+D[k]$。也就是说$a[]$是$D[]$的前缀和，所以「差分」和「前缀和」就是一组逆运算。\n当我们想要对区间$[L,R]$每个元素加上$d$，则只要进行下面的两步操作：\n1 2 D[L] += d; D[R+1] -= d; 当所有修改都完成时，我们可以通过复杂度为$\\Omicron(n)$的操作计算出新的$a[]$\n当然，差分也不是万能的，它只能解决 区间修改+单点查询 这类问题。当遇到需要多次查询的问题，比如有$m$次修改，$k$次查询，此时修改的复杂度为$\\Omicron(m)$,查询的复杂度为$\\Omicron(kn)$，总复杂度为$\\Omicron(m+kn)$，和暴力法$\\Omicron(mn+k)$的复杂度一致了。\n二维差分 从一维差分可以很容易的推广到二维差分，我们可以通过下面的公式计算$D[][]$：\n$$D[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$$我们想修改坐标点$(x1,y1)$~$(x2,y2)$定义的区间，则需要修改矩阵的四个点：\n1 2 3 4 D[y1][x1] += d; //二维区间的起点 D[y1][x2+1] -= d; //把y看成常数，x从x1到x2+1 D[y2+1][x1] -= d; //把x看成常数，y从y1到y2+1 D[y2+1][x2+1] += d; //由于前两式把d减了2次，多减了1次，这里加1次回来 前缀和$a[][]$的计算可以用下面的公式：\n$$a[i][j]=D[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1]$$在计算$a[][]$时，我们可以不新开一个数组，而是以用过的$D[][]$作为$a[][]$，以此来节约空间。使用的话只需要将上面式子中的$a$全部换为$D$\n树状数组 树状数组的优点在于查询和修改的时间复杂度都为$\\Omicron(logn)$，且比线段树好写。\n单点修改、区间查询 树状数组的原理由于时间有限，这里就不展开说了（之后有空再补上😇），先上模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int c[MAXN];\t//树状数组(下标从1开始) int n;\t//数组的长度 inline int lowbit(int i) { return i \u0026amp; (-i); } //在位置i加上k void update(int i, int k) { while (i \u0026lt;= n) { c[i] += k; i += lowbit(i); } } //求A[1]~A[i]的和 int getsum(int i) { int res = 0; while (i \u0026gt; 0) { res += c[i]; i -= lowbit(i); } return res; } 这里一定要注意，树状数组和原数组下标都是从1开始的。\n由此就解决了单点修改、区间查询的问题，我们想要得到区间$(a,b)$的和，只需使用getsum(b) - getsum(a - 1)。\n例题：P3374【模板】树状数组 1\n区间修改、单点查询 在上面的差分中我们分析了，如果有多次查询，仅仅使用差分的时间复杂度就和暴力差不多了。这时，我们可以采用树状数组+差分的方法。\n我们将上面模板中的原始数组改为差分数组。由差分的性质可知，当我们修改一个区间时，只需要修改区间的两个端点即可，此时区间修改的问题便被转化成了单点修改的问题。同时，树状数组前n项和也就变成了原数组第n项的值。\n例题：P3368【模板】树状数组 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //前面还是树状数组的模板，这里就不放了 int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int pre = 0, now; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; now; //这里每次求差分来生成树状数组 update(i, now - pre); pre = now; } while (m--) { int a, x, y, k; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; x; if (a == 1) { cin \u0026gt;\u0026gt; y \u0026gt;\u0026gt; k; //更新即为对D[X]、D[y+1]进行修改 update(x, k); update(y + 1, -k); } else if (a == 2) { //求D[1]~D[i]的和,即A[i]的值 cout \u0026lt;\u0026lt; getsum(x) \u0026lt;\u0026lt; endl; } } system(\u0026#34;pause\u0026#34;); return 0; } 参考资料 【朝夕的ACM笔记】算法基础-前缀和 差分 \u0026ndash;算法竞赛专题解析（32） 关于各类「区间和」问题如何选择解决方案（含模板） 树状数组详解 ","date":"2022-03-14T20:46:19+08:00","image":"https://lbqaq.top/p/%E5%88%9D%E6%8E%A2%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/95680357.webp","permalink":"https://lbqaq.top/p/%E5%88%9D%E6%8E%A2%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/","title":"初探区间求和问题"},{"content":"题目类型 选择（10分） 10题 填空（10分） 10题 问答（30分） 4题 编程题（30分） 3-4题 综合题（20分） 上机题整理 这里只存放核心的代码，完整的程序见Gitee仓库\n使用Maven 通过使用Maven可以让程序自动配置和导入包，不必自己手动配置和导入，非常方便，推荐大家使用。\n我的配置文件已经把考试会用的包都导入了，包括Servlet、JSP、JSTL、MySQl驱动，版本都已经调整为最佳，保证开箱即用。\n新建项目，选择Maven，直接下一步\n填写项目名称和目录位置，其他的可填可不填\n在pom.xml文件增加这样一句\u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt;\n接着粘贴下面的代码，并点击右上角的图标应用（或者使用快捷键Ctrl+Shift+O）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;dependencies\u0026gt; \u0026lt;!-- servlet 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jsp 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet.jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jstl --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp.jstl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- standard标签库 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;taglibs\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;standard\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 在左边src的main这个目录下建立一个名叫webapp的目录，再这下面建立一个名叫WEB-INF的目录，再在其中建立web.xml这个文件\n在里面填入下面的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--默认启用EL表达式--\u0026gt; \u0026lt;jsp-config\u0026gt; \u0026lt;jsp-property-group\u0026gt; \u0026lt;url-pattern\u0026gt;*.jsp\u0026lt;/url-pattern\u0026gt; \u0026lt;el-ignored\u0026gt;false\u0026lt;/el-ignored\u0026gt; \u0026lt;/jsp-property-group\u0026gt; \u0026lt;/jsp-config\u0026gt; \u0026lt;/web-app\u0026gt; 这样就配置好了，如果你还是觉得麻烦，可以下载我这个配置好的懒人包，解压即可使用，注意在IDEA打开时要选择“信任MAVEN项目”，否则无法生效。\nServlet生成三角形 正三角\n1 2 3 4 5 6 7 8 9 for (int i = 0; i \u0026lt; num; i++) { for (int j = 0; j \u0026lt; num - i; j++) { out.print(\u0026#34;\u0026amp;nbsp;\u0026#34;); } for (int k = 0; k \u0026lt;= i * 2; k++) { out.print(\u0026#34;*\u0026#34;); } out.println(\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;); } 倒三角\n1 2 3 4 5 6 7 8 9 for (int i = num; i \u0026gt; 0; i--) { for (int j = num - i; j \u0026gt; 0; j--) { out.print(\u0026#34;\u0026amp;nbsp;\u0026#34;); } for (int k = (i * 2) - 1; k \u0026gt; 0; --k) { out.print(\u0026#34;*\u0026#34;); } out.println(\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;); } JSP生成乘法表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;% String s = request.getParameter(\u0026#34;num\u0026#34;); int num = Integer.parseInt(\u0026#34;\u0026#34;.equals(s) ? \u0026#34;0\u0026#34; : s); for (int i = 1; i \u0026lt;= num; i++) { out.println(\u0026#34;\u0026lt;tr\u0026gt;\u0026#34;); for (int j = 1; j \u0026lt;= num; j++) { if (j \u0026lt;= i) { out.println(\u0026#34;\u0026lt;td\u0026gt;\u0026#34; + i + \u0026#34;*\u0026#34; + j + \u0026#34;=\u0026#34; + i * j + \u0026#34;\u0026lt;/td\u0026gt;\u0026#34;); }else{ out.println(\u0026#34;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026#34;); } } out.println(\u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;); } %\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; 登录界面，三次禁用 数据用数组存储application，但我没使用，如果要使用可以调用request.getServletContext()\n用户信息存在session\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @WebServlet(name = \u0026#34;Servlet3\u0026#34;, value = \u0026#34;/Servlet3\u0026#34;) public class Servlet3 extends HttpServlet { private static final String[] USER_NAME = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; private static final String[] PASSWORD = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;}; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String username = req.getParameter(\u0026#34;username\u0026#34;); String password = req.getParameter(\u0026#34;password\u0026#34;); if (username == null || password == null || \u0026#34;\u0026#34;.equals(username) || \u0026#34;\u0026#34;.equals(password)) { req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;用户名或密码不能为空！\u0026#34;); req.getRequestDispatcher(\u0026#34;/3.jsp\u0026#34;).forward(req, resp); return; } HttpSession mySession = req.getSession(); int errTime = (int) (mySession.getAttribute(\u0026#34;errTime\u0026#34;) == null ? 0 : mySession.getAttribute(\u0026#34;errTime\u0026#34;)); Date dbDate = (Date) mySession.getAttribute(\u0026#34;dbDate\u0026#34;); Date nowDate = new Date(); if (errTime \u0026gt;= 3) { if (dbDate.after(nowDate)) { req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;您被禁止登录！\u0026#34;); req.getRequestDispatcher(\u0026#34;/3.jsp\u0026#34;).forward(req, resp); return; } else { errTime = 0; } } int i; for (i = 0; i \u0026lt; USER_NAME.length; i++) { if (username.equals(USER_NAME[i]) \u0026amp;\u0026amp; password.equals(PASSWORD[i])) { errTime = 0; req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;登陆成功！\u0026#34;); break; } } if(i\u0026gt;=USER_NAME.length) { errTime += 1; if (errTime \u0026gt;= 3) { //单位为毫秒 nowDate.setTime(nowDate.getTime() + 1 * 60 * 1000); } req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;用户名或密码错误！\u0026#34;); } mySession.setAttribute(\u0026#34;errTime\u0026#34;, errTime); mySession.setAttribute(\u0026#34;dbDate\u0026#34;,nowDate); req.getRequestDispatcher(\u0026#34;/3.jsp\u0026#34;).forward(req, resp); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 用户认证 不使用Filter\n1 2 3 4 5 6 7 \u0026lt;% Object username = session.getAttribute(\u0026#34;username\u0026#34;); if(username==null){ request.setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;您没有登陆\u0026#34;); request.getRequestDispatcher(\u0026#34;/4-1.jsp\u0026#34;).forward(request,response); } %\u0026gt; 使用Filter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //filterName：过滤器名称 urlPatterns：过滤的范围 过滤全部为\u0026#34;/*\u0026#34; @WebFilter(filterName = \u0026#34;Filter4\u0026#34;, urlPatterns = \u0026#34;/4-3.jsp\u0026#34;) public class Filter4 implements Filter { public void init(FilterConfig config) throws ServletException {} public void destroy() {} @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; Object username = req.getSession().getAttribute(\u0026#34;username\u0026#34;); if (username == null) { req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;您没有登陆\u0026#34;); req.getRequestDispatcher(\u0026#34;/4-1.jsp\u0026#34;).forward(req, resp); } else { chain.doFilter(request, response); } } } 录入用户信息并回显 如姓名爱好（checkbox数组）提交后，在界面上显示提交的信息\n修改数据时，如何将原数据显示在表单中也在此段中。特别是select radio\n使用EL表达式即可\n注意点：\ncheckbox传递的值为数组，需使用request.getParameterValues(\u0026quot;b\u0026quot;);获取 可以将数组转换为列表，方便使用相关方法 List\u0026lt;String\u0026gt; list = Arrays.asList(strArray); 只能查看，不支持修改和删除 ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(Arrays.asList(strArray)); 可以修改和删除 checkbox和radio选中为checked；select中的option为selected 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;${pageContext.request.contextPath}/Servlet5\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;a\u0026#34;\u0026gt;文本框\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;a\u0026#34; name=\u0026#34;a\u0026#34; value=\u0026#34;${A}\u0026#34;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;label for=\u0026#34;b\u0026#34;\u0026gt;多选框\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;b\u0026#34; name=\u0026#34;b\u0026#34; value=\u0026#34;1\u0026#34; ${BL.contains(\u0026#34;1\u0026#34;)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;b\u0026#34; value=\u0026#34;2\u0026#34; ${BL.contains(\u0026#34;2\u0026#34;)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;b\u0026#34; value=\u0026#34;3\u0026#34; ${BL.contains(\u0026#34;3\u0026#34;)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;label for=\u0026#34;c1\u0026#34;\u0026gt;单选框 4\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;c1\u0026#34; name=\u0026#34;c\u0026#34; value=\u0026#34;4\u0026#34; ${\u0026#34;4\u0026#34;.equals(C)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;label for=\u0026#34;c2\u0026#34;\u0026gt;单选框 5\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;c2\u0026#34; name=\u0026#34;c\u0026#34; value=\u0026#34;5\u0026#34; ${\u0026#34;5\u0026#34;.equals(C)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;label for=\u0026#34;d\u0026#34;\u0026gt;下拉框\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;d\u0026#34; id=\u0026#34;d\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;6\u0026#34; ${\u0026#34;6\u0026#34;.equals(D)?\u0026#34;selected\u0026#34;:\u0026#34;\u0026#34;}\u0026gt;6\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;7\u0026#34; ${\u0026#34;7\u0026#34;.equals(D)?\u0026#34;selected\u0026#34;:\u0026#34;\u0026#34;}\u0026gt;7\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;8\u0026#34; ${\u0026#34;8\u0026#34;.equals(D)?\u0026#34;selected\u0026#34;:\u0026#34;\u0026#34;}\u0026gt;8\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 请求转发、重定向，实现传值 请求转发：\nrequest.setAttribute(\u0026quot;D\u0026quot;, d); 或者存放到Session里request.getSession().setAttribute(\u0026quot;D\u0026quot;, d); 重定向：\n只能放在Session里 或者通过构造URL参数传递，如response.sendRedirect(\u0026quot;/1.jsp?a=\u0026quot;+a+\u0026quot;\u0026amp;b=\u0026quot;+b); 在servlet如何使用jsp:usebean jsp来接收form内的值 jsp中使用下面的代码\n1 2 \u0026lt;jsp:useBean id=\u0026#34;s\u0026#34; class=\u0026#34;yzu.calc\u0026#34; scope=\u0026#34;request\u0026#34; /\u0026gt; \u0026lt;jsp:setProperty name=\u0026#34;s\u0026#34; property=\u0026#34;*\u0026#34; /\u0026gt; servlet中使用\n1 2 request.getRequestDispatcher(\u0026#34;getForm.jsp\u0026#34;).include(request,response); calc mybean=(calc)request.getAttribute(\u0026#34;s\u0026#34;); 从web表单接收数据 request.getParameter request.getParameterValues 数据库实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 private static final String DRIVER = \u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;; private static final String URL = \u0026#34;jdbc:mysql://localhost:3306/web?serverTimezone=Asia/Shanghai\u0026amp;characterEncoding=utf-8\u0026#34;; private static final String USERNAME = \u0026#34;root\u0026#34;; private static final String PASSWORD = \u0026#34;root\u0026#34;; //加载驱动 try { Class.forName(DRIVER); connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); } catch (Exception e) { e.printStackTrace(); } if (connection != null) { String sql = \u0026#34;select * from user where name=?\u0026#34;; PreparedStatement pstm = null; ResultSet rs = null; try { //加载SQL语句 pstm = connection.prepareStatement(sql); //填入变量 pstm.setObject(1, username); //执行SQL（查询） rs = pstm.executeQuery(); //执行SQL（增删改） updateRows = pstm.executeUpdate(); //读取数据（多行使用while） if (rs.next()) { dbPassword = rs.getString(\u0026#34;password\u0026#34;); dbDate = new Date(rs.getTimestamp(\u0026#34;time\u0026#34;).getTime()); dbErrorTime = rs.getInt(\u0026#34;error_count\u0026#34;); } //释放资源 rs.close(); pstm.close(); connection.close(); }SQLException (e) { e.printStackTrace(); } 注册用户 多个信息 不懂什么意思，有懂哥可以评论区留言\nDB CRUD查询组合查询不需要分页 见上面\n用会话对象实现购物车的CRUD商品名称，单价，数量购物车列表，总价 具体代码见仓库Servlet6\n问答题 C/S B/S优缺点 C/S架构\n全称是Client/Server，即客户端服务器端架构\n优点：\nC/S架构的界面和操作可以很丰富。 安全性能可以很容易保证，实现多层认证也不难。 由于只有一层交互，因此响应速度较快。 缺点：\n适用面窄，通常用于局域网中。 用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户。 维护成本高，发生一次升级，则所有客户端的程序都需要改变。 B/S架构\n全称为Browser/Server，即浏览器/服务器结构。\n优点：\n客户端无需安装，有Web浏览器即可。 BS架构可以直接放在广域网上，通过一定的权限控制实现多客户访问的目的，交互性较强。 BS架构无需升级多个客户端，升级服务器即可。 缺点：\n在跨浏览器上，BS架构不尽如人意。 表现要达到CS程序的程度需要花费不少精力。 在速度和安全性上需要花费巨大的设计成本，这是BS架构的最大问题。 JSTL EL JDBC VO DAO MVC JSP中英文全称 JSTL:Java server pages standarded tag library，JSP标准标签库 EL:Expression Language,EL表达式 JDBC:Java Database Connectivity,Java数据库连接 VO:Value Object,值对象 DAO:Data Access Object,数据库访问对象 MVC:Model View Controller,模型 视图 控制器 JSP:Java Server Pages,JAVA服务器页面 多层架构的优点 高内聚低耦合，便于团队开发\n内聚：一个模块内各个元素彼此结合的紧密程度；\n耦合：一个软件结构内不同模块之间关联程度的度量。\n在团队开发中，分层可以让软件开发人员专注于自己负责的层，而不必关心其他层的设计，也不必担心自己的设计会影响其它层。如果不分层，根本不可能进行团队开发，只会一团糟。\n使软件升级和维护更为容易\n分层设计使得程序结构清晰，升级和维护都变得十分容易，更改层的具体实现代码，只要层接口保持稳定，其他层可以不必修改。即使层的接口发生变化，也只影响上层和下层，修改工作量小而且错误可以控制，不会带来意外的风险。\nMVC的特点和优点 MVC主要分模型、视图、控制器三层。\n模型(model)\n它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性\n视图(view)\n用户与之交互的界面、在 web 中视图一般由 jsp,html 组成\n控制器(controller)\n接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用\n优点：\n降低代码耦合性。在 MVC 模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。 有利于分工合作。在 MVC 模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的 JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。 有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。 GET、POST特点和优缺点 GET\n查询字符串（名称/值对）是在GET请求的URL中发送的\n优点：\nGET请求可被缓存 GET请求速度快 GET请求可被收藏为书签 GET请求保留在浏览器历史记录中 缺点：\nGET请求不安全 GET请求有url长度限制 POST\n查询字符串（名称/值对）是在POST请求的HTTP消息主体中发送的\n优点：\nPOST请求对数据长度没有要求 POST请求相对GET请求更安全 缺点：\nPOST请求不会被缓存 POST请求速度慢 重定向与请求转发的优缺点 实现的核心代码 重定向\n优点：\n不限制应用范围，可以重定向到服务器内部其他资源，也可以是外部的应用 缺点：\n重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间 核心代码：response.sendRedirect(\u0026quot;请求地址\u0026quot;)\n请求转发\n优点：\n安全性高，在内部发生跳转，浏览器地址不变 转发只需要一次请求，就可以访问至少两个servlet或jsp页面。 缺点：\n只能在同一web应用内使用，不能转发到外部的url地址。 核心代码：request.getRequestDispatcher(\u0026quot;URL地址\u0026quot;).forward(request, response)\nJSP Servlet 区别与联系 区别：\njsp更擅长表现于页面显示,servlet更擅长于逻辑控制。 Servlet中没有内置对象，Jsp中有内置对象。 Servlet在Java代码中通过HttpServletResponse对象动态输出HTML内容；JSP在静态HTML内容中嵌入Java代码，Java代码被动态执行后生成HTML内容 联系：\njsp是对servlet的一种高级封装。本质还是servlet。 jsp会由TomCat自动编译成“类servlet”。 JSP内置对象 对象 描述 request HttpServletRequest 接口的实例 response HttpServletResponse 接口的实例 out JspWriter类的实例，用于把结果输出至网页上 session HttpSession类的实例 application ServletContext类的实例，与应用上下文有关 config ServletConfig类的实例 pageContext PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问 page 类似于Java类中的this关键字 Exception Exception类的对象，代表发生错误的JSP页面中对应的异常对象 JavaBean相关动作标记有哪些，用代码说明之 语法 描述 jsp:useBean 寻找或者实例化一个JavaBean。 jsp:setProperty 设置JavaBean的属性。 jsp:getProperty 输出某个JavaBean的属性。 \u0026lt;jsp:useBean id = \u0026quot;name\u0026quot; class = \u0026quot;package.class\u0026quot; scope= \u0026quot;page | request | session | application\u0026quot; /\u0026gt;\n其中：\n1）id\n表示 Bean 实例化对象的变量名，可以在指定范围内使用该变量名。\n2）class\n表示需要实例化 Bean 的类路径，指定的类必须包含 public 且无参数的构造方法。\n3）scope\n指定 Bean 的作用域，取值为：\npage：只能在当前页面使用该 Bean 对象； request：只能在一次请求范围内使用该 Bean 对象； session：只能在一次会话范围内使用该 Bean 对象； application：可以在整个应用范围内使用该 Bean 对象。 \u0026lt;jsp:setProperty name = \u0026quot;beanName\u0026quot; property = \u0026quot;attributeName\u0026quot; value = \u0026quot;attributeValue\u0026quot;/\u0026gt;\n\u0026lt;jsp:setProperty\u0026gt; 通常和 \u0026lt;jsp:useBean\u0026gt; 一起使用，分为两种情况。\n在 \u0026lt;jsp:useBean\u0026gt; 标签外使用\u0026lt;jsp:setProperty\u0026gt;\n以上情况，无论 \u0026lt;jsp:useBean\u0026gt; 是否实例化了 User 对象，\u0026lt;jsp:setProperty\u0026gt; 都会执行。\n在 \u0026lt;jsp:useBean\u0026gt; 标签里使用 \u0026lt;jsp:setProperty\u0026gt;\n只有 \u0026lt;jsp:useBean\u0026gt; 实例化了 User 对象，\u0026lt;jsp:setProperty\u0026gt; 才会执行\n\u0026lt;jsp:getProperty name = \u0026quot;beanName\u0026quot; property = \u0026quot;attributeName\u0026quot;\u0026gt;\n其中，name 指定需要获取属性的 Bean 的名称；property 指定 Bean 的属性，即 Bean 类中的属性。\n当 property 的取值为 * 时，要求 Bean 属性的名称与类型要与 request 请求中参数的名称及类型一致，以便用 Bean 中的属性来接收客户输入的数据，系统会根据名称来自动匹配。\n注意：\u0026lt;jsp:setProperty\u0026gt; 和 \u0026lt;jsp:getProperty\u0026gt; 动作都会按照 page、request、session 和 application 的顺序依次查找指定 Bean 的实例对象，直到第一个实例被找到。如果任何范围内都不存在这个 Bean 实例，则会拋出异常。\nEL与作用城相关的隐含对象有哪些 内置对象 说明 pageScope 获取 page 范围的变量 requestScope 获取 request 范围的变量 sessionScope 获取 session 范围的变量 applicationScope 获取 application 范围的变量 param 相当于 request.getParameter(String name)，获取单个参数的值 paramValues 相当于 request.getParameterValues(String name)，获取参数集合中的变量值 header 相当于 request.getHeader(String name)，获取 HTTP 请求头信息 headerValues 相当于 request.getHeaders(String name)，获取 HTTP 请求头数组信息 initParam 相当于 application.getInitParameter(String name)，获取 web.xml 文件中的参数值 cookie 相当于 request.getCookies()，获取 cookie 中的值 pageContext 表示当前 JSP 页面的 pageContext 对象 EL 表达式可以输出 4 种属性范围的内容。如果在不同的属性范围中设置了同一个属性名称，则按照 page、request、session、application 的顺序依次查找。\n${person.name} person存放在request属性中person对象的类yzu.Person，对象的java代码是什么(JavaBean) \u0026lt;%=((yzu.Person)request.getAttribute(\u0026quot;person\u0026quot;)).getName()%\u0026gt;\n过滤器与Servlet区别与联系，他有什么作用 过滤器（Filter）：对Request请求起到过滤的作用，作用在Servlet之前\nServlet：处理Request请求和Response响应\nJava和JSP的区别 Java是一种通用的计算机编程语言，它是并发的，基于类的，面向对象的，并且专门设计为具有尽可能少的实现依赖性。而JSP是一种技术，可帮助软件开发人员基于HTML，XML或其他文档类型创建动态生成的Web页面。 Java applet是使用Java编程语言编写的。JSP使用“scriptlet元素”（Java代码）和“标记”（通常是HTML或XML）的混合编程，以提供数据驱动（“动态”）网页。 Java为面向对象语言，JSP可以理解为一种脚本 Java主要负责逻辑，业务处理，而JSP主要负责页面展现 JSP的本质是servlet，而servlet的本质是Java类 JSP开发的优点 将内容的生成和显示分离\n借助jsp技术，web页面发开人员可以使用html或者xml标签来设计和格式化最终页面，使用jsp标签或者脚本程序来生成动态web页面的内容（页面的内容是根据请求来变化的，例如，请求账户信息或者特定的一本书的价格）。生成内容的逻辑被封装在标签和javabean组件中，并且捆绑在脚本程序中，所有的脚本程序在服务器端运行。因此，其他人能够方便地编辑和使用jsp页面，而不影响内容的生成。\n强调可重用的组件\njsp页面可借助可重用的、跨平台的组件来执行应用程序所要求的极为复杂的业务逻辑。开发人员能够共享和交换执行普通操作的组件，或者让这些组件被别的开发人员或开发团队所使用。基于组件的方法加速了总体开发进程，并且使得各种组织在他们现有的技能和优化结果的开发努力中得到平衡。\n采用标签简化页面开发\n通过使用jsp提供的标准标签库，web页面开发人员能够访问和实例化javabean组件、设置或者检索组件属性、下载applet以及执行用其他方法更难于编码和耗时的功能。此外，web页面开发人员还可以为常用功能创建自己的标签库，这是的web页面开发人员能够使用熟悉的工具盒如同标签一样的执行特定功能的构件来工作。\n一次编写、处处运行\n由于jsp页面的内置脚本是基于java语言的，而且所有的jsp页面都被编译为java servlet，因此jsp页面就具有java技术的所有好处，包括健壮性和安全性等。作为java平台的一部分，jsp拥有java语言“一次编写，处处运行”的特点。jsp几乎可以运行于所有的平台，如windows nt、linux、unix等。\n更高的效率和安全性\njsp程序在执行之前先被编译成字节码文件，字节码文件有java虚拟机解释执行，比源代码解释的效率高。此外，服务器端还有字节码的cache机构，能提高字节码的访问效率。第一次调用jsp网页可能稍慢，因为它被编译成cache，以后就快的多了。同时，jsp源程序不大可能被下载，特别是javabean程序，完全可能放到不对外的目录中。\n","date":"2022-01-03T19:52:31+08:00","image":"https://lbqaq.top/p/javawebexam/92462192.webp","permalink":"https://lbqaq.top/p/javawebexam/","title":"JavaWeb期末复习"},{"content":"新番“先审后播”政策已经实行了快半年了，现在看来在哔哩哔哩上追番的体验已经没有之前那样舒适了，更不用提还有好多番剧连上线都没有上线。这时本地看番就成了一个比较不错的选择了。这篇文章就记录以下这段时间我本地追番使用的工具和网站，大家也可以以此为参照，打造属于自己的追番体验。\n找番 “巧妇难为无米之炊”，没有片源的话，本文使用的一切工具也就无从谈起了。下面我就列举几个我知道的找番网址：\n（推荐）萌番组\n只能说是良心网站了，国内可以直连，支持RSS订阅和筛选\n動漫花園\n老牌网站了，国内无法直连，但分享内容不止番剧，还有音乐等内容\nNyaa\n一般是英文资源，可做为备用网站\n下载 找到了需要的资源（一般都是BT链接），下一步就是下载了，这里我推荐qBittorrent，我认为是BT下载的最优解了。Windows平台我建议选择增强版qBittorrent-Enhanced-Edition\n对于新番来说，速度基本是不慢的。但如果要下载旧番的话，如果分享的人不多的话速度就不太理想了。\n面对这种情况我知道的有这样几种解决方法：\n使用115等支持离线的网盘\n这里我推荐一个安卓的APP，叫PikPak。由于是新出的，现在有会员免费领取的活动，可以无限次离线+3T空间。我个人测试了一下离线成功率和下载速度还是不错的，乘现在还能白嫖就多用用吧_(:з)∠)_\n租一台国外的VPS，先在上面下载好再转存到国内（因为有些资源分享的人在国内无法连接到，所以这个方法才有用😂）\n看看百度云等网盘上有没有人分享\n使用PT，当然这个难度过大了，就连我也没整过😇\n播放 说到本地播放器，那就不得不提到PotPlayer的大名了，这基本是播放器的最优解了，在这里我就不过多阐述它的优点了，我主要是想提一提另外的一款播放器——弹弹play\n相比PotPlayer，它最大的优点就是支持弹幕的播放。在看了这么多年的B站以后，现在看番不带弹幕就觉得缺了些什么，这款播放器就很好的解决了我这个痛点。当然它的功能不止这些，比如可以配置自动下载、开启远程访问等等。但我一般不会让一个播放器后台常驻+开机自启的，所以这些功能对我来说并没有多大的作用。\n当然还是有缺点的，比如不能像pakku那样将重复弹幕合并成一条大弹幕，使用自带的重复弹幕屏蔽会有肉眼可见的弹幕消失等BUG。不过瑕不掩瑜，这款播放器我还是很推荐的。\n补帧 终于到这个环节了，这才是我写这篇文章的主要动力。\n国际惯例，先来一段名词解释：\n帧数(Frames)，为帧生成数量的简称。由于口语习惯上的原因，我们通常将帧数与帧率混淆。每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象，因此高的帧率可以得到更流畅、更逼真的动画。\n而帧率（Frame rate）是用于测量显示帧数的量度。所谓的测量单位为每秒显示帧数(Frames per Second，简称：FPS）或“赫兹”（Hz）。此词多用于影视制作和电子游戏。\n所以说补帧就是将低帧率的视频通过一定的算法提升到高帧率。直观来看，就是画面变得更加流畅丝滑了，还不理解的话可以看下面的动图或者看看极客湾的这期视频，通过不同帧率的对比能有个更清晰的认识。\n当然，上面的视频中使用的是AI补帧，对显卡和时间要求都十分高。我们正常看番是用不到这些的。这里就列举本地实时插帧的三款软件。\nAMD Fluid Motion SVP dmitriRender 硬件需求 支持此功能的A卡 无 高性能的显卡 是否收费 免费 收费（可试用） 收费（可试用） 正版体验 / 优秀 较差 配置难度 不知道 复杂 简单 支持格式 全部 不支持HEVC 全部 至于补帧效果，我感觉对于动漫dmitriRender要比SVP要好一点。当然由于动漫的画面一般不具有逻辑连续，所以还是会有一点虚影的，不过不影响观看。\n两款软件的正版激活体验来说，还是SVP比较好，不限次数反激活，支持官网反激活。而dmitriRender不但不支持官网反激活，而且只有20次反激活的限制，更要命的是如果系统重装、硬件更新都可能会掉激活，贴吧上也有好多丢失激活的情况。\ndmitriRender的官网售价是$15.00（我当时买的是12刀，居然涨价了）\nSVP的官网售价是$19.99（太贵了，等黑五促销再说）\nSVP是支持支付宝付款的，而dmitriRender需要一张信用卡\n不过，上面两块软件都有爱心分享版，这里就不直接写出来了（避免查水表），如果有需要可以在评论里留言。\n小结 这篇文章还是拖更了好久，每次在心里列下想写的内容，一到电脑前就懒得动手了😭之后一定会补上两款补帧软件的安装和配置方法。\n","date":"2021-10-26T15:39:41+08:00","image":"https://lbqaq.top/p/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%9C%8B%E7%95%AA/90624322.webp","permalink":"https://lbqaq.top/p/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%9C%8B%E7%95%AA/","title":"如何优雅的看番"},{"content":"最近把服务器重装成Ubuntu了，所以要重装MySQL，没想到在这里踩了好几个坑，在这里记录下来备忘。\n安装 这其实很简单，直接通过Ubuntu的包管理器直接安装就行了（我把系统转为Ubuntu也有这方面的原因）。\n1 sudo apt-get install mysql-server 通过这条命令安装的MySQL的root账号是没有密码的，所以只要输入mysql就直接可以进入了\n开启远程访问 这里就是本文的重点了，我在这里花了很多时间😇\n设定MySQL的监听端口 通过apt安装的MySQL默认是只监听本地的端口的，我们要修改使其监听所有ip地址的请求。\n1 2 3 4 vim /etc/mysql/mysql.conf.d/mysqld.cnf #把bind - address后面的127.0.0.1改为0.0.0.0 #重启MySQL服务器 systemctl restart mysql 设置root账号密码并开启远程访问 默认root账号是没有密码的，这当然是不行的，我们需要给一个密码\n1 2 3 4 use mysql; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;新的密码\u0026#39;; update user set host = \u0026#39;%\u0026#39; where user=\u0026#39;root\u0026#39;; flush privileges; 还要注意把防火墙的3306端口放行，这样就可以实现MySQL的远程访问了。\n","date":"2021-10-21T10:19:52+08:00","image":"https://lbqaq.top/p/mysql8%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/90561040.webp","permalink":"https://lbqaq.top/p/mysql8%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","title":"MySQL8开启远程访问"},{"content":"在我现在在做的项目中需要进行身份和权限认证，在网上找了些教程，推荐都是使用JWT来进行身份认证，于是便决定使用此方法来实现。（然而用完了才发现JWT也有缺点）\n何为JWT 所谓JWT，全称是JSON Web Token。下面是从官网摘抄的定义：\nJWT是一个开放的标准（RFC 7519），它定义了一种紧凑和独立的方式，以JSON对象的形式在各方之间安全地传输信息。这种信息可以被验证和信任，因为它是经过数字签名的。JWTs可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公共/私人密钥对进行签名。\n按我的理解，JWT其实就是将传统的session认证中的token存储位置从服务器上下发给用户，服务器只需要判断传来的token是否合法而无需存储。这样做的好处就是可以做分布式的服务器，无需考虑用户是在哪一台服务器上登录的。\n详细的定义和构成我这里就不展开了，这里主要关注JWT中Payload（载荷）。这是有效信息存放的地方，我们一般关注这里就行了。\n下面是官方提供且建议（并不强制）使用的声明：\niss: jwt签发者\nsub: 主题\naud: 接收jwt的一方\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\nnbf: 生效时间，在此时间之前该jwt都是不可用的.\niat: jwt的签发时间\njti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n当然，在载荷中还可以存放自定义的信息，在本项目中使用官方提供的就足以了，故不展开。\n认证流程 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 具体实现 导入依赖包 第一步当然是导入相关依赖了，使用Maven进行包管理。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- shiro --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jwt --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.auth0\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java-jwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.18.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 封装JWT工具类 这里主要实现JWT的生成、验证、提取用户名三个功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @Slf4j public class JwtUtil { /** * 服务器私钥 */ private static final Algorithm ALGORITHM = Algorithm.HMAC256(\u0026#34;test\u0026#34;); /** * 生成JSON Web Token * * @param username 用户名 * @param issuer 签发者 * @param subject 面向主体 * @param ttlMillis 生效时长(单位:毫秒) */ public static String creatJwt(String username, String issuer, String subject, long ttlMillis) { long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); JWTCreator.Builder builder = JWT.create() .withAudience(username) .withIssuedAt(now) .withSubject(subject) .withIssuer(issuer); if (ttlMillis \u0026gt;= 0) { long expMillis = nowMillis + ttlMillis; Date exp = new Date(expMillis); builder.withExpiresAt(exp); } return builder.sign(ALGORITHM); } /** * 生成JSON Web Token * * @param username 用户名 * @param issuer 签发者 * @param subject 面向主体 * @param expDate 失效日期 */ public static String creatJwt(String username, String issuer, String subject, Date expDate) { Date now = new Date(); JWTCreator.Builder builder = JWT.create() .withAudience(username) .withIssuedAt(now) .withSubject(subject) .withIssuer(issuer); if (now.before(expDate)) { builder.withExpiresAt(expDate); } return builder.sign(ALGORITHM); } /** * 获取签发对象 * * @param token 需要解密的token * @return 解密后获得的对象，失败返回null */ public static String getAudience(String token) { String audience; try { audience = JWT.decode(token).getAudience().get(0); } catch (JWTDecodeException exception) { log.error(\u0026#34;输入的token无法解析\u0026#34;); return null; } return audience; } /** * 验证token是否正确 * * @param token 需要验证的token * @return 通过验证返回true，反之抛出异常 */ public static Boolean verifyToken(String token) throws JWTVerificationException { JWTVerifier verifier = JWT.require(ALGORITHM).build(); verifier.verify(token); return true; } } 配置Shiro 这里的ShiroConfig.java与一般Shiro项目的配置有以下几点不同：\n禁用Session 使用自定义的jwtFilter过滤器，用来拦截并处理携带JWT token的请求 使用自定义的Realm认证器，用于验证用户是否存在及查询用户权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Configuration public class ShiroConfig { @Autowired private MyRealm myRealm; @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager() { DefaultWebSecurityManager manger = new DefaultWebSecurityManager(); manger.setRealm(myRealm); // 关闭shiro自带的session DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO(); subjectDAO.setSessionStorageEvaluator(sessionStorageEvaluator()); manger.setSubjectDAO(subjectDAO); return manger; } @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager manger) { ShiroFilterFactoryBean bean = new CustomShiroFilterFactoryBean(); bean.setSecurityManager(manger); Map\u0026lt;String, Filter\u0026gt; filterMap = new HashMap\u0026lt;\u0026gt;(); filterMap.put(\u0026#34;jwt\u0026#34;, getJwtFilter()); bean.setFilters(filterMap); Map\u0026lt;String, String\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); //设置过滤规则，anon表示无需认证，其余的请求都通过自定义的jwt认证器 map.put(\u0026#34;/\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/v3/api-docs\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/swagger-resources/**\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/unauthorized/**\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/**\u0026#34;, \u0026#34;jwt\u0026#34;); bean.setFilterChainDefinitionMap(map); bean.setLoginUrl(\u0026#34;/login\u0026#34;); // 设置无权限时跳转的 url bean.setUnauthorizedUrl(\u0026#34;/unauthorized/无权限\u0026#34;); return bean; } public JwtFilter getJwtFilter() { return new JwtFilter(); } /** * 开启注解代理 */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; } /** * 禁用session, 不保存用户登录状态。保证每次请求都重新认证 */ @Bean protected SessionStorageEvaluator sessionStorageEvaluator() { DefaultSessionStorageEvaluator sessionStorageEvaluator = new DefaultSessionStorageEvaluator(); sessionStorageEvaluator.setSessionStorageEnabled(false); return sessionStorageEvaluator; } } 自定义Token 由于使用了JWT当token，自然要写自定义的Token\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class JwtToken implements AuthenticationToken { private String token; public JwtToken(String token) { this.token = token; } @Override public Object getPrincipal() { return token; } @Override public Object getCredentials() { return token; } } 自定义过滤器 由于使用了JWT，所以不能使用shiro中自带的过滤器，而是自定义自己的过滤器 JWTFilter，JWTFilter 继承了 BasicHttpAuthenticationFilter，并部分原方法进行了重写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Slf4j public class JwtFilter extends BasicHttpAuthenticationFilter { @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { //判断请求的请求头是否带上 \u0026#34;Token\u0026#34; if (isLoginAttempt(request, response)) { //如果存在，则进入 executeLogin 方法执行登入，检查 token 是否正确 try { executeLogin(request, response); return true; } catch (Exception e) { //token 错误 responseError(response, e.getMessage()); } } //如果请求头不存在 Token，则可能是执行登陆操作或者是游客状态访问，无需检查 token，直接返回 true return true; } /** * 判断用户是否想要登入。 * 检测 header 里面是否包含 Token 字段 */ @Override protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) { HttpServletRequest req = (HttpServletRequest) request; String token = req.getHeader(\u0026#34;Token\u0026#34;); return token != null; } @Override protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception { HttpServletRequest httpServletRequest = (HttpServletRequest) request; String token = httpServletRequest.getHeader(\u0026#34;Token\u0026#34;); JwtToken jwtToken = new JwtToken(token); // 提交给realm进行登入，如果错误他会抛出异常并被捕获 getSubject(request, response).login(jwtToken); // 如果没有抛出异常则代表登入成功，返回true return true; } /** * 将非法请求跳转到 /unauthorized/** */ private void responseError(ServletResponse response, String message) { try { HttpServletResponse httpServletResponse = (HttpServletResponse) response; //设置编码，否则中文字符在重定向时会变为空字符串 message = URLEncoder.encode(message, \u0026#34;UTF-8\u0026#34;); //允许跨域请求 httpServletResponse.setHeader(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \u0026#34;true\u0026#34;); httpServletResponse.setHeader(\u0026#34;Access-Control-Allow-Methods\u0026#34;, \u0026#34;GET, POST\u0026#34;); httpServletResponse.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); httpServletResponse.setHeader(\u0026#34;Access-Control-Max-Age\u0026#34;, \u0026#34;3600\u0026#34;); httpServletResponse.sendRedirect(\u0026#34;/unauthorized/\u0026#34; + message); } catch (IOException e) { log.error(e.getMessage()); } } } 该过滤器有这几大步骤：\n检验请求头是否带有Token 如果带有 token，执行 shiro 的 login() 方法，将 token 提交到 Realm 中进行检验；如果没有 token，说明当前状态为游客状态（或者其他一些不需要进行认证的接口） 如果在 token 校验的过程中出现错误，如 token 校验失败，那么我会将该请求视为认证不通过，则重定向到 /unauthorized/** 自定义Realm 这里主要是进行身份认证和权限认证\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @Component public class MyRealm extends AuthorizingRealm { @Autowired UserService userService; @Autowired RoleService roleService; @Autowired PermissionService permissionService; @Override public boolean supports(AuthenticationToken token) { return token instanceof JwtToken; } /** * 权限认证 * 只有当需要检测用户权限的时候才会调用此方法，例如checkRole,checkPermission之类的 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { String userName = (String) principals.iterator().next(); Set\u0026lt;String\u0026gt; roles = roleService.getAllRoleByUserName(userName); Set\u0026lt;String\u0026gt; permissions = permissionService.getAllPermissionByUserName(userName); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.setRoles(roles); info.setStringPermissions(permissions); return info; } /** * 身份认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { JwtToken jwtToken = (JwtToken) token; String jwtTokenPrincipal = (String) jwtToken.getPrincipal(); String userName = JwtUtil.getAudience(jwtTokenPrincipal); if (userName == null) { throw new AuthenticationException(\u0026#34;token认证失败！\u0026#34;); } try { JwtUtil.verifyToken(jwtTokenPrincipal); } catch (JWTDecodeException e) { throw new AuthenticationException(\u0026#34;不是有效的JWT格式\u0026#34;); } catch (SignatureVerificationException e) { throw new AuthenticationException(\u0026#34;无效的签名\u0026#34;); } catch (TokenExpiredException e) { throw new AuthenticationException(\u0026#34;token已过期\u0026#34;); } User user = userService.getUserByUserName(userName); if (user == null) { throw new AuthenticationException(\u0026#34;该用户不存在！\u0026#34;); } return new SimpleAuthenticationInfo(userName, jwtTokenPrincipal, user.getUserId()); } } 这里有个细节，在Controller中要求进行身份认证时，Shiro会自动把上面doGetAuthenticationInfo方法中返回的Info存起来。这样我们就可以在Controller中调用这里面的值了。\nuserName可以通过(String) SecurityUtils.getSubject().getPrincipal()取出来\nuserId可以通过SecurityUtils.getSubject().getPrincipals().getRealmNames().iterator().next()取出来。当然，这里根据Shiro的设计，SimpleAuthenticationInfo的第三个构造参数应该填入RealmName，用来区分用户该使用哪一个Realm进行验证的。但我这个项目就只有一个Realm，所以在这里就偷了个懒，就没按官方标准来了。\n异常处理 第一个是专门处理身份认证时的异常\n1 2 3 4 5 @ApiOperation(value = \u0026#34;接收未授权错误\u0026#34;, notes = \u0026#34;返回错误信息\u0026#34;) @GetMapping(\u0026#34;/unauthorized/{message}\u0026#34;) public Result unauthorized(@PathVariable String message) { return new Result().setCode(233).setMessage(message); } 第二个则是全局接管Shiro的异常，在其中进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RestControllerAdvice public class ExceptionController { /** * 捕捉shiro的异常 */ @ExceptionHandler(ShiroException.class) public Result handle401(ShiroException e) { Result result = new Result(); result.setCode(666); if(e instanceof UnauthenticatedException){ result.setMessage(\u0026#34;您没有登录！\u0026#34;); }else if(e instanceof UnauthorizedException){ result.setMessage(\u0026#34;您没有权限访问！\u0026#34;); } else { result.setMessage(e.toString()); } return result; } } 解决中文报错 在Shiro1.7版本之后增加了url校验，如果有中文字符就不通过。然而我们项目里返回错误信息就是通过url来实现的。参考这篇文章知道，需要自己重写ShiroFilterFactoryBean来实现关闭url校验\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class CustomShiroFilterFactoryBean extends ShiroFilterFactoryBean { @Override protected FilterChainManager createFilterChainManager() { FilterChainManager manager = super.createFilterChainManager(); // URL携带中文400，servletPath中文校验bug Map\u0026lt;String, Filter\u0026gt; filterMap = manager.getFilters(); Filter invalidRequestFilter = filterMap.get(DefaultFilter.invalidRequest.name()); if (invalidRequestFilter instanceof InvalidRequestFilter) { ((InvalidRequestFilter) invalidRequestFilter).setBlockNonAscii(false); } return manager; } } 开始使用 身份认证在Controller上添加@RequiresAuthentication 角色认证在Controller上添加@RequiresRoles(\u0026quot;xxx\u0026quot;) 权限认证在Controller上添加@RequiresPermissions(\u0026quot;xxx\u0026quot;) 测试 测试接口的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @GetMapping(\u0026#34;/test\u0026#34;) @ResponseBody public Result test() { return new Result().setCode(200).setMessage(\u0026#34;当你看到这段话时，说明服务成功运行了\u0026#34;); } @GetMapping(\u0026#34;/test2\u0026#34;) @ResponseBody @RequiresPermissions(\u0026#34;user:insert\u0026#34;) public Result test2() { return new Result().setCode(200).setMessage(\u0026#34;当你看到这段话时，说明你已经通过了验证\u0026#34;); } @GetMapping(\u0026#34;/test3\u0026#34;) @ResponseBody @RequiresPermissions(\u0026#34;noBody\u0026#34;) public Result test3() { return new Result().setCode(200).setMessage(\u0026#34;当你看到这段话时，说明认证系统出现了问题\u0026#34;); } 参考文章 教你 Shiro + SpringBoot 整合 JWT Shiro步步为营\u0026ndash;如何优雅地与JWT集成 更新日志 2021.11.7：\n增加解决跳转时的跨域请求 更细粒度的展示JWT错误原因 增加SecurityUtils的使用 增加测试接口的代码 ","date":"2021-10-08T15:19:44+08:00","image":"https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/92388693.webp","permalink":"https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/","title":"shiro整合JWT"},{"content":"最近看了很久的Vue教程，为了避免之后的遗忘，还是停下脚步，花点时间讲笔记写出来吧。\n这篇笔记是基于B站上的尚硅谷Vue2.0+Vue3.0全套教程而成，在此感谢提供这么优秀的学习教程。\nVue2基础 想要学好Vue，那肯定还是从Vue2开始学起。那么这一章主要是Vue2中的基础内容，没有使用到脚手架。\n初识Vue 每学一个新的语言，HelloWord是必不可少的。话不多说，上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!-- 准备好一个容器 --\u0026gt; \u0026lt;div id=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hello，{{name.toUpperCase()}}，{{address}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; \u0026gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 //创建Vue实例 new Vue({ el:\u0026#39;#demo\u0026#39;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。 data:{ //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。 name:\u0026#39;vue\u0026#39;, address:\u0026#39;北京\u0026#39; } }) \u0026lt;/script\u0026gt; 这样就完成了一个基础的Vue程序。\n1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；\n2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；\n3.root容器里的代码被称为【Vue模板】；\n4.Vue实例和容器是一一对应的；\n5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；\n6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；\n7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；\nVue模板语法 Vue模板语法有2大类：\n1.插值语法：\n​ 功能：用于解析标签体内容。\n​ 写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。\n2.指令语法：\n​ 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件\u0026hellip;..）。\n​ 举例：v-bind:href=\u0026ldquo;xxx\u0026rdquo; 或 简写为 :href=\u0026ldquo;xxx\u0026rdquo;，xxx同样要写js表达式，\n​ 且可以直接读取到data中的所有属性。\n​ 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。\n其实很好理解，想要显示在页面上的内容就使用{{value}}这样的写法，而v-bind:则是用于html标签中的属性绑定。\n数据绑定 Vue中有2种数据绑定的方式：\n​ 1.单向绑定(v-bind)：数据只能从data流向页面。\n​ 2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。\n​ 备注：\n​ 1.双向绑定一般都应用在表单类元素上（如：input、select等）\n​ 2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。\n1 2 3 4 5 6 7 \u0026lt;!-- 普通写法 --\u0026gt; 单向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-bind:value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 双向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-model:value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 简写 --\u0026gt; 单向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 双向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; el与data的两种写法 data与el的2种写法\n​ 1.el有2种写法\n​ (1).new Vue时候配置el属性。\n​ (2).先创建Vue实例，随后再通过vm.$mount(\u0026rsquo;#root\u0026rsquo;)指定el的值。\n1 2 3 4 5 6 7 const v = new Vue({ //el:\u0026#39;#root\u0026#39;, //第一种写法 data:{ name:\u0026#39;Vue\u0026#39; } }) v.$mount(\u0026#39;#root\u0026#39;) //第二种写法 ​ 2.data有2种写法\n​ (1).对象式\n​ (2).函数式\n​ 如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 new Vue({ el:\u0026#39;#root\u0026#39;, //data的第一种写法：对象式 /* data:{ name:\u0026#39;Vue\u0026#39; } */ //data的第二种写法：函数式 data(){ console.log(\u0026#39;@@@\u0026#39;,this) //此处的this是Vue实例对象 return{ name:\u0026#39;Vue\u0026#39; } } }) ​ 3.一个重要的原则：\n​ 由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。\n数据代理 在讲Vue中的数据代理之前，先讲一下js中Object.defineproperty方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 let number = 18 let person = { name:\u0026#39;张三\u0026#39;, sex:\u0026#39;男\u0026#39;, } Object.defineProperty(person,\u0026#39;age\u0026#39;,{ // value:18, // enumerable:true, //控制属性是否可以枚举，默认值是false // writable:true, //控制属性是否可以被修改，默认值是false // configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get(){ console.log(\u0026#39;有人读取age属性了\u0026#39;) return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value){ console.log(\u0026#39;有人修改了age属性，且值是\u0026#39;,value) number = value } }) // 输出person中所有的key // console.log(Object.keys(person)) console.log(person) 通过Object.defineProperty添加进的属性，默认是不可枚举、不可修改、不可删除的，可以通过上面的三条配置项，让其和普通的属性一样。\n所谓数据代理，就是指通过一个对象代理对另一个对象中属性的操作（读/写）。\n1.Vue中的数据代理：\n​ 通过vm对象来代理data对象中属性的操作（读/写）\n2.Vue中数据代理的好处：\n​ 更加方便的操作data中的数据\n3.基本原理：\n​ 通过Object.defineProperty()把data对象中所有属性添加到vm上。\n​ 为每一个添加到vm上的属性，都指定一个getter/setter。\n​ 在getter/setter内部去操作（读/写）data中对应的属性。\n1 2 3 4 5 6 7 const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ name:\u0026#39;Vue\u0026#39;, password:123 } }) 通过在控制台查看vm，可以发现data中的数据都通过数据代理在vm身上了\n事件处理 事件的基本使用：\n​ 1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；\n​ 2.事件的回调需要配置在methods对象中，最终会在vm上；\n​ 3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；\n​ 4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；\n​ 5.@click=\u0026ldquo;demo\u0026rdquo; 和 @click=\u0026ldquo;demo($event)\u0026rdquo; 效果一致，但后者可以传参；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Hello,{{name}}\u0026lt;/h2\u0026gt; \u0026lt;!-- \u0026lt;button v-on:click=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/button\u0026gt; --\u0026gt; \u0026lt;button @click=\u0026#34;showInfo1\u0026#34;\u0026gt;点我提示信息1（不传参）\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showInfo2($event,66)\u0026#34;\u0026gt;点我提示信息2（传参）\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ name:\u0026#39;Vue\u0026#39;, }, methods:{ showInfo1(event){ // console.log(event.target.innerText) // console.log(this) //此处的this是vm alert(\u0026#39;同学你好！\u0026#39;) }, showInfo2(event,number){ console.log(event,number) // console.log(event.target.innerText) // console.log(this) //此处的this是vm alert(\u0026#39;同学你好！！\u0026#39;) } } }) \u0026lt;/script\u0026gt; Vue中的事件修饰符：\n​ 1.prevent：阻止默认事件（常用）；\n​ 2.stop：阻止事件冒泡（常用）；\n​ 3.once：事件只触发一次（常用）；\n​ 4.capture：使用事件的捕获模式；\n​ 5.self：只有event.target是当前操作的元素时才触发事件；\n​ 6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 阻止默认事件（常用） --\u0026gt; \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; @click.prevent=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/a\u0026gt; \u0026lt;!-- 阻止事件冒泡（常用） --\u0026gt; \u0026lt;div class=\u0026#34;demo1\u0026#34; @click=\u0026#34;showInfo\u0026#34;\u0026gt; \u0026lt;button @click.stop=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/button\u0026gt; \u0026lt;!-- 修饰符可以连续写 --\u0026gt; \u0026lt;!-- \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; @click.prevent.stop=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/a\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 事件只触发一次（常用） --\u0026gt; \u0026lt;button @click.once=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/button\u0026gt; 1.Vue中常用的按键别名：\n​ 回车 =\u0026gt; enter\n​ 删除 =\u0026gt; delete (捕获“删除”和“退格”键)\n​ 退出 =\u0026gt; esc\n​ 空格 =\u0026gt; space\n​ 换行 =\u0026gt; tab (特殊，必须配合keydown去使用)\n​ 上 =\u0026gt; up\n​ 下 =\u0026gt; down\n​ 左 =\u0026gt; left\n​ 右 =\u0026gt; right\n2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）\n3.系统修饰键（用法特殊）：ctrl、alt、shift、meta\n​ (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n​ (2).配合keydown使用：正常触发事件。\n4.也可以使用keyCode去指定具体的按键（不推荐）\n5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\n一般都是@keydown.xxx或者@keyup.xxx来绑定按键\n计算属性 计算属性：\n​ 1.定义：要用的属性不存在，要通过已有属性计算得来。\n​ 2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。\n​ 3.get函数什么时候执行？\n​ (1).初次读取时会执行一次。\n​ (2).当依赖的数据发生改变时会被再次调用。\n​ 4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。\n​ 5.备注：\n​ 1.计算属性最终会出现在vm上，直接读取使用即可。\n​ 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ firstName:\u0026#39;张\u0026#39;, lastName:\u0026#39;三\u0026#39;, x:\u0026#39;你好\u0026#39; }, computed:{ fullName:{ //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值 //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。 get(){ console.log(\u0026#39;get被调用了\u0026#39;) // console.log(this) //此处的this是vm return this.firstName + \u0026#39;-\u0026#39; + this.lastName }, //set什么时候调用? 当fullName被修改时。 set(value){ console.log(\u0026#39;set\u0026#39;,value) const arr = value.split(\u0026#39;-\u0026#39;) this.firstName = arr[0] this.lastName = arr[1] } } } }) 计算属性调用就和普通属性的调用一样，用{{key}}就行了。\n当我们不需要计算属性的set方法时，我们就可以使用简写方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ firstName:\u0026#39;张\u0026#39;, lastName:\u0026#39;三\u0026#39;, }, computed:{ //简写 fullName(){ console.log(\u0026#39;get被调用了\u0026#39;) return this.firstName + \u0026#39;-\u0026#39; + this.lastName } } }) 监视属性 监视属性watch：\n1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作\n2.监视的属性必须存在，才能进行监视！！\n3.监视的两种写法：\n​ (1).new Vue时传入watch配置\n​ (2).通过vm.$watch监视\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;今天天气很{{info}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeWeather\u0026#34;\u0026gt;切换天气\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ isHot:true, }, computed:{ info(){ return this.isHot ? \u0026#39;炎热\u0026#39; : \u0026#39;凉爽\u0026#39; } }, methods: { changeWeather(){ this.isHot = !this.isHot } }, /* watch:{ isHot:{ immediate:true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时。 handler(newValue,oldValue){ console.log(\u0026#39;isHot被修改了\u0026#39;,newValue,oldValue) } } } */ }) vm.$watch(\u0026#39;isHot\u0026#39;,{ immediate:true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时。 handler(newValue,oldValue){ console.log(\u0026#39;isHot被修改了\u0026#39;,newValue,oldValue) } }) \u0026lt;/script\u0026gt; 深度监视：\n​ (1).Vue中的watch默认不监测对象内部值的改变（一层）。\n​ (2).配置deep:true可以监测对象内部值改变（多层）。\n备注：\n​ (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！\n​ (2).使用watch时根据数据的具体结构，决定是否采用深度监视。\n计算属性也同样可以简写：\n1 2 3 4 5 6 watch:{ //简写 isHot(newValue,oldValue){ console.log(\u0026#39;isHot被修改了\u0026#39;,newValue,oldValue,this) } } computed和watch之间的区别：\n​ 1.computed能完成的功能，watch都可以完成。\n​ 2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。\n两个重要的小原则：\n​ 1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。\n​ 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，\n​ 这样this的指向才是vm 或 组件实例对象。\n绑定样式 绑定样式：\nclass样式\n写法:class=\u0026ldquo;xxx\u0026rdquo; xxx可以是字符串、对象、数组。\n字符串写法适用于：类名不确定，要动态获取。\n对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\nstyle样式\n:style=\u0026quot;{fontSize: xxx}\u0026ldquo;其中xxx是动态值。\n:style=\u0026quot;[a,b]\u0026ldquo;其中a、b是样式对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;mood\u0026#34; @click=\u0026#34;changeMood\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;classArr\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;classObj\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定style样式--对象写法 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :style=\u0026#34;styleObj\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定style样式--数组写法 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :style=\u0026#34;styleArr\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.config.productionTip = false const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ name:\u0026#39;尚硅谷\u0026#39;, mood:\u0026#39;normal\u0026#39;, classArr:[\u0026#39;atguigu1\u0026#39;,\u0026#39;atguigu2\u0026#39;,\u0026#39;atguigu3\u0026#39;], classObj:{ atguigu1:false, atguigu2:false, }, styleObj:{ fontSize: \u0026#39;40px\u0026#39;, color:\u0026#39;red\u0026#39;, }, styleObj2:{ backgroundColor:\u0026#39;orange\u0026#39; }, styleArr:[ { fontSize: \u0026#39;40px\u0026#39;, color:\u0026#39;blue\u0026#39;, }, { backgroundColor:\u0026#39;gray\u0026#39; } ] }, methods: { changeMood(){ const arr = [\u0026#39;happy\u0026#39;,\u0026#39;sad\u0026#39;,\u0026#39;normal\u0026#39;] const index = Math.floor(Math.random()*3) this.mood = arr[index] } }, }) \u0026lt;/script\u0026gt; 条件渲染 条件渲染：\n​ 1.v-if\n​ 写法：\n​ (1).v-if=\u0026ldquo;表达式\u0026rdquo;\n​ (2).v-else-if=\u0026ldquo;表达式\u0026rdquo;\n​ (3).v-else=\u0026ldquo;表达式\u0026rdquo;\n​ 适用于：切换频率较低的场景。\n​ 特点：不展示的DOM元素直接被移除。\n​ 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。\n​ 2.v-show\n​ 写法：v-show=\u0026ldquo;表达式\u0026rdquo;\n​ 适用于：切换频率较高的场景。\n​ 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉\n​ 3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- 使用v-show做条件渲染 --\u0026gt; \u0026lt;h2 v-show=\u0026#34;false\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2 v-show=\u0026#34;1 === 1\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 使用v-if做条件渲染 --\u0026gt; \u0026lt;h2 v-if=\u0026#34;1 === 1\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2 v-if=\u0026#34;false\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;!-- v-else和v-else-if --\u0026gt; \u0026lt;div v-if=\u0026#34;n === 1\u0026#34;\u0026gt;Angular\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;n === 2\u0026#34;\u0026gt;React\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;n === 3\u0026#34;\u0026gt;Vue\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- v-if与template的配合使用 --\u0026gt; \u0026lt;template v-if=\u0026#34;n === 1\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;你好\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;尚硅谷\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;北京\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; 列表渲染 基本列表 v-for指令:\n​ 1.用于展示列表数据\n​ 2.语法：v-for=\u0026quot;(item, index) in xxx\u0026rdquo; :key=\u0026ldquo;yyy\u0026rdquo;\n​ 3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;!-- 遍历数组 --\u0026gt; \u0026lt;h2\u0026gt;人员列表（遍历数组）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(p,index) of persons\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{p.name}}-{{p.age}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 遍历对象 --\u0026gt; \u0026lt;h2\u0026gt;汽车信息（遍历对象）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value,k) of car\u0026#34; :key=\u0026#34;k\u0026#34;\u0026gt; {{k}}-{{value}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 遍历字符串 --\u0026gt; \u0026lt;h2\u0026gt;测试遍历字符串（用得少）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(char,index) of str\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{char}}-{{index}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 遍历指定次数 --\u0026gt; \u0026lt;h2\u0026gt;测试遍历指定次数（用得少）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(number,index) of 5\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{index}}-{{number}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; new Vue({ el:\u0026#39;#root\u0026#39;, data:{ persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;张三\u0026#39;,age:18}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;李四\u0026#39;,age:19}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;王五\u0026#39;,age:20} ], car:{ name:\u0026#39;奥迪A8\u0026#39;, price:\u0026#39;70万\u0026#39;, color:\u0026#39;黑色\u0026#39; }, str:\u0026#39;hello\u0026#39; } }) \u0026lt;/script\u0026gt; 面试题：react、vue中的key有什么作用？（key的内部原理）\n虚拟DOM中key的作用： ​ key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,\n​ 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：\n​ 2.对比规则：\n​ (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：\n​ ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！\n​ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。\n​ (2).旧虚拟DOM中未找到与新虚拟DOM相同的key\n​ 创建新的真实DOM，随后渲染到到页面。\n​ 3. 用index作为key可能会引发的问题：\n​ 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:\n​ 会产生没有必要的真实DOM更新 ==\u0026gt; 界面效果没问题, 但效率低。\n​ 2. 如果结构中还包含输入类的DOM：\n​ 会产生错误DOM更新 ==\u0026gt; 界面有问题。\n​ 4. 开发中如何选择key?:\n​ 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。\n​ 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，\n​ 使用index作为key是没有问题的。\n列表过滤 可以通过watch或者computed实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;人员列表\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入名字\u0026#34; v-model=\u0026#34;keyWord\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(p,index) of filPerons\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{p.name}}-{{p.age}}-{{p.sex}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.config.productionTip = false //用watch实现 //#region new Vue({ el:\u0026#39;#root\u0026#39;, data:{ keyWord:\u0026#39;\u0026#39;, persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;马冬梅\u0026#39;,age:19,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;周冬雨\u0026#39;,age:20,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;周杰伦\u0026#39;,age:21,sex:\u0026#39;男\u0026#39;}, {id:\u0026#39;004\u0026#39;,name:\u0026#39;温兆伦\u0026#39;,age:22,sex:\u0026#39;男\u0026#39;} ], filPerons:[] }, watch:{ keyWord:{ immediate:true, handler(val){ this.filPerons = this.persons.filter((p)=\u0026gt;{ return p.name.indexOf(val) !== -1 }) } } } }) //#endregion //用computed实现 new Vue({ el:\u0026#39;#root\u0026#39;, data:{ keyWord:\u0026#39;\u0026#39;, persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;马冬梅\u0026#39;,age:19,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;周冬雨\u0026#39;,age:20,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;周杰伦\u0026#39;,age:21,sex:\u0026#39;男\u0026#39;}, {id:\u0026#39;004\u0026#39;,name:\u0026#39;温兆伦\u0026#39;,age:22,sex:\u0026#39;男\u0026#39;} ] }, computed:{ filPerons(){ return this.persons.filter((p)=\u0026gt;{ return p.name.indexOf(this.keyWord) !== -1 }) } } }) \u0026lt;/script\u0026gt; 列表排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;人员列表\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入名字\u0026#34; v-model=\u0026#34;keyWord\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;sortType = 2\u0026#34;\u0026gt;年龄升序\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;sortType = 1\u0026#34;\u0026gt;年龄降序\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;sortType = 0\u0026#34;\u0026gt;原顺序\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(p,index) of filPerons\u0026#34; :key=\u0026#34;p.id\u0026#34;\u0026gt; {{p.name}}-{{p.age}}-{{p.sex}} \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.config.productionTip = false new Vue({ el:\u0026#39;#root\u0026#39;, data:{ keyWord:\u0026#39;\u0026#39;, sortType:0, //0原顺序 1降序 2升序 persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;马冬梅\u0026#39;,age:30,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;周冬雨\u0026#39;,age:31,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;周杰伦\u0026#39;,age:18,sex:\u0026#39;男\u0026#39;}, {id:\u0026#39;004\u0026#39;,name:\u0026#39;温兆伦\u0026#39;,age:19,sex:\u0026#39;男\u0026#39;} ] }, computed:{ filPerons(){ const arr = this.persons.filter((p)=\u0026gt;{ return p.name.indexOf(this.keyWord) !== -1 }) //判断一下是否需要排序 if(this.sortType){ arr.sort((p1,p2)=\u0026gt;{ return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age }) } return arr } } }) \u0026lt;/script\u0026gt; Vue监视数据的原理：\nvue会监视data中所有层次的数据。\n如何监测对象中的数据？\n​ 通过setter实现监视，且要在new Vue时就传入要监测的数据。\n​ (1).对象中后追加的属性，Vue默认不做响应式处理\n​ (2).如需给后添加的属性做响应式，请使用如下API：\n​ Vue.set(target，propertyName/index，value) 或\n​ vm.$set(target，propertyName/index，value)\n如何监测数组中的数据？ ​ 通过包裹数组更新元素的方法实现，本质就是做了两件事：\n​ (1).调用原生对应的方法对数组进行更新。\n​ (2).重新解析模板，进而更新页面。\n4.在Vue修改数组中的某个元素一定要用如下方法：\n​ 1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n​ 2.Vue.set() 或 vm.$set()\n特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！\n收集表单数据 若：\u0026lt;input type=\u0026quot;text\u0026quot;/\u0026gt;，则v-model收集的是value值，用户输入的就是value值。\n若：\u0026lt;input type=\u0026quot;radio\u0026quot;/\u0026gt;，则v-model收集的是value值，且要给标签配置value值。\n若：\u0026lt;input type=\u0026quot;checkbox\u0026quot;/\u0026gt;\n​ 1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n​ 2.配置input的value属性:\n​ (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n​ (2)v-model的初始值是数组，那么收集的的就是value组成的数组\n备注：v-model的三个修饰符：\n​ lazy：失去焦点再收集数据\n​ number：输入字符串转为有效的数字\n​ trim：输入首尾空格过滤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;form @submit.prevent=\u0026#34;demo\u0026#34;\u0026gt; 账号：\u0026lt;input type=\u0026#34;text\u0026#34; v-model.trim=\u0026#34;userInfo.account\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;userInfo.password\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 年龄：\u0026lt;input type=\u0026#34;number\u0026#34; v-model.number=\u0026#34;userInfo.age\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 性别： 男\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; v-model=\u0026#34;userInfo.sex\u0026#34; value=\u0026#34;male\u0026#34;\u0026gt; 女\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; v-model=\u0026#34;userInfo.sex\u0026#34; value=\u0026#34;female\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 爱好： 学习\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34; value=\u0026#34;study\u0026#34;\u0026gt; 打游戏\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34; value=\u0026#34;game\u0026#34;\u0026gt; 吃饭\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34; value=\u0026#34;eat\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 所属校区 \u0026lt;select v-model=\u0026#34;userInfo.city\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;请选择校区\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;beijing\u0026#34;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;shanghai\u0026#34;\u0026gt;上海\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;shenzhen\u0026#34;\u0026gt;深圳\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;wuhan\u0026#34;\u0026gt;武汉\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 其他信息： \u0026lt;textarea v-model.lazy=\u0026#34;userInfo.other\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.agree\u0026#34;\u0026gt;阅读并接受\u0026lt;a href=\u0026#34;http://www.atguigu.com\u0026#34;\u0026gt;《用户协议》\u0026lt;/a\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; new Vue({ el:\u0026#39;#root\u0026#39;, data:{ userInfo:{ account:\u0026#39;\u0026#39;, password:\u0026#39;\u0026#39;, age:18, sex:\u0026#39;female\u0026#39;, hobby:[], city:\u0026#39;beijing\u0026#39;, other:\u0026#39;\u0026#39;, agree:\u0026#39;\u0026#39; } }, methods: { demo(){ console.log(JSON.stringify(this.userInfo)) } } }) \u0026lt;/script\u0026gt; 过滤器 过滤器：\n定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。\n语法：\n​ 1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}\n​ 2.使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \u0026ldquo;xxx | 过滤器名\u0026rdquo;\n备注：\n​ 1.过滤器也可以接收额外参数、多个过滤器也可以串联\n​ 2.并没有改变原本的数据, 是产生新的对应的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;显示格式化后的时间\u0026lt;/h2\u0026gt; \u0026lt;!-- 计算属性实现 --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{fmtTime}}\u0026lt;/h3\u0026gt; \u0026lt;!-- methods实现 --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{getFmtTime()}}\u0026lt;/h3\u0026gt; \u0026lt;!-- 过滤器实现 --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{time | timeFormater}}\u0026lt;/h3\u0026gt; \u0026lt;!-- 过滤器实现（传参） --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{time | timeFormater(\u0026#39;YYYY_MM_DD\u0026#39;) | mySlice}}\u0026lt;/h3\u0026gt; \u0026lt;h3 :x=\u0026#34;msg | mySlice\u0026#34;\u0026gt;尚硅谷\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;root2\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{msg | mySlice}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.filter(\u0026#39;mySlice\u0026#39;,function(value){ return value.slice(0,4) }) new Vue({ el:\u0026#39;#root\u0026#39;, data:{ time:1621561377603, //时间戳 msg:\u0026#39;你好，尚硅谷\u0026#39; }, computed: { fmtTime(){ return dayjs(this.time).format(\u0026#39;YYYY年MM月DD日 HH:mm:ss\u0026#39;) } }, methods: { getFmtTime(){ return dayjs(this.time).format(\u0026#39;YYYY年MM月DD日 HH:mm:ss\u0026#39;) } }, //局部过滤器 filters:{ timeFormater(value,str=\u0026#39;YYYY年MM月DD日 HH:mm:ss\u0026#39;){ // console.log(\u0026#39;@\u0026#39;,value) return dayjs(value).format(str) } } }) new Vue({ el:\u0026#39;#root2\u0026#39;, data:{ msg:\u0026#39;hello,atguigu!\u0026#39; } }) \u0026lt;/script\u0026gt; 内置指令 我们学过的指令：\n​ v-bind : 单向绑定解析表达式, 可简写为 :xxx\n​ v-model : 双向数据绑定\n​ v-for : 遍历数组/对象/字符串\n​ v-on : 绑定事件监听, 可简写为@\n​ v-if : 条件渲染（动态控制节点是否存存在）\n​ v-else : 条件渲染（动态控制节点是否存存在）\n​ v-show : 条件渲染 (动态控制节点是否展示)\nv-text指令：\n​ 1.作用：向其所在的节点中渲染文本内容。\n​ 2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。\nv-html指令：\n​ 1.作用：向指定节点中渲染包含html结构的内容。\n​ 2.与插值语法的区别：\n​ (1).v-html会替换掉节点中所有的内容，{{xx}}则不会。\n​ (2).v-html可以识别html结构。\n​ 3.严重注意：v-html有安全性问题！！！！\n​ (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。\n​ (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！\nv-cloak指令（没有值）：\n​ 1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。\n​ 2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。\nv-once指令：\n​ 1.v-once所在节点在初次动态渲染后，就视为静态内容了。\n​ 2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。\nv-pre指令：\n​ 1.跳过其所在节点的编译过程。\n​ 2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。\n生命周期 话不多说先上图：\n生命周期：\n​ 1.又名：生命周期回调函数、生命周期函数、生命周期钩子。\n​ 2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。\n​ 3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n​ 4.生命周期函数中的this指向是vm 或 组件实例对象。\n常用的生命周期钩子：\n​ 1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\n​ 2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n关于销毁Vue实例\n​ 1.销毁后借助Vue开发者工具看不到任何信息。\n​ 2.销毁后自定义事件会失效，但原生DOM事件依然有效。\n​ 3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n组件 Vue中使用组件的三大步骤：\n​ 一、定义组件(创建组件)\n​ 二、注册组件\n​ 三、使用组件(写组件标签)\n一、如何定义一个组件？\n​ 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；\n​ 区别如下：\n​ 1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。\n​ 2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。\n​ 备注：使用template可以配置组件结构。\n二、如何注册组件？\n​ 1.局部注册：靠new Vue的时候传入components选项\n​ 2.全局注册：靠Vue.component(\u0026lsquo;组件名\u0026rsquo;,组件)\n三、编写组件标签：\n​ \u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;\n几个注意点：\n​ 1.关于组件名:\n​ 一个单词组成：\n​ 第一种写法(首字母小写)：school\n​ 第二种写法(首字母大写)：School\n​ 多个单词组成：\n​ 第一种写法(kebab-case命名)：my-school\n​ 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)\n​ 备注：\n​ (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。\n​ (2).可以使用name配置项指定组件在开发者工具中呈现的名字。\n​ 2.关于组件标签:\n​ 第一种写法：\u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;\n​ 第二种写法：\u0026lt;school/\u0026gt;\n​ 备注：不用使用脚手架时，\u0026lt;school/\u0026gt;会导致后续组件不能渲染。\n​ 3.一个简写方式：\n​ const school = Vue.extend(options) 可简写为：const school = options\n关于VueComponent：\n​ 1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。\n​ 2.我们只需要写\u0026lt;school/\u0026gt;或\u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;，Vue解析时会帮我们创建school组件的实例对象，\n​ 即Vue帮我们执行的：new VueComponent(options)。\n​ 3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！\n​ 4.关于this指向：\n​ (1).组件配置中：\n​ data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。\n​ (2).new Vue(options)配置中：\n​ data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。\n​ 5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。\n​ Vue的实例对象，以后简称vm。\nVue2进阶 到这一部分，就要使用到脚手架了，同时也向正式的项目靠近了。\n脚手架文件结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ │── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 ├── package-lock.json：包版本控制文件 关于不同版本的Vue vue.js与vue.runtime.xxx.js的区别： vue.js是完整版的Vue，包含：核心功能 + 模板解析器。 vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。也就是代码中的这句render: h =\u0026gt; h(App) vue.config.js配置文件 使用vue inspect \u0026gt; output.js可以查看到Vue脚手架的默认配置。 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh ref属性 被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc） 使用方式： 打标识：\u0026lt;h1 ref=\u0026quot;xxx\u0026quot;\u0026gt;.....\u0026lt;/h1\u0026gt; 或 \u0026lt;School ref=\u0026quot;xxx\u0026quot;\u0026gt;\u0026lt;/School\u0026gt; 获取：this.$refs.xxx props配置项 功能：让组件接收外部传过来的数据\n传递数据：\u0026lt;Demo name=\u0026quot;xxx\u0026quot;/\u0026gt;\n接收数据：\n第一种方式（只接收）：props:['name'] 第二种方式（限制类型）：props:{name:String}\n第三种方式（限制类型、限制必要性、指定默认值）：\n1 2 3 4 5 6 7 props:{ name:{ type:String, //类型 required:true, //必要性 default:\u0026#39;老王\u0026#39; //默认值 } } 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。\nmixin(混入) 功能：可以把多个组件共用的配置提取成一个混入对象\n使用方式：\n第一步定义混合：\n1 2 3 4 5 { data(){....}, methods:{....} .... } 第二步使用混入：\n​\t全局混入：Vue.mixin(xxx) ​\t局部混入：mixins:['xxx']\t插件 功能：用于增强Vue\n本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n定义插件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 对象.install = function (Vue, options) { // 1. 添加全局过滤器 Vue.filter(....) // 2. 添加全局指令 Vue.directive(....) // 3. 配置全局混入(合) Vue.mixin(....) // 4. 添加实例方法 Vue.prototype.$myMethod = function () {...} Vue.prototype.$myProperty = xxxx } 使用插件：Vue.use()\nscoped样式 作用：让样式在局部生效，防止冲突。 写法：\u0026lt;style scoped\u0026gt; 总结TodoList案例 组件化编码流程：\n​\t(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\n​\t(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n​\t1).一个组件在用：放在组件自身即可。\n​\t2). 一些组件在用：放在他们共同的父组件上（状态提升）。\n​\t(3).实现交互：从绑定事件开始。\nprops适用于：\n​\t(1).父组件 ==\u0026gt; 子组件 通信\n​\t(2).子组件 ==\u0026gt; 父组件 通信（要求父先给子一个函数）\n使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！\nprops传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。\nwebStorage 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）\n浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n相关API：\nxxxxxStorage.setItem('key', 'value'); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\nxxxxxStorage.getItem('person');\n​\t该方法接受一个键名作为参数，返回键名对应的值。\nxxxxxStorage.removeItem('key');\n​\t该方法接受一个键名作为参数，并把该键名从存储中删除。\nxxxxxStorage.clear()\n​\t该方法会清空存储中的所有数据。\n备注：\nSessionStorage存储的内容会随着浏览器窗口关闭而消失。 LocalStorage存储的内容，需要手动清除才会消失。 xxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null。 JSON.parse(null)的结果依然是null。 组件的自定义事件 一种组件间通信的方式，适用于：子组件 ===\u0026gt; 父组件\n使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。\n绑定自定义事件：\n第一种方式，在父组件中：\u0026lt;Demo @atguigu=\u0026quot;test\u0026quot;/\u0026gt; 或 \u0026lt;Demo v-on:atguigu=\u0026quot;test\u0026quot;/\u0026gt;\n第二种方式，在父组件中：\n1 2 3 4 5 \u0026lt;Demo ref=\u0026#34;demo\u0026#34;/\u0026gt; ...... mounted(){ this.$refs.xxx.$on(\u0026#39;atguigu\u0026#39;,this.test) } 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。\n触发自定义事件：this.$emit('atguigu',数据)\n解绑自定义事件this.$off('atguigu')\n组件上也可以绑定原生DOM事件，需要使用native修饰符。\n注意：通过this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！\n全局事件总线（GlobalEventBus） 一种组件间通信的方式，适用于任意组件间通信。\n安装全局事件总线：\n1 2 3 4 5 6 7 new Vue({ ...... beforeCreate() { Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm }, ...... }) 使用事件总线：\n接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。\n1 2 3 4 5 6 7 methods(){ demo(data){......} } ...... mounted() { this.$bus.$on(\u0026#39;xxxx\u0026#39;,this.demo) } 提供数据：this.$bus.$emit('xxxx',数据)\n最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。\n消息订阅与发布（pubsub） 一种组件间通信的方式，适用于任意组件间通信。\n使用步骤：\n安装pubsub：npm i pubsub-js\n引入: import pubsub from 'pubsub-js'\n接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。\n1 2 3 4 5 6 7 methods(){ demo(data){......} } ...... mounted() { this.pid = pubsub.subscribe(\u0026#39;xxx\u0026#39;,this.demo) //订阅消息 } 提供数据：pubsub.publish('xxx',数据)\n最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。\nnextTick 语法：this.$nextTick(回调函数) 作用：在下一次 DOM 更新结束后执行其指定的回调。 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。 Vue封装的过度与动画 作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。\n图示：无了\n写法：\n准备好样式：\n元素进入的样式： v-enter：进入的起点 v-enter-active：进入过程中 v-enter-to：进入的终点 元素离开的样式： v-leave：离开的起点 v-leave-active：离开过程中 v-leave-to：离开的终点 使用\u0026lt;transition\u0026gt;包裹要过度的元素，并配置name属性：\n1 2 3 \u0026lt;transition name=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;h1 v-show=\u0026#34;isShow\u0026#34;\u0026gt;你好啊！\u0026lt;/h1\u0026gt; \u0026lt;/transition\u0026gt; 备注：若有多个元素需要过度，则需要使用：\u0026lt;transition-group\u0026gt;，且每个元素都要指定key值。\nvue脚手架配置代理 方法一 ​\t在vue.config.js中添加如下配置：\n1 2 3 devServer:{ proxy:\u0026#34;http://localhost:5000\u0026#34; } 说明：\n优点：配置简单，请求资源时直接发给前端（8080）即可。 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源） 方法二 ​\t编写vue.config.js配置具体代理规则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 module.exports = { devServer: { proxy: { \u0026#39;/api1\u0026#39;: {// 匹配所有以 \u0026#39;/api1\u0026#39;开头的请求路径 target: \u0026#39;http://localhost:5000\u0026#39;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: {\u0026#39;^/api1\u0026#39;: \u0026#39;\u0026#39;} }, \u0026#39;/api2\u0026#39;: {// 匹配所有以 \u0026#39;/api2\u0026#39;开头的请求路径 target: \u0026#39;http://localhost:5001\u0026#39;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: {\u0026#39;^/api2\u0026#39;: \u0026#39;\u0026#39;} } } } } /* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080 changeOrigin默认值为true */ 说明：\n优点：可以配置多个代理，且可以灵活的控制请求是否走代理。 缺点：配置略微繁琐，请求资源时必须加前缀。 插槽 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ===\u0026gt; 子组件。\n分类：默认插槽、具名插槽、作用域插槽\n使用方式：\n默认插槽：\n1 2 3 4 5 6 7 8 9 10 11 父组件中： \u0026lt;Category\u0026gt; \u0026lt;div\u0026gt;html结构1\u0026lt;/div\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 定义插槽 --\u0026gt; \u0026lt;slot\u0026gt;插槽默认内容...\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 具名插槽：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 父组件中： \u0026lt;Category\u0026gt; \u0026lt;template slot=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;div\u0026gt;html结构1\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:footer\u0026gt; \u0026lt;div\u0026gt;html结构2\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 定义插槽 --\u0026gt; \u0026lt;slot name=\u0026#34;center\u0026#34;\u0026gt;插槽默认内容...\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;插槽默认内容...\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 作用域插槽：\n理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）\n具体编码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 父组件中： \u0026lt;Category\u0026gt; \u0026lt;template scope=\u0026#34;scopeData\u0026#34;\u0026gt; \u0026lt;!-- 生成的是ul列表 --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in scopeData.games\u0026#34; :key=\u0026#34;g\u0026#34;\u0026gt;{{g}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; \u0026lt;Category\u0026gt; \u0026lt;template slot-scope=\u0026#34;scopeData\u0026#34;\u0026gt; \u0026lt;!-- 生成的是h4标题 --\u0026gt; \u0026lt;h4 v-for=\u0026#34;g in scopeData.games\u0026#34; :key=\u0026#34;g\u0026#34;\u0026gt;{{g}}\u0026lt;/h4\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot :games=\u0026#34;games\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name:\u0026#39;Category\u0026#39;, props:[\u0026#39;title\u0026#39;], //数据在子组件自身 data() { return { games:[\u0026#39;红色警戒\u0026#39;,\u0026#39;穿越火线\u0026#39;,\u0026#39;劲舞团\u0026#39;,\u0026#39;超级玛丽\u0026#39;] } }, } \u0026lt;/script\u0026gt; Vuex 概念 ​\t在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。\n何时使用？ ​\t多个组件需要共享数据时\n搭建vuex环境 创建文件：src/store/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //引入Vue核心库 import Vue from \u0026#39;vue\u0026#39; //引入Vuex import Vuex from \u0026#39;vuex\u0026#39; //应用Vuex插件 Vue.use(Vuex) //准备actions对象——响应组件中用户的动作 const actions = {} //准备mutations对象——修改state中的数据 const mutations = {} //准备state对象——保存具体的数据 const state = {} //创建并暴露store export default new Vuex.Store({ actions, mutations, state }) 在main.js中创建vm时传入store配置项\n1 2 3 4 5 6 7 8 9 10 11 ...... //引入store import store from \u0026#39;./store\u0026#39; ...... //创建vm new Vue({ el:\u0026#39;#app\u0026#39;, render: h =\u0026gt; h(App), store }) 基本使用 初始化数据、配置actions、配置mutations，操作文件store.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //引入Vue核心库 import Vue from \u0026#39;vue\u0026#39; //引入Vuex import Vuex from \u0026#39;vuex\u0026#39; //引用Vuex Vue.use(Vuex) const actions = { //响应组件中加的动作 jia(context,value){ // console.log(\u0026#39;actions中的jia被调用了\u0026#39;,miniStore,value) context.commit(\u0026#39;JIA\u0026#39;,value) }, } const mutations = { //执行加 JIA(state,value){ // console.log(\u0026#39;mutations中的JIA被调用了\u0026#39;,state,value) state.sum += value } } //初始化数据 const state = { sum:0 } //创建并暴露store export default new Vuex.Store({ actions, mutations, state, }) 组件中读取vuex中的数据：$store.state.sum\n组件中修改vuex中的数据：$store.dispatch('action中的方法名',数据) 或 $store.commit('mutations中的方法名',数据)\n备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit\ngetters的使用 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。\n在store.js中追加getters配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 ...... const getters = { bigSum(state){ return state.sum * 10 } } //创建并暴露store export default new Vuex.Store({ ...... getters }) 组件中读取数据：$store.getters.bigSum\n四个map方法的使用 mapState方法：用于帮助我们映射state中的数据为计算属性\n1 2 3 4 5 6 7 computed: { //借助mapState生成计算属性：sum、school、subject（对象写法） ...mapState({sum:\u0026#39;sum\u0026#39;,school:\u0026#39;school\u0026#39;,subject:\u0026#39;subject\u0026#39;}), //借助mapState生成计算属性：sum、school、subject（数组写法） ...mapState([\u0026#39;sum\u0026#39;,\u0026#39;school\u0026#39;,\u0026#39;subject\u0026#39;]), }, mapGetters方法：用于帮助我们映射getters中的数据为计算属性\n1 2 3 4 5 6 7 computed: { //借助mapGetters生成计算属性：bigSum（对象写法） ...mapGetters({bigSum:\u0026#39;bigSum\u0026#39;}), //借助mapGetters生成计算属性：bigSum（数组写法） ...mapGetters([\u0026#39;bigSum\u0026#39;]) }, mapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数\n1 2 3 4 5 6 7 methods:{ //靠mapActions生成：incrementOdd、incrementWait（对象形式） ...mapActions({incrementOdd:\u0026#39;jiaOdd\u0026#39;,incrementWait:\u0026#39;jiaWait\u0026#39;}) //靠mapActions生成：incrementOdd、incrementWait（数组形式） ...mapActions([\u0026#39;jiaOdd\u0026#39;,\u0026#39;jiaWait\u0026#39;]) } mapMutations方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数\n1 2 3 4 5 6 7 methods:{ //靠mapActions生成：increment、decrement（对象形式） ...mapMutations({increment:\u0026#39;JIA\u0026#39;,decrement:\u0026#39;JIAN\u0026#39;}), //靠mapMutations生成：JIA、JIAN（对象形式） ...mapMutations([\u0026#39;JIA\u0026#39;,\u0026#39;JIAN\u0026#39;]), } 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\n模块化+命名空间 目的：让代码更好维护，让多种数据分类更加明确。\n修改store.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const countAbout = { namespaced:true,//开启命名空间 state:{x:1}, mutations: { ... }, actions: { ... }, getters: { bigSum(state){ return state.sum * 10 } } } const personAbout = { namespaced:true,//开启命名空间 state:{ ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { countAbout, personAbout } }) 开启命名空间后，组件中读取state数据：\n1 2 3 4 //方式一：自己直接读取 this.$store.state.personAbout.list //方式二：借助mapState读取： ...mapState(\u0026#39;countAbout\u0026#39;,[\u0026#39;sum\u0026#39;,\u0026#39;school\u0026#39;,\u0026#39;subject\u0026#39;]), 开启命名空间后，组件中读取getters数据：\n1 2 3 4 //方式一：自己直接读取 this.$store.getters[\u0026#39;personAbout/firstPersonName\u0026#39;] //方式二：借助mapGetters读取： ...mapGetters(\u0026#39;countAbout\u0026#39;,[\u0026#39;bigSum\u0026#39;]) 开启命名空间后，组件中调用dispatch\n1 2 3 4 //方式一：自己直接dispatch this.$store.dispatch(\u0026#39;personAbout/addPersonWang\u0026#39;,person) //方式二：借助mapActions： ...mapActions(\u0026#39;countAbout\u0026#39;,{incrementOdd:\u0026#39;jiaOdd\u0026#39;,incrementWait:\u0026#39;jiaWait\u0026#39;}) 开启命名空间后，组件中调用commit\n1 2 3 4 //方式一：自己直接commit this.$store.commit(\u0026#39;personAbout/ADD_PERSON\u0026#39;,person) //方式二：借助mapMutations： ...mapMutations(\u0026#39;countAbout\u0026#39;,{increment:\u0026#39;JIA\u0026#39;,decrement:\u0026#39;JIAN\u0026#39;}), 路由 理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。 前端路由：key是路径，value是组件。 基本使用 安装vue-router，命令：npm i vue-router\n应用插件：Vue.use(VueRouter)\n编写router配置项:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //引入VueRouter import VueRouter from \u0026#39;vue-router\u0026#39; //引入Luyou 组件 import About from \u0026#39;../components/About\u0026#39; import Home from \u0026#39;../components/Home\u0026#39; //创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes:[ { path:\u0026#39;/about\u0026#39;, component:About }, { path:\u0026#39;/home\u0026#39;, component:Home } ] }) //暴露router export default router 实现切换（active-class可配置高亮样式）\n1 \u0026lt;router-link active-class=\u0026#34;active\u0026#34; to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; 指定展示位置\n1 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 几个注意点 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。 每个组件都有自己的$route属性，里面存储着自己的路由信息。 整个应用只有一个router，可以通过组件的$router属性获取到。 多级路由（多级路由） 配置路由规则，使用children配置项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 routes:[ { path:\u0026#39;/about\u0026#39;, component:About, }, { path:\u0026#39;/home\u0026#39;, component:Home, children:[ //通过children配置子级路由 { path:\u0026#39;news\u0026#39;, //此处一定不要写：/news component:News }, { path:\u0026#39;message\u0026#39;,//此处一定不要写：/message component:Message } ] } ] 跳转（要写完整路径）：\n1 \u0026lt;router-link to=\u0026#34;/home/news\u0026#34;\u0026gt;News\u0026lt;/router-link\u0026gt; 路由的query参数 传递参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 跳转并携带query参数，to的字符串写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;/home/message/detail?id=666\u0026amp;title=你好\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!-- 跳转并携带query参数，to的对象写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{ path:\u0026#39;/home/message/detail\u0026#39;, query:{ id:666, title:\u0026#39;你好\u0026#39; } }\u0026#34; \u0026gt;跳转\u0026lt;/router-link\u0026gt; 接收参数：\n1 2 $route.query.id $route.query.title 命名路由 作用：可以简化路由的跳转。\n如何使用\n给路由命名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { path:\u0026#39;/demo\u0026#39;, component:Demo, children:[ { path:\u0026#39;test\u0026#39;, component:Test, children:[ { name:\u0026#39;hello\u0026#39; //给路由命名 path:\u0026#39;welcome\u0026#39;, component:Hello, } ] } ] } 简化跳转：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!--简化前，需要写完整的路径 --\u0026gt; \u0026lt;router-link to=\u0026#34;/demo/test/welcome\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!--简化后，直接通过名字跳转 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;hello\u0026#39;}\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!--简化写法配合传递参数 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{ name:\u0026#39;hello\u0026#39;, query:{ id:666, title:\u0026#39;你好\u0026#39; } }\u0026#34; \u0026gt;跳转\u0026lt;/router-link\u0026gt; 路由的params参数 配置路由，声明接收params参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { path:\u0026#39;/home\u0026#39;, component:Home, children:[ { path:\u0026#39;news\u0026#39;, component:News }, { component:Message, children:[ { name:\u0026#39;xiangqing\u0026#39;, path:\u0026#39;detail/:id/:title\u0026#39;, //使用占位符声明接收params参数 component:Detail } ] } ] } 传递参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 跳转并携带params参数，to的字符串写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;/home/message/detail/666/你好\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!-- 跳转并携带params参数，to的对象写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{ name:\u0026#39;xiangqing\u0026#39;, params:{ id:666, title:\u0026#39;你好\u0026#39; } }\u0026#34; \u0026gt;跳转\u0026lt;/router-link\u0026gt; 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n接收参数：\n1 2 $route.params.id $route.params.title 路由的props配置 ​\t作用：让路由组件更方便的收到参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { name:\u0026#39;xiangqing\u0026#39;, path:\u0026#39;detail/:id\u0026#39;, component:Detail, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 // props:{a:900} //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件 // props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props(route){ return { id:route.query.id, title:route.query.title } } } \u0026lt;router-link\u0026gt;的replace属性 作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push 如何开启replace模式：\u0026lt;router-link replace .......\u0026gt;News\u0026lt;/router-link\u0026gt; 编程式路由导航 作用：不借助\u0026lt;router-link\u0026gt; 实现路由跳转，让路由跳转更加灵活\n具体编码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //$router的两个API this.$router.push({ name:\u0026#39;xiangqing\u0026#39;, params:{ id:xxx, title:xxx } }) this.$router.replace({ name:\u0026#39;xiangqing\u0026#39;, params:{ id:xxx, title:xxx } }) this.$router.forward() //前进 this.$router.back() //后退 this.$router.go() //可前进也可后退 缓存路由组件 作用：让不展示的路由组件保持挂载，不被销毁。\n具体编码：\n1 2 3 \u0026lt;keep-alive include=\u0026#34;News\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt; 两个新的生命周期钩子 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。 具体名字： activated路由组件被激活时触发。 deactivated路由组件失活时触发。 路由守卫 作用：对路由进行权限控制\n分类：全局守卫、独享守卫、组件内守卫\n全局守卫:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //全局前置守卫：初始化时执行、每次路由切换前执行 router.beforeEach((to,from,next)=\u0026gt;{ console.log(\u0026#39;beforeEach\u0026#39;,to,from) if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制 if(localStorage.getItem(\u0026#39;school\u0026#39;) === \u0026#39;atguigu\u0026#39;){ //权限控制的具体规则 next() //放行 }else{ alert(\u0026#39;暂无权限查看\u0026#39;) // next({name:\u0026#39;guanyu\u0026#39;}) } }else{ next() //放行 } }) //全局后置守卫：初始化时执行、每次路由切换后执行 router.afterEach((to,from)=\u0026gt;{ console.log(\u0026#39;afterEach\u0026#39;,to,from) if(to.meta.title){ document.title = to.meta.title //修改网页的title }else{ document.title = \u0026#39;vue_test\u0026#39; } }) 独享守卫:\n1 2 3 4 5 6 7 8 9 10 11 12 13 beforeEnter(to,from,next){ console.log(\u0026#39;beforeEnter\u0026#39;,to,from) if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制 if(localStorage.getItem(\u0026#39;school\u0026#39;) === \u0026#39;atguigu\u0026#39;){ next() }else{ alert(\u0026#39;暂无权限查看\u0026#39;) // next({name:\u0026#39;guanyu\u0026#39;}) } }else{ next() } } 组件内守卫：\n1 2 3 4 5 6 //进入守卫：通过路由规则，进入该组件时被调用 beforeRouteEnter (to, from, next) { }, //离开守卫：通过路由规则，离开该组件时被调用 beforeRouteLeave (to, from, next) { } 路由器的两种工作模式 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。\nhash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。\nhash模式：\n地址中永远带着#号，不美观 。 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。 兼容性较好。 history模式：\n地址干净，美观 。 兼容性和hash模式相比略差。 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。 ","date":"2021-09-22T08:21:14+08:00","image":"https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/88417243.webp","permalink":"https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Vue学习笔记"},{"content":"最近做项目需要前后端分离，所以需要接口文档给前端方便联调。手写文档是不可能的，这时就需要使用Swagger了。网上的教程大部分版本都在2.x甚至是1.x，很少有3.0的教程，我个人就是喜欢用最新版，所以我就来分享一下我使用Swagger3的体验和坑吧。\n配置 这里就分享springboot版本的方法了，现在的项目应该都用springboot创建了吧。\n导入Maven依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在启动类上加上@EnableOpenApi就行了。\n当然，这样只是默认的，我们要用肯定要配置一下，我们去创建一个Config类，在里面建立一个函数返回Docket类，我们所有的配置就在这个Docket类里配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Configuration @EnableOpenApi public class SwaggerConfig { @Bean public Docket docket(){ return new Docket(DocumentationType.OAS_30)\t//3.0版本用OAS_30这个标准 .apiInfo(getApiInfo()) .select() //扫描指定包下的接口 .apis(RequestHandlerSelectors.basePackage(\u0026#34;top.lbqaq.controller\u0026#34;)) .build(); } /** * 配置swagger信息 */ private ApiInfo getApiInfo(){ //这里是作者信息，分别为姓名、个人主页、邮箱 Contact contact = new Contact(\u0026#34;luoboQAQ\u0026#34;,\u0026#34;https://lbqaq.top\u0026#34;,\u0026#34;123@xx.com\u0026#34;); return new ApiInfo( \u0026#34;项目名\u0026#34;, \u0026#34;项目描述\u0026#34;, \u0026#34;版本\u0026#34;, \u0026#34;项目主页\u0026#34;, contact, \u0026#34;Apache 2.0\u0026#34;, \u0026#34;https://www.apache.org/licenses/LICENSE-2.0\u0026#34;, new ArrayList()); } } 这样一个带有个人信息的配置页就做好了。\n注解 首先是2.0版本的注解，当然新版本也同样通用。\nSwagger注解 简单说明 @Api(tags = \u0026ldquo;xxx模块说明\u0026rdquo;) 作用在模块类上 @ApiOperation(\u0026ldquo;xxx接口说明\u0026rdquo;) 作用在接口方法上 @ApiModel(\u0026ldquo;xxxPOJO说明\u0026rdquo;) 作用在模型类上：如VO、BO @ApiModelProperty(value = \u0026ldquo;xxx属性说明\u0026rdquo;,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(\u0026ldquo;xxx参数说明\u0026rdquo;) 作用在参数、方法和字段上，类似@ApiModelProperty 既然用了3.0，也就可以使用3.0的新注释。\n先放上官网链接：\nSwagger注解 SpringFox文档 Swagger是底层，实现是由SpringFox来完成的，所以有些在Swagger文档里的注解放到SpringFox里就无法实现，比如@RequestBody这个注解就无法实现。下面就列举我测试过可以成功的注解：\n在方法上进行注释\n1 2 3 @Operation(summary = \u0026#34;这会显示在主页上\u0026#34;, description = \u0026#34;这显示在内页里\u0026#34;, tags = {\u0026#34;test\u0026#34;})\t//会将接口分类出去 在参数上注释\n1 @Parameter(description = \u0026#34;这里是描述\u0026#34;, required = true) 只测了这么多，之前为了测试@RequestBody花了太多时间，结果一无所获。因为2.0的注解还能用，这里就挖个坑，等之后有时间再来完善吧。\n","date":"2021-09-09T15:09:04+08:00","image":"https://lbqaq.top/p/swagger/92079701.webp","permalink":"https://lbqaq.top/p/swagger/","title":"Swagger3初体验"},{"content":"每次写完博客，需要在本地编译，然后再手动通过WinSCP送到服务器上。作为一个懒人，这上面几步下来还是觉得麻烦，而且每次编译又会生成一顿不需要的文件，于是便决定整点自动化的流程，直接解放双手。\n因为我的博客在没买服务器之前都是托管在Github上的，于是自然而然地就想到了Webhook，在每次Push后自动发送消息给服务器，让其自动拉取代码。\n网上的教程大多都是在本地编译，然而我觉得既然要懒，就一懒到底吧，编译也直接通过Github Actions来完成就行了。\n流程 需要2个Github仓库（1个应该也可以），一个存放网站的源码，一个是存放编译好的html文件。整个工作流程就如下图所示：\n步骤 设置脚本 首先要写一个shell脚本，功能很简单就是自动拉取代码。\n1 2 3 #!/bin/bash cd /home/luobo/Blog git pull 创建webhook服务后端 这里就直接使用NodeJS来创建，使用的原因很简单，因为已经有现成的插件可以使用了。\n首先安装依赖\n1 2 npm i -S github-webhook-handler npm i -g pm2 然后创建webhook.js作为后端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 var http = require(\u0026#39;http\u0026#39;); var spawn = require(\u0026#39;child_process\u0026#39;).spawn; var createHandler = require(\u0026#39;github-webhook-handler\u0026#39;); //注意要将 secret 修改你自己的 var handler = createHandler({ path: \u0026#39;/webhook\u0026#39;, secret: \u0026#39;xxxxx\u0026#39; }); http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404; res.end(\u0026#39;no such location\u0026#39;); }) }).listen(6666); handler.on(\u0026#39;error\u0026#39;, function (err) { console.error(\u0026#39;Error:\u0026#39;, err.message) }); handler.on(\u0026#39;push\u0026#39;, function (event) { console.log(\u0026#39;Received a push event for %s to %s\u0026#39;, event.payload.repository.name, event.payload.ref); runCommand(\u0026#39;sh\u0026#39;, [\u0026#39;./deploy.sh\u0026#39;], function( txt ){ console.log(txt); }); }); function runCommand( cmd, args, callback ){ var child = spawn( cmd, args ); var resp = \u0026#39;Deploy OK\u0026#39;; child.stdout.on(\u0026#39;data\u0026#39;, function( buffer ){ resp += buffer.toString(); }); child.stdout.on(\u0026#39;end\u0026#39;, function(){ callback( resp ) }); } 最后启动服务即可\n1 pm2 start webhook.js Nginx设置反代 1 2 3 location /webhook { proxy_pass http://127.0.0.1:6666; } 配置Github Webhook 在 html仓库的 Settings - webhooks 设置中创建一个新的 webhook。\n将Content Type 设置为 application/json，secret 设置成与 webhook.js 中的相同。\ntrigeer选择Just the push event. 。\n完成后Github会自动发起一个测试请求，如果返回为200说明配置完成，\n配置自动编译 在源代码仓库的.github/workflows目录下创建deploy.yml，并填入以下内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 name: Build and Deploy on: [push] # 任务 jobs: build-and-deploy: # 服务器环境：最新版 Ubuntu runs-on: ubuntu-latest steps: # 拉取代码 - name: Checkout uses: actions/checkout@v2 # 安装Hugo - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest extended: true - name: Build run: hugo # 部署到 GitHub Pages - name: Deploy to GitHub Pages uses: JamesIves/github-pages-deploy-action@4.1.4 with: BRANCH: main FOLDER: public token: ${{ secrets.GP_TOKEN }} repository-name: luoboQAQ/luoboQAQ.github.io 注意要将最后的repository-name换为你自己的仓库，同时需要申请和配置Github Token，这里我就不展开了。\n参考 使用 GitHub Webhook 实现静态网站自动化部署 ","date":"2021-08-23T15:44:59+08:00","image":"https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/90550307.webp","permalink":"https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"使用Webhooks实现自动部署"},{"content":"一个完整的博客，怎么能少的了评论系统呢。评论的实现已经有许许多多的方法了，挑来挑去，还是选择了Waline。\n一开始我是采用官方推荐的LeanCloud+Vercel的方式进行部署的，结果步骤全部走完后才发现Vercel已经在国内被墙了，不科学根本上不去😇。总不能要求用户还要开梯子才能评论吧，所幸官方提供了其他的部署方式，因为我才买了自己的服务器~~（不榨干怎么行呢）~~，所以就选择本地部署+SQLlite的方式了。\n部署步骤 安装node.js 由于Waline的服务端是由js写的，所以需要安装node.js\n在nodejs中文网找到需要的版本，选择阿里云镜像，将下载链接复制下来\n连接服务器，选择nodejs的安装目录，这里我安装在/usr/local/bin/\n1 cd /usr/local/bin/ 下载安装包到本地\n1 wget https://npm.taobao.org/mirrors/node/v14.17.5/node-v14.17.5-linux-x64.tar.gz 解压\n1 tar -xvf node-v14.17.5-linux-x64.tar.gz 重命名目录\n1 mv node-v14.17.5-linux-x64 nodejs 添加目录到系统变量\n1 2 cd /etc/profile.d vim custom.sh 在文件末尾添加export PATH=$PATH:/usr/local/bin/nodejs/bin\n测试，输入下面3条命令，如果不报错则安装成功。\n1 2 3 node -v npm version npx -v （可选）安装cnpm\n1 npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Waline服务端 安装waline的服务端\n1 npm install -g @waline/vercel 配置数据库。这里我采用的是SQLite，只需要下载 waline.sqlite 文件至合适的位置。\n其他的数据库可以看官方文档来配置。\n配置环境变量。\n这里我选择新建waline.sh，方便日后维护。\n1 2 3 4 cd /etc/profile.d vim waline.sh export SQLITE_PATH=/home/luobo export JWT_TOKEN=eqdVMaEwd SQLITE_PATH：表示SQLite文件的位置。 JWT_TOKEN：随机一串字符串就行。 启动模块\n1 2 cd /usr/local/bin/nodejs/lib node node_modules/@waline/vercel/vanilla.js 配置nginx反代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #waline server { listen 80; listen 443 ssl http2; server_name waline.lbqaq.top; if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } ssl_certificate cert/waline.lbqaq.top.pem; ssl_certificate_key cert/waline.lbqaq.top.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:8360; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; # cache add_header Cache-Control no-cache; expires 12h; } } 在hugo中启用Waline 由于我用的主题已经支持Waline评论，所以只需要填入serverURL就行了。\n添加QQ推送（可选） 官方提供了四种通知方法，分别为邮箱、微信、QQ、Telegram。\n邮箱基本不会去看，Telegram没科学也上不去，微信由于是走的Server酱，没有捐赠一天就支持5条消息。\n最终还是决定采用Qmsg 酱。\n注册就不在这展开了，具体写一下环境变量的配置。\n1 2 3 4 5 6 7 cd /etc/profile.d vim waline.sh export QMSG_KEY=xxxxxx export QQ_ID=xxxxxx export AUTHOR_EMAIL=xxxxxxx export SITE_NAME=Blog export SITE_URL=lbqaq.top 踩坑 本以为启用评论是一件很简单的事，结果花了整个下午加晚上，踩了好多好多坑。在这里就把我踩的坑记录下来，避免之后出现一样的问题。\nnpm install -g @waline/vercel报错\n使用cnpm进行安装\n2021/10/21更新：\n更新系统后再尝试安装无论是npm还是cnpm都无法安装，故使用Docker进行安装和运行\n1 2 3 4 5 6 7 8 9 10 11 12 docker run -d \\ -e SQLITE_PATH=/data \\ -e JWT_TOKEN=xxx \\ -e QMSG_KEY=xxxx \\ -e QQ_ID=123 \\ -e AUTHOR_EMAIL=xxx@xx.com \\ -e SITE_NAME=Blog \\ -e SITE_URL=lbqaq.top \\ -p 8360:8360 \\ -v /home/admin/waline:/data \\ --name=waline \\ lizheming/waline 想使用lbqaq.top/waline/这样的链接来设置服务端\n直接报404错误，还是选择上文中的子域名方法\nnginx提示没找到http2模块\n在安装nginx时加上--with-http_v2_module如果已经安装好了，可以重新安装一遍\n设置了server_name waline.lbqaq.top还是跳转首页\n增加一个默认的server，将所有不匹配的链接阻止\n1 2 3 4 5 server { listen 80 default_server; server_name _; return 444; } nginx配置不生效\n如果配置没有问题，除了nginx -s reload还可以尝试重启nginx\n参考链接 Waline官方文档 nginx中文文档 ","date":"2021-08-21T15:37:44+08:00","image":"https://lbqaq.top/p/waline/78502982.webp","permalink":"https://lbqaq.top/p/waline/","title":"为博客添加评论系统"},{"content":"SpringMVC也告一段落了，终于要到SpringBoot了。\n还是和之前一样，笔记是基于遇见狂神说的SpringMVC视频教程而来，在此感谢能提供这么优秀的教程。\n回顾MVC 什么是MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 将业务逻辑、数据、显示分离的方法来组织代码。 **Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\n拓展：在前端数据传输给后端时，有些字段是不需要的，这是可能会细分出Vo层（视图）\n比如：用户有账号、密码、年龄等一系列字段\n这时前端登录只传了账号密码\n此时可以用UserVo来表示，里面只有账号和密码\n**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\n**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析：\nController：控制器\n取得表单数据 调用业务逻辑 转向指定的页面 Model：模型\n业务逻辑 保存数据的状态 View：视图\n显示页面 复习Servlet 父工程添加依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写Servlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取前端操作 String method = req.getParameter(\u0026#34;method\u0026#34;); if (method.equals(\u0026#34;add\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了add方法\u0026#34;); } if (method.equals(\u0026#34;delete\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了delete方法\u0026#34;); } //调用业务层 //视图转发或重定向 req.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/test.jsp\u0026#34;).forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 编写test.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建test.jsp\n1 2 3 4 5 6 7 8 9 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在web.xml中注册Servlet\n1 2 3 4 5 6 7 8 9 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;top.lbqaq.servlet.HelloServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 配置TomCat，进行测试\nMVC框架要做哪些事情\n将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求\u0026ndash;调用相关的业务处理\u0026ndash;封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明：\n​\t常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等\u0026hellip;.\n什么是SpringMVC 概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n中文文档\n我们为什么要学习SpringMVC呢?\nSpring MVC的特点：\n轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 中心控制器 ​\tSpring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\n​\tSpring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。\nSpringMVC的原理如下图所示：\n​\t当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\nSpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。\n简要分析执行流程\nDispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080服务器域名\nSpringMVC部署在服务器上的web站点\nhello表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\nHandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\nHandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\nHandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\nHandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\nHandler让具体的Controller执行。\nController将具体的执行信息返回给HandlerAdapter,如ModelAndView。\nHandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\nDispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n视图解析器将解析的逻辑视图名传给DispatcherServlet。\nDispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n最终视图呈现给用户。\n这里比较绕，所以直接把原文搬来了，之后等理解加深了再来补充自己的看法。\n第一个SpringMVC程序 由于我们是采用子模块的方式，那么需要去IDEA里设置一下让lib会打包出去。否则就会提示404错误。\n在点击IDEA右上角的小齿轮，选择项目结构，在工件下看WEB-INF里是否有lib目录，没有的话就创建一个，然后点击+号，选择库文件将所有的包导入进去。\n配置版 准备要看的视图。在WEB-INF目录下创建jsp目录，在里面创建test.jsp，填入${msg}\n配置SpringMVC。在web.xml里添加下面的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--配置DispatchServlet：这是SpringMVC的核心：请求分发器、前端控制器--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--DispatchServlet要绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别1：随服务器一起启动--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 备注：/和/*的区别：/匹配所有请求，不匹配jsp页面；/*会匹配jsp页面，这样会导致嵌套，一般不会用\n编写SpringMVC的配置文件springmvc-servlet.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--处理器映射器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026#34;/\u0026gt; \u0026lt;!--处理器适配器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026#34;/\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!--前缀--\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;!--后缀--\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 实现Controller接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package top.lbqaq.Controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { ModelAndView mv = new ModelAndView(); //业务代码 String result = \u0026#34;HelloSpringMVC\u0026#34;; mv.addObject(\u0026#34;msg\u0026#34;,result); //视图跳转 mv.setViewName(\u0026#34;test\u0026#34;); return mv; } } 将Controller在Spring中注册(springmvc-servlet.xml)\n1 2 \u0026lt;!--BeanNameUrlHandlerMapping:按BeanName匹配--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;top.lbqaq.Controller.HelloController\u0026#34;/\u0026gt; 运行TomCat查看结果\n然而正常开发并不会使用这样的方式，这样做只是为了理解底层的操作。_(:з)∠)_\n注解版 配置Web.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!--配置DispatchServlet：这是SpringMVC的核心：请求分发器、前端控制器--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--DispatchServlet要绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别1：随服务器一起启动；越小级别越高--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 还是老样子，这里没有什么需要改动的。\n在resources目录下添加SpringMVC配置文件springmvc-servlet.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;top.lbqaq.controller\u0026#34;/\u0026gt; \u0026lt;!-- 让Spring MVC不处理静态资源 --\u0026gt; \u0026lt;mvc:default-servlet-handler /\u0026gt; \u0026lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;!-- 视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34; /\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 创建Controller\n1 2 3 4 5 6 7 8 9 @Controller public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model){ //封装数据 model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;Hello,SpringMVCAnnotation!\u0026#34;); return \u0026#34;hello\u0026#34;; //会被视图解析器处理 } } @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 创建视图层，在WEB-INF/jsp目录中创建hello.jsp\n1 2 3 4 5 6 7 8 9 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运行TomCat查看结果\n小结 实现步骤其实非常的简单：\n新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置\nRestFul风格 概念\nRestful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n功能\n资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。\n分别对应 添加、 删除、修改、查询。\n传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get\n​\thttp://127.0.0.1/item/queryItem.action?id=1 查询,GET\n​\thttp://127.0.0.1/item/saveItem.action 新增,POST\n​\thttp://127.0.0.1/item/updateItem.action 更新,POST\n​\thttp://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST\n使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！\n​\thttp://127.0.0.1/item/1 查询,GET\n​\thttp://127.0.0.1/item 新增,POST\n​\thttp://127.0.0.1/item 更新,PUT\n​\thttp://127.0.0.1/item/1 删除,DELETE\n使用方法\n创建一个类RestFulController\n1 2 3 4 5 6 7 8 9 10 11 12 @Controller public class RestFulController { //原来的：localhost:8085/add?a=1\u0026amp;b=2 //Restful:localhost:8085/add/1/2 @RequestMapping(\u0026#34;/add/{a}/{b}\u0026#34;) public String test1(@PathVariable int a,@PathVariable int b, Model model){ int res = a+b; model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;结果为\u0026#34;+res); return \u0026#34;test\u0026#34;; } } @RequestMapping里面的{a}就代表这里是传给a变量的值；下面的a变量前要加@PathVariable\n使用路径变量的好处？\n使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 我们也可以进行方法约束，让其只响应某一种请求\n1 2 3 4 5 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 拿@GetMapping来说，就是@RequestMapping(method =RequestMethod.GET)意思，如果使用其他的方法，将会报405错误。\n重定向和转发 重定向不需要视图解析器，本质就是重新请求一个新地方。\n可以重定向到另外一个请求实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Controller public class ResultSpringMVC2 { @RequestMapping(\u0026#34;/rsm2/t1\u0026#34;) public String test1(){ //转发 return \u0026#34;test\u0026#34;; } @RequestMapping(\u0026#34;/rsm2/t2\u0026#34;) public String test2(){ //重定向 return \u0026#34;redirect:/index.jsp\u0026#34;; //return \u0026#34;redirect:hello.do\u0026#34;; //hello.do为另一个请求/ } } 数据处理 处理提交数据 1、提交的域名称和处理方法的参数名一致\n提交数据 : http://localhost:8080/hello?name=lbqaq\n处理方法 :\n1 2 3 4 5 @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : lbqaq\n2、提交的域名称和处理方法的参数名不一致\n提交数据 : http://localhost:8080/hello?username=lbqaq\n处理方法 :\n1 2 3 4 5 6 //@RequestParam(\u0026#34;username\u0026#34;) : username提交的域的名称 . @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : lbqaq\n3、提交的是一个对象\n要求提交的表单域和对象的属性名一致 , 参数使用对象即可\n1、实体类\n1 2 3 4 5 6 7 8 public class User { private int id; private String name; private int age; //构造 //get/set //tostring() } 2、提交数据 : http://localhost:8080/mvc04/user?name=lbqaq\u0026amp;id=1\u0026amp;age=15\n3、处理方法 :\n1 2 3 4 5 @RequestMapping(\u0026#34;/user\u0026#34;) public String user(User user){ System.out.println(user); return \u0026#34;hello\u0026#34;; } 后台输出 : User { id=1, name=\u0026lsquo;lbqaq\u0026rsquo;, age=15 }\n说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。\n数据显示到前端 第一种 : 通过ModelAndView\n我们前面一直都是如此 . 就不过多解释\n1 2 3 4 5 6 7 8 9 10 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;ControllerTest1\u0026#34;); mv.setViewName(\u0026#34;test\u0026#34;); return mv; } } 第二种 : 通过ModelMap\nModelMap\n1 2 3 4 5 6 7 8 @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\u0026#34;name\u0026#34;,name); model.addAttribute(\u0026#34;name\u0026#34;,name); System.out.println(name); return \u0026#34;hello\u0026#34;; } 第三种 : 通过Model\nModel\n1 2 3 4 5 6 7 8 @RequestMapping(\u0026#34;/ct2/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\u0026#34;name\u0026#34;,name); model.addAttribute(\u0026#34;msg\u0026#34;,name); System.out.println(name); return \u0026#34;test\u0026#34;; } 对比 就对于新手而言简单来说使用区别就是：\nModel 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。\n这里都是概念性的内容，所以就直接复制笔记了😌\n解决乱码 直接把Spring的乱码处理器放入web.xml里\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; JSON JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 使用Jackson 导入依赖\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写Controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Controller public class UserController { @RequestMapping(\u0026#34;/json1\u0026#34;) @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\u0026#34;小明\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } 如果出现乱码，可以指定编码格式为UTF8来解决\n@RequestMapping(value = \u0026quot;/json1\u0026quot;,produces = \u0026quot;application/json;charset=utf-8\u0026quot;)\n这样处理乱码还是太麻烦了，可以让Spring统一管理，在SpringMVC的配置文件里加上下面的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController public class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = \u0026#34;/json1\u0026#34;) public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\u0026#34;小明\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 自定义工具类，可以是JSON转换变得更简单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class JsonUtils { public static String getJson(Object object) { return getJson(object,\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 使用FastJson 1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.78\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 为了使@RestController有效，需要在Spring配置里加上下面的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- 配置Fastjson支持 --\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;application/json\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;text/html;charset=UTF-8\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; fastjson 三个主要的类：\nJSONObject 代表 json 对象\nJSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取\u0026quot;键：值\u0026quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组\n内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化\nJSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 测试代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(\u0026#34;1号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user2 = new User(\u0026#34;2号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user3 = new User(\u0026#34;3号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user4 = new User(\u0026#34;4号\u0026#34;, 3, \u0026#34;男\u0026#34;); List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;User\u0026gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\u0026#34;*******Java对象 转 JSON字符串*******\u0026#34;); String str1 = JSON.toJSONString(list); System.out.println(\u0026#34;JSON.toJSONString(list)==\u0026gt;\u0026#34;+str1); String str2 = JSON.toJSONString(user1); System.out.println(\u0026#34;JSON.toJSONString(user1)==\u0026gt;\u0026#34;+str2); System.out.println(\u0026#34;\\n****** JSON字符串 转 Java对象*******\u0026#34;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\u0026#34;JSON.parseObject(str2,User.class)==\u0026gt;\u0026#34;+jp_user1); System.out.println(\u0026#34;\\n****** Java对象 转 JSON对象 ******\u0026#34;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\u0026#34;(JSONObject) JSON.toJSON(user2)==\u0026gt;\u0026#34;+jsonObject1.getString(\u0026#34;name\u0026#34;)); System.out.println(\u0026#34;\\n****** JSON对象 转 Java对象 ******\u0026#34;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\u0026#34;JSON.toJavaObject(jsonObject1, User.class)==\u0026gt;\u0026#34;+to_java_user); } } Jackson刚刚测试没成功，还是选择FastJson吧😇。\n拦截器 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。\n**过滤器与拦截器的区别：**拦截器是AOP思想的具体应用。\n过滤器\nservlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器\n拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 使用方法 自定义拦截器需要实现接口HandlerInterceptor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\u0026#34;------------处理前------------\u0026#34;); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;------------处理后------------\u0026#34;); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\u0026#34;------------清理------------\u0026#34;); } } 在springmvc的配置文件中配置拦截器\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--关于拦截器的配置--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;!--/** 包括路径及其子路径--\u0026gt; \u0026lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--\u0026gt; \u0026lt;!--/admin/** 拦截的是/admin/下的所有--\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;!--bean配置的就是拦截器--\u0026gt; \u0026lt;bean class=\u0026#34;top.lbqaq.interceptor.MyInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 执行顺序如下：\n1 2 3 4 ------------处理前------------ Controller方法 ------------处理后------------ ------------清理------------ 拦截器可以用来做登录验证等等内容，这里就不展开了（才不是懒得写）\n文件传输 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。\n前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；\n对表单中的 enctype 属性做个详细的说明：\napplication/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 \u0026ldquo;+\u0026rdquo; 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 1 2 3 4 \u0026lt;form action=\u0026#34;\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 文件上传 导入依赖包\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!--文件上传--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--servlet-api导入高版本的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置multipartResolver\n这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！\n1 2 3 4 5 6 7 8 \u0026lt;!--文件上传配置--\u0026gt; \u0026lt;bean id=\u0026#34;multipartResolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34;\u0026gt; \u0026lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --\u0026gt; \u0026lt;property name=\u0026#34;defaultEncoding\u0026#34; value=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --\u0026gt; \u0026lt;property name=\u0026#34;maxUploadSize\u0026#34; value=\u0026#34;10485760\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;maxInMemorySize\u0026#34; value=\u0026#34;40960\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 编写前端页面\n1 2 3 4 \u0026lt;form action=\u0026#34;/upload\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;upload\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 配置Controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.commons.CommonsMultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.*; @Controller public class FileController { //@RequestParam(\u0026#34;file\u0026#34;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(\u0026#34;/upload\u0026#34;) public String fileUpload(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file , HttpServletRequest request) throws IOException { //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (\u0026#34;\u0026#34;.equals(uploadFileName)){ return \u0026#34;redirect:/index.jsp\u0026#34;; } System.out.println(\u0026#34;上传文件名 : \u0026#34;+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1){ os.write(buffer,0,len); os.flush(); } os.close(); is.close(); return \u0026#34;redirect:/index.jsp\u0026#34;; } } 方法二：使用file.Transto 来保存上传的文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* * 采用file.Transto 来保存上传的文件 */ @RequestMapping(\u0026#34;/upload2\u0026#34;) public String fileUpload2(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file, HttpServletRequest request) throws IOException { //上传路径保存设置 String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } //上传文件地址 System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\u0026#34;/\u0026#34;+ file.getOriginalFilename())); return \u0026#34;redirect:/index.jsp\u0026#34;; } 文件下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @RequestMapping(value=\u0026#34;/download\u0026#34;) public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址 String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); String fileName = \u0026#34;基础语法.jpg\u0026#34;; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //字符编码 response.setContentType(\u0026#34;multipart/form-data\u0026#34;); //二进制传输数据 //设置响应头 response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34;+URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } 或者直接用a标签\n\u0026lt;a href=\u0026quot;/1.jpg\u0026quot;\u0026gt;点击下载\u0026lt;/a\u0026gt;\n","date":"2021-08-15T09:06:00+08:00","image":"https://lbqaq.top/p/springmvc/65411813.webp","permalink":"https://lbqaq.top/p/springmvc/","title":"SpringMVC学习笔记"},{"content":"花了3天时间，Spring也终于看完了,SSM已经干完了两个了，感觉人都要没了😇。还是老样子，留下笔记以免遗忘。\n下面的内容都是基于遇见狂神说的Spring5视频教程而来，在此感谢能提供这么优秀的教程。\nSpring 简介 Spring就是用来简化Java开发的，只能说学Java不学Spring，就像读四大名著不读红楼梦\u0026hellip;\u0026hellip;\n2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。\n2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。\n很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。\nSpring理念 : 使现有技术更加实用。 本身就是一个大杂烩 , 整合现有的框架技术。\nSSM：SpringMVC+Spring+MyBatis\n几个常用的网址：\n官网\n官方文档（英文）\n中文文档\nGitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 优点 Spring是一个开源免费的框架 , 容器\nSpring是一个轻量级的框架 , 非侵入式的\n控制反转（IoC）,面向切面（Aop）\n对事务的支持 , 对框架的支持\n一句话概括：\nSpring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n拓展 Spring Boot 一套快速配置脚手架 可以基于Spring Boot 快速开发单个微服务 Spring Cloud Spring Cloud是基于Spring Boot实现的 学习路线：Spring -\u0026gt; SpringMVC -\u0026gt; Spring Boot -\u0026gt; Spring Cloud\nIOC理论推导 原先的开发模式：\n先写一个UserDao接口\n1 2 3 public interface UserDao { public void getUser(); } 再去写Dao的实现类\n1 2 3 4 5 6 public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;获取用户数据\u0026#34;); } } 然后去写UserService的接口\n1 2 3 public interface UserService { public void getUser(); } 最后写Service的实现类\n1 2 3 4 5 6 7 8 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 测试一下\n1 2 3 4 5 6 @Test public void test(){ //用户实际调用的是业务层，dao层他们并不需要接触！ UserService service = new UserServiceImpl(); service.getUser(); } 如果需要更换Dao层的实现方法，每次都需要在UserServiceImpl里手动修改new的对象，这样做十分麻烦。\n现在可以使用set接口实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class UserServiceImpl implements UserService { private UserDao userDao; // 利用set进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 以前所有东西都是由程序去进行控制创建。 而现在是由我们自行控制创建对象，把主动权交给了调用者。程序不用去管怎么创建,怎么实现了，它只负责提供一个接口。 这种思想，从本质上解决了问题，我们程序员不再去管理对象的创建了，更多的去关注业务的实现。耦合性大大降低， 这也就是IOC的原型！\nIOC本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\nSpring的工作原理：\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\n第一个Spring程序 添加Maven依赖\n1 2 3 4 5 6 7 8 \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 在pojo包下创建实体类Hello\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package top.lbqaq.pojo; /** * @author luoboQAQ * @Date 2021/8/12 上午 10:49 */ public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \u0026#34;Hello{\u0026#34; + \u0026#34;str=\u0026#39;\u0026#34; + str + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 在resources目录下编写Spring的配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--bean就是java对象 , 由Spring创建和管理 原来是 类型 变量名 = new 类型(); Hello hello = new Hello(); 现在 id=变量名 class=new的对象 property是给变量赋的初值 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; class=\u0026#34;top.lbqaq.pojo.Hello\u0026#34;\u0026gt; \u0026lt;!--引用另外一个bean , 不是用value 而是用 ref--\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import top.lbqaq.pojo.Hello; /** * @author luoboQAQ * @Date 2021/8/12 上午 10:53 */ public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); //我们的对象都在Spring中管理了，我们要使用直接从中取即可 Hello hello = (Hello) context.getBean(\u0026#34;hello\u0026#34;); System.out.println(hello); } } 现在Hello对象由Spring来创建和管理，这个过程就叫控制反转\n控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。\n反转：程序本身不创建对象，而变成被动的接收对象。\n依赖注入：就是利用set方法来进行注入的。\nIOC是一种编程思想，由主动的编程变成被动的接收。\nIOC创建对象方式 通过无参构造函数（默认）\n通过有参构造函数，有三种方式\n下标赋值\n1 2 3 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 用类型赋值（不推荐）\n1 2 3 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 通过参数名创建\n1 2 3 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 在配置文件加载的时候，其中管理的对象都已经初始化了！\nSpring配置 别名（alias） 1 2 \u0026lt;!--设置别名：在获取Bean的时候可以使用别名获取--\u0026gt; \u0026lt;alias name=\u0026#34;user\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt; Bean的配置 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!--bean就是java对象,由Spring创建和管理--\u0026gt; \u0026lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class是bean的全限定名=包名+类名 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; name=\u0026#34;hello2 h2,h3;h4\u0026#34; class=\u0026#34;top.lbqaq.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; import 一般用于团队开发，将多个配置文件合为一个配置文件applicationContext.xml\n1 \u0026lt;import resource=\u0026#34;{path}/beans.xml\u0026#34;/\u0026gt; 依赖注入 概念 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器，Bean对象的依赖资源。 注入 : 指Bean对象所依赖的资源，由容器来设置和装配。 构造器注入 见前面的IOC创建对象方式\nset注入【重点】 测试环境 1 2 3 4 5 6 7 8 9 10 11 public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 1 2 3 4 5 6 7 8 9 10 public class Student { private String name; private Address address; private String[] books; private List\u0026lt;String\u0026gt; hobbys; private Map\u0026lt;String,String\u0026gt; card; private Set\u0026lt;String\u0026gt; games; private String wife; private Properties info; } xml编写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;address\u0026#34; class=\u0026#34;top.lbqaq.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;西安\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;top.lbqaq.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--普通值注入，value--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;!--Bean注入，ref--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;address\u0026#34;/\u0026gt; \u0026lt;!--数组注入--\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;红楼梦\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;西游记\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;水浒传\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;三国演义\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--list--\u0026gt; \u0026lt;property name=\u0026#34;hobbys\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;听歌\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;看电影\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;打游戏\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--map--\u0026gt; \u0026lt;property name=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;身份证\u0026#34; value=\u0026#34;112233445566778899\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;银行卡\u0026#34; value=\u0026#34;123987879172197\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Set--\u0026gt; \u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;LOL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;CSGO\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--null--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Properties--\u0026gt; \u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;driver\u0026#34;\u0026gt;20211213\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;url\u0026#34;\u0026gt;女\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;username\u0026#34;\u0026gt;root\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 具体用法见上面的代码就行了。\n扩展方式注入 p命名空间 导入命名空间\n1 xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; 在bean标签里直接使用\n1 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34;/\u0026gt; 相当于set注入\nc命名空间 导入命名空间\n1 xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; 在bean标签里直接使用\n1 \u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; c:age=\u0026#34;20\u0026#34; c:name=\u0026#34;小红\u0026#34;/\u0026gt; 相当于有参构造函数注入\nBean的作用域 类别 说明 singleton (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。 prototype 将单个 bean 定义的作用域限定为任意数量的对象实例。 request 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring ApplicationContext中有效。 session 将单个 bean 定义的范围限定为 HTTP Session的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 application 将单个 bean 定义的范围限定为ServletContext的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 websocket 将单个 bean 定义的范围限定为WebSocket的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 单例模式（默认）：每次获取的都是同一个对象\n1 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; 原型模式：每次get都是从容器中产生一个新对象\n1 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; 其余request、session、application、websocket这些只在web开发中使用。\nBean的自动装配 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是：\n在xml中显式配置 在java中显式配置 隐式的bean发现机制和自动装配【重要】 环境搭建 1 2 3 4 5 public class Cat { public void shout(){ System.out.println(\u0026#34;miao~\u0026#34;); } } 1 2 3 4 5 public class Dog { public void shout(){ System.out.println(\u0026#34;wang~\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } } ByName自动装配 1 2 3 4 5 6 \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;top.lbqaq.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;top.lbqaq.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;top.lbqaq.pojo.People\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 会自动在容器上下文中查找，和自己对象set方法后面的值相对应的beanid\nByType自动装配 1 2 3 4 5 6 \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;top.lbqaq.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;top.lbqaq.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;top.lbqaq.pojo.People\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 自动在容器上下文中查找，和自己对象属性类型相同的Bean\n小结：\nbyname要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致 bytype的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致 使用注解自动装配 准备工作 导入aop包\n导入约束\n1 2 3 4 xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 配置注解支持\u0026lt;context:annotation-config/\u0026gt;\n@Autowired 在属性或在set方法上使用。\n使用Autowired可以不需要set方法。\n@Autowired是按类型自动转配的。\n@Autowired(required=false) 说明对象可以为null\n@Qualifier 如果环境比较复杂，自动装配无法通过一个@Autowired完成，可以通过@Qualifier(value=\u0026quot;xxx\u0026quot;)来实现。\n@Qualifier相当于byName\n1 2 3 4 5 6 @Autowired @Qualifier(value = \u0026#34;cat2\u0026#34;) private Cat cat; @Autowired @Qualifier(value = \u0026#34;dog2\u0026#34;) private Dog dog; @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 1 2 3 4 5 6 7 8 public class User { //如果允许对象为null，设置required = false,默认为true @Resource(name = \u0026#34;cat2\u0026#34;) private Cat cat; @Resource private Dog dog; private String str; } 小结 @Autowired与@Resource异同：\n@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。\n@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n使用注解开发 使用注解开发需要导入aop的包，导入约束和配置注解支持\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--指定要扫描的包，这个包下的注解就会生效--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt; Bean的实现 1 2 3 4 @Component public class User { public String name = \u0026#34;小明\u0026#34;; } 使用@Component注解，相当于配置文件中的\u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;当前注解的类\u0026quot;/\u0026gt;\n注意需要在配置文件中指定要扫描的包\u0026lt;context:component-scan base-package=\u0026quot;top.lbqaq.pojo\u0026quot;/\u0026gt;\n属性注入 使用@Value注解，相当于配置文件中的\u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;小明\u0026quot;/\u0026gt;\n可以在声明上加，也可以在set方法上加\n1 2 3 4 5 @Component public class User { @Value(\u0026#34;小明\u0026#34;) public String name; } 1 2 3 4 5 6 7 8 9 10 @Component public class User { public String name; @Value(\u0026#34;小明\u0026#34;) public void setName(String name) { this.name = name; } } 衍生注解 对于@Component注解，有三个衍生注解，分别对应MVC的三层。\nDao层：@Repository Service层：@Service Web层：@Controller 这四个注解的作用都是代表将某个类注册到Spring中，装配Bean\n自动装配注解 @Autowired：按类型自动转配 @Qualifier(value=\u0026quot;xxx\u0026quot;)：按name自动装配 @Resource：Java提供的，先name再type，比较复杂 详细的解释可以看上面\n作用域 @Scope\nsingleton：单例模式 prototype：多例模式 1 2 3 4 5 6 @Component @Scope(\u0026#34;prototype\u0026#34;) public class User { @Value(\u0026#34;小明\u0026#34;) public String name; } 小结 XML与注解比较\nXML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 推荐用法\nxml管理Bean 注解完成属性注入 使用Java类进行配置 实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class User { private String name; @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } public String getName() { return name; } @Value(\u0026#34;小明\u0026#34;) public void setName(String name) { this.name = name; } } 配置类\n1 2 3 4 5 6 7 @Configuration public class LbqaqConfig { @Bean public User getUser(){ return new User(); } } 这里的@Configuration表明这是Spring的配置\n@Bean是用来注册bean，这里的返回值就Bean的类型，方法名就是bean的id\n测试\n1 2 3 4 5 6 7 8 public class MyTest { @Test public void test1(){ ApplicationContext context = new AnnotationConfigApplicationContext(LbqaqConfig.class); User user = (User) context.getBean(\u0026#34;getUser\u0026#34;); System.out.println(user.getName()); } } 代理模式 AOP的底层机制就是动态代理。\n静态代理 角色分析\n抽象角色：一般使用接口或者抽象类来实现 真实角色：被代理的角色 代理角色：代理真实角色。代理真实角色后 , 一般会做一些附属的操作。 客户：使用代理角色来进行一些操作。 举例：\nRent.java即抽象角色\n1 2 3 4 //抽象角色：租房 public interface Rent { public void rent(); } Host.java即真实角色\n1 2 3 4 5 6 //真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\u0026#34;房屋出租\u0026#34;); } } Proxy.java即代理角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //代理角色：中介 public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房 public void rent(){ seeHouse(); host.rent(); fare(); } //看房 public void seeHouse(){ System.out.println(\u0026#34;带房客看房\u0026#34;); } //收中介费 public void fare(){ System.out.println(\u0026#34;收中介费\u0026#34;); } } Client.java即客户\n1 2 3 4 5 6 7 8 9 10 11 12 //客户类，一般客户都会去找代理！ public class Client { public static void main(String[] args) { //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); } } 分析：\n在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式。\n静态代理的好处:\n可以使得我们的真实角色更加纯粹，不再去关注一些公共的事情。 公共的业务由代理来完成，实现了业务的分工。 公共业务发生扩展时变得更加集中和方便。 缺点：\n类多了，多了代理类，工作量变大了，开发效率降低。 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想。\n动态代理 动态代理的角色和静态代理的一样。\n动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的\n动态代理分为两类：一类是基于接口动态代理，一类是基于类的动态代理\n基于接口的动态代理\u0026mdash;-JDK动态代理 基于类的动态代理\u0026ndash;cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！ JDK的动态代理需要了解两个类\n核心 : InvocationHandler、Proxy\n代码实现：\n1 2 3 4 //租房 public interface Rent { void rent(); } 1 2 3 4 5 6 7 8 //房东 public class Host implements Rent { @Override public void rent() { System.out.println(\u0026#34;房东要出租\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成得到的代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this); } @Override //处理代理实例，并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //动态代理就是依赖反射实现 Object result = method.invoke(rent, args); return result; } } 1 2 3 4 5 6 7 8 9 10 11 public class Client { public static void main(String[] args) { //真实角色 Host host=new Host(); ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); Rent proxy = (Rent) pih.getProxy(); proxy.rent(); } } 动态代理代理接口\n通用的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } //生成代理类 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String methodName) { System.out.println(\u0026#34;执行了\u0026#34; + methodName + \u0026#34;方法\u0026#34;); } } AOP 什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n通俗点说，就是在不改变原有代码的情况下去增加新的功能。\nAOP在Spring中 提供声明式事务；允许用户自定义切面\n横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 \u0026hellip;. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n使用Spring实现AOP 导入依赖包\n1 2 3 4 5 6 7 \u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 方式一：使用Spring的方法 业务接口和实现类\n1 2 3 4 5 6 public interface UserService { void add(); void delete(); void update(); void select(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\u0026#34;增加一个用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除一个用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;更新一个用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询一个用户\u0026#34;); } } 写两个增强类\n1 2 3 4 5 6 7 8 9 public class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //o : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(o.getClass().getName()+\u0026#34;的\u0026#34;+method.getName()+\u0026#34;被执行了\u0026#34;); } } 1 2 3 4 5 6 7 public class AfterLog implements AfterReturningAdvice { //o:返回值 @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(\u0026#34;执行了\u0026#34;+method.getName()+\u0026#34;方法，返回结果为\u0026#34;+o); } } 配置xml，这里需要引入aop命名空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--注册Bean--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;top.lbqaq.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;log\u0026#34; class=\u0026#34;top.lbqaq.log.Log\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;top.lbqaq.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!--配置aop：需要导入aop约束--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点：expression：表达式 execution()--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;log\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; execution表达式解析：\nexecution(修饰符 返回值 包名.类名/接口名.方法名(参数列表)) 修饰符可以忽略 (..)可以代表所有参数,(*)代表一个参数,(*,String)代表第一个参数为任何值,第二个参数为String类型 最后测试\n1 2 3 4 5 6 7 8 public class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); userService.select(); } } 方法二：使用自定义类来实现 创建自定义类\n1 2 3 4 5 6 7 8 9 public class DiyPointCut { public void before(){ System.out.println(\u0026#34;==========方法执行前==========\u0026#34;); } public void after(){ System.out.println(\u0026#34;==========方法执行后==========\u0026#34;); } } 配置xml\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;bean id=\u0026#34;diy\u0026#34; class=\u0026#34;top.lbqaq.diy.DiyPointCut\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--自定义切面，ref为要引用的类--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;diy\u0026#34;\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;point\u0026#34; expression=\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--通知--\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;point\u0026#34;/\u0026gt; \u0026lt;aop:after method=\u0026#34;after\u0026#34; pointcut-ref=\u0026#34;point\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 方式三：使用注解来实现AOP 在类上标注注解@Aspect，如果没有该注解，就在maven配置里把\u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt;去掉\n在方法前加上@Before()或@After()注解，并在括号中填入表达式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //使用注解实现AOP @Aspect public class AnnotationPointCut { @Before(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;=====方法执行前=====\u0026#34;); } @After(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;=====方法执行后=====\u0026#34;); } //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点 @Around(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); //执行方法 Object proceed = jp.proceed(); System.out.println(\u0026#34;环绕后\u0026#34;); } } 在Spring配置文件注册Bean并开启注解支持\n1 2 3 \u0026lt;bean id=\u0026#34;annotationPointCut\u0026#34; class=\u0026#34;top.lbqaq.diy.AnnotationPointCut\u0026#34;/\u0026gt; \u0026lt;!--开启注解支持--\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; 整合MyBatis 首先要导入相关jar包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;dependencies\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis-spring --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring框架 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- AOP 织入器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 回顾MyBatis 编写实体类\n1 2 3 4 5 6 7 public class User { private int id; private String name; private String pwd; //setter,getter //toString,构造 } 编写Mybatis配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper都需要注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;top.lbqaq.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 编写接口\n1 2 3 public interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); } 编写接口对应的xml文件\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 解决Maven静态资源过滤问题\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class MyTest { @Test public void test() throws IOException { String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.selectUser(); for (User user: userList){ System.out.println(user); } sqlSession.close(); } } MyBatis-Spring MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。官方文档\n整合实现一 引入Spring配置文件spring-dao.xml\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; 配置数据源\n1 2 3 4 5 6 7 8 9 \u0026lt;!--DataSource:使用Spring的数据源替换MyBatis的配置 这里使用Spring提供的JDBC --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 配置SqlSessionFactory,关联MyBatis\n1 2 3 4 5 6 \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:top/lbqaq/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 注册sqlSessionTemplate，关联sqlSessionFactory\n1 2 3 4 \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--使用构造器注入，因为它没有set方法--\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 增加Mapper接口的实现类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class UserMapperImpl implements UserMapper{ //原来我们的所有操作，都使用sqlSession来执行；现在都使用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u0026lt;User\u0026gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); } } 将实现类注册到Spring中\n1 2 3 \u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 测试\n1 2 3 4 5 6 7 8 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;spring-dao.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } } 此时再去看MyBatis的配置文件，里面大部分配置都被Spring整合了\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;/configuration\u0026gt; 这里建议将typeAliases和settings留在MyBatis的配置文件中。\n以后可以将Spring配置文件拆开，spring-dao.xml用来处理数据库相关代码，applicationContext.xml作为总配置文件。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;import resource=\u0026#34;spring-dao.xml\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 整合方式二 使用SqlSessionDaoSupport\n修改实现类，继承SqlSessionDaoSupport\n1 2 3 4 5 6 public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper{ @Override public List\u0026lt;User\u0026gt; selectUser() { return getSqlSession().getMapper(UserMapper.class).selectUser(); } } 配置Bean\n1 2 3 \u0026lt;bean id=\u0026#34;userMapper2\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl2\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 测试\n1 2 3 4 5 6 7 8 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper2\u0026#34;, UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } } 使用这种方法，就不需要上面的第4步了，步骤就更加简洁了。\n声明式事务 spring中的事务：\n编程式事务：在代码中进行事务的管理 声明式事务：AOP 一般我们都采用声明式事务，将事务管理作为横切关注点，通过aop方法模块化。\n使用方法：\n引入头文件约束tx\n1 2 3 4 xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34; 配置事务管理器\n1 2 3 4 \u0026lt;!--配置声明式事务--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 配置事务通知\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!--配置事务通知--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;!--给那些方法配置事务--\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--配置事务的传播特性 propagation--\u0026gt; \u0026lt;tx:method name=\u0026#34;add\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;delete\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;update\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;query\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; Spring的事务的传播特性一共有7种：\npropagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 一般第一种就够用了。\n配置AOP\n注意要导入头文件依赖aop，详细的内容在上面，或者IDEA也会自动补全\n1 2 3 4 5 \u0026lt;!--配置事务切入--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;txPointCut\u0026#34; expression=\u0026#34;execution(* top.lbqaq.mapper.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;txPointCut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; ","date":"2021-08-12T09:38:02+08:00","image":"https://lbqaq.top/p/spring/82968220.webp","permalink":"https://lbqaq.top/p/spring/","title":"Spring学习笔记"},{"content":"因为买了一台云服务器，不拿来干点啥实在是太亏了，于是便想到了可以使用云服务器来挂卡。\n步骤 安装.net环境 ASF是基于.netcore开发的程序，所以需要安装环境。这里建议看微软官方的安装文档，里面有不同系统的安装方法。\n我们需要安装的只是ASP.NET Core 运行时。\n我的系统是centos7，这里就只列举我系统上的命令了。\n1 2 sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install aspnetcore-runtime-5.0 安装ASF 在ASF的发布页面上下载系统对应的版本解压即可。\n我这里是在本地先下载好后用WinSCP直接传上服务器。\n配置ASF 这里就采用官方的**在线配置文件生成器**自动生成即可。\n我们这里选择机器人，将steam的账号和密码填入，并将Enabled设置为True就行了。\n详细的配置内容可以在官方Wiki上看到，这里就不再赘述了。\n下面放上我的配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;SteamLogin\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;SteamPassword\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;Enabled\u0026#34;: true, \u0026#34;CustomGamePlayedWhileFarming\u0026#34;: \u0026#34;挂卡中...\u0026#34;, \u0026#34;CustomGamePlayedWhileIdle\u0026#34;: \u0026#34;空闲中...\u0026#34;, \u0026#34;FarmingOrders\u0026#34;: [ 15, 12 ], \u0026#34;HoursUntilCardDrops\u0026#34;: 0, \u0026#34;OnlineStatus\u0026#34;: 1 } CustomGamePlayedWhileFarming：表示挂卡时显示的游戏名 CustomGamePlayedWhileIdle：表示空闲时显示的游戏名 HoursUntilCardDrops：表示至少将游戏挂到几小时，如果是非限制账户，调到0是最好的。 我们也可以配置ASF本身的设置，这里也同样贴上我的配置：\n1 2 3 4 5 { \u0026#34;s_SteamOwnerID\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;CurrentCulture\u0026#34;: \u0026#34;zh-CN\u0026#34;, \u0026#34;IPCPassword\u0026#34;: \u0026#34;xxx\u0026#34; } s_SteamOwnerID：该属性定义 ASF 进程所有者的 64 位 Steam ID，直接设置成自己的大号就行 CurrentCulture：ASF的语言 IPCPassword：由于ASF默认会开启IPC服务，为了安全起见建议设置密码或关闭IPC服务。 将配置文件放入config目录里就行了。\n启动ASF 首先将ASF的主程序设置为可执行：\n1 sudo chmod 755 ./ArchiSteamFarm 然后运行即可：\n1 ./ArchiSteamFarm 附加步骤 使用ASCF 由于服务器在大陆境内，由于众所周知的原因是无法访问steam社区的，这时就需要使用大佬开发的转发工具了。\n【更新2.0】另一个SteamCommunityFix | 支持Win/Linux/MacOS 【2018-08-29】\n下载地址：https://pan.baidu.com/s/1nvBW8qP\n使用步骤：\n下载并解压缩\n打开终端（Terminal），进入到ascf程序目录： 如ascf程序在 /Users/Makazeu/Downloads/文件夹中，那么在终端中输入\n1 cd /Users/Makazeu/Downloads 赋予程序可执行权限，在终端中输入命令：\n1 chmod +x ./ascf 使用root用户（管理员用户）运行程序，在终端中输入\n1 sudo ./ascf 输入root用户密码后，看程序是否运行 因为程序涉及到hosts文件修改，需要高权限，所以你需要输入root密码\n若程序已经成功运行，此时就不要关闭终端窗口了，否则程序就会退出！试下Steam社区能否正常打开\n使用Tmux 由于我们在服务器上使用，不可能一直开着ssh，这时就需要将终端窗口和会话解绑，Tmux就是做这个工作的。\n安装：\n1 2 3 4 5 6 7 8 # Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux 常用命令/快捷键：\n新建会话：Tmux 窗口默认是以0、1、2\u0026hellip;\u0026hellip;来编号的，为了便于区分，可以为每个会话起名\n1 tmux new -s \u0026lt;session-name\u0026gt; 分离当前会话：Ctrl+b d\n列出所有会话：Ctrl+b s或tmux ls\n重命名当前会话：Ctrl+b $或tmux rename-session -t 0 \u0026lt;new-name\u0026gt;\n接入到某个会话：\n1 2 3 4 5 # 使用会话编号 $ tmux attach -t 0 # 使用会话名称 $ tmux attach -t \u0026lt;session-name\u0026gt; 切换到某个会话：\n1 2 3 4 5 # 使用会话编号 $ tmux switch -t 0 # 使用会话名称 $ tmux switch -t \u0026lt;session-name\u0026gt; 参考链接 Tmux 使用教程 - 阮一峰的网络日志 ASF官方Wiki NET开发文档 ","date":"2021-08-11T21:46:24+08:00","image":"https://lbqaq.top/p/asf/82970659.webp","permalink":"https://lbqaq.top/p/asf/","title":"从零开始ASF挂卡"},{"content":"花了四天的时间，终于把MyBatis的视频教程全部看完了，为了以后不要那么快的遗忘掉，还是来写一下笔记比较好。\n下面的内容都是基于遇见狂神说的MyBatis视频教程而来，在此感谢能提供这么优秀的教程。\n简介 MyBatis的作用用我自己的话说，就是不用自己手动搞JDBC了，省事，行！ MyBatis作用于持久层——DAO层 【DAO (Data Access Object) 数据访问对象】，通俗点说就是用来操作数据库的层 选择MyBatis的最大原因还是用的人多，为后面的Spring打基础_(:з)∠)_ 第一个MyBatis程序 思路流程：搭建环境\u0026ndash;\u0026gt;导入MyBatis\u0026mdash;\u0026gt;编写代码\u0026mdash;\u0026gt;测试\n具体代码 创建Maven项目\n引入依赖包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- 导入依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 在resources目录下创建mybatis-config.xml，作为MyBatis的配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper都需要注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 编写MyBatis工具类，在utils的包下面创建MybatisUtils类，填入以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //SqlSessionFactory /** * @author luoboQAQ */ public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步：获取SqlSessionFactory String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } 在pojo包下创建实体类\n1 2 3 4 5 6 7 8 9 public class User { private int id; //id private String name; //姓名 private String pwd; //密码 //构造,有参,无参 //set/get //toString() } 在dao包下创建接口类，我们需要的功能就填入到这里面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import top.lbqaq.pojo.User; import java.util.List; import java.util.Map; public interface UserMapper { //模糊查询 List\u0026lt;User\u0026gt; getUserLike(String value); //查询全部用户 List\u0026lt;User\u0026gt; getUserList(); //根据ID查询用户 User getUserById(int id); //插入用户 int addUser(User user); int addUser2(Map\u0026lt;String,Object\u0026gt; map); //修改用户 int updateUser(User user); //删除用户 int deleteUser(int id); } 编写Mapper.xml配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!--namespace绑定一个对应的Dao/Mapper接口--\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--id就是namespace中对应的方法名，resultType：sql语句的返回值--\u0026gt; \u0026lt;select id=\u0026#34;getUserList\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;getUserLike\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name like #{value} \u0026lt;/select\u0026gt; \u0026lt;!--parameterType：传入参数类型--\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) \u0026lt;/insert\u0026gt; \u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; update user set name =#{name},pwd=#{pwd} where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from user where id=#{id} \u0026lt;/delete\u0026gt; \u0026lt;/mapper\u0026gt; 进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 import org.apache.ibatis.session.SqlSession; import org.junit.Test; import top.lbqaq.pojo.User; import top.lbqaq.utils.MybatisUtils; import java.util.HashMap; import java.util.List; public class UserMapperTest { @Test public void test() { //获得sqlSession对象 try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserList(); for (User user : userList) { System.out.println(user); } } } @Test public void getUserLike() { //获得sqlSession对象 try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserLike(\u0026#34;%李%\u0026#34;); for (User user : userList) { System.out.println(user); } } } @Test public void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } @Test public void addUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.addUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务 sqlSession.commit(); } sqlSession.close(); } @Test public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u0026lt;String,Object\u0026gt; map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;userid\u0026#34;,5); map.put(\u0026#34;userName\u0026#34;,\u0026#34;小绿\u0026#34;); map.put(\u0026#34;passWord\u0026#34;,\u0026#34;1234\u0026#34;); int res = mapper.addUser2(map); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务 sqlSession.commit(); } sqlSession.close(); } @Test public void updateUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.updateUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123456\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务 sqlSession.commit(); } sqlSession.close(); } @Test public void deleteUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.deleteUser(4); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务 sqlSession.commit(); } sqlSession.close(); } } 注意事项 如果Mapper.xml创建在java目录里而不是resouces里，需要在Maven配置里配置过滤，否则会保错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; 当需要传入参数进行查询而不是传入实体类，有两种方法\n第一种：直接在方法中传递参数。\n在接口方法的参数前加@Param属性，sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型\n1 2 3 4 5 6 7 User selectUserByNP(@Param(\u0026#34;username\u0026#34;) String username,@Param(\u0026#34;pwd\u0026#34;) String pwd); /* \u0026lt;select id=\u0026#34;selectUserByNP\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; */ 第二种：通过map来传递参数。（推荐）\n在接口创建时就直接使用map作为参数\n1 int addUser2(Map\u0026lt;String,Object\u0026gt; map); 在写sql时直接设置入参为map即可\n1 2 3 4 \u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt; 配置解析 官方文档\n核心配置 MyBatis官方给出的配置项有以下这么多：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） \u0026lt;!-- 注意元素节点的顺序！顺序不对会报错 --\u0026gt; 我们需要关注的就是properties（属性）、settings（设置）、typeAliases（类型别名）、plugins（插件）、environments（环境配置）、mappers（映射器）这几项配置，其余的可以忽略（基本用不到）\nproperties 数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。\n说白了，就是能将数据库那些配置项从核心配置中剥离出来，降低耦合。\n用法 在resources目录下创建db.properties，填入下面的内容\n1 2 3 4 driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis username=root password=root 在配置xml中导入\n1 2 3 4 5 6 \u0026lt;!--引用外部配置文件--\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt; \u0026lt;!--外部文件优先级大于内部（下面）--\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123\u0026#34;/\u0026gt; \u0026lt;/properties\u0026gt; 正常情况下，只需要用\u0026lt;properties resource=\u0026quot;db.properties\u0026quot;/\u0026gt;这短短一句就行了，上面的代码是用来测试优先级的\nsettings 这里存放的是MyBatis的一些设置项，具体的内容在官方文档上可以查看\n常用的设置项有以下几个：\n设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 typeAliases 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。\n也就是在resultType和parameterType中不需要写那么长的类名了\n用法 1 2 3 4 5 6 7 \u0026lt;!--可以给实体类起别名--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!--手动指定--\u0026gt; \u0026lt;typeAlias type=\u0026#34;top.lbqaq.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;!--自动扫描包下所有类，别名为类名全小写--\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 有两种方法，第一种就是手动指定别名，第二种就是通过package标签自动扫描包下所有的类\n在第二种方法下，默认别名是类名全小写（当然首字母大写也同样可用）\n如果在类前加上@Alias注解，则别名就为手动设定的内容。\nplugins 这里是配置mybatis的插件的地方，常用的插件有以下几个：\nPageHelper MyBatis-Plus \u0026hellip; \u0026hellip; 这里是就不展开这些插件了，以后有需要再看\nenvironments 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; transactionManager： 事务管理器 。有两个选项： JDBC：正常的 MANAGED：几乎啥都不干 dataSource：如何使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三个选项： unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 mappers 用于告诉MyBatis我们写的xml文件到底在哪，每个xml文件都需要绑定！\n常用的有以下几种方法：\n1 2 3 4 \u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;top/lbqaq/dao/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 1 2 3 4 5 6 7 \u0026lt;!-- 使用映射器接口实现类的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 1 2 3 4 5 6 7 \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;org.mybatis.builder\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; ResultMap 属性名和字段名不一致 在实际开发中，会遇到类的属性名和数据库的字段名不一致，这时MyBatis的自动匹配将无法产生作用，这时可以使用ResultMap来解决这个问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--结果集映射--\u0026gt; \u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!--column:数据库中的字段；property：实体类的属性--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 多对一 在开发时常常会有这样的需求，比如多个学生都被一个老师教，下面将对该实例具体展开来了解多对一如何处理。\n环境搭建 添加Lombok插件\n引入Maven依赖\n1 2 3 4 5 6 7 8 9 \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.20\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写实体类\n1 2 3 4 5 6 7 8 9 10 @Data public class Student { private int id; private String name; /** * 学生需要关联一个老师 */ private Teacher teacher; } 1 2 3 4 5 @Data public class Teacher { private int id; private String name; } 按查询嵌套处理 思路：\n获取所有学生的信息\n根据获取的学生信息的老师ID-\u0026gt;获取该老师的信息\n思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？\n做一个结果集映射：StudentTeacher StudentTeacher结果集的类型为 Student 学生中老师的属性为teacher，对应数据库中为tid。 多个 [1,\u0026hellip;）学生关联一个老师=\u0026gt; 一对一，一对多 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;select id=\u0026#34;getStudent\u0026#34; resultMap=\u0026#34;StudentTeacher\u0026#34;\u0026gt; select * from student \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--复杂的属性需要单独处理 对象：association 集合：collection--\u0026gt; \u0026lt;association column=\u0026#34;tid\u0026#34; property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;Teacher\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; 注意点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;{id=tid,name=tid}\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=\u0026#34;{key=value,key=value}\u0026#34; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;teacher\u0026#34;\u0026gt; select * from teacher where id = #{id} and name = #{name} \u0026lt;/select\u0026gt; 这个还是比较难以理解的，一般我选择用第二种方法\n按结果嵌套处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!--按照结果嵌套处理--\u0026gt; \u0026lt;select id=\u0026#34;getStudent2\u0026#34; resultMap=\u0026#34;StudentTeacher2\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher2\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 这种就比较好理解了，难度主要在sql部分，好在之前数据库学的还行，这种方法还是比较适合我。\n一对多 一个老师会教多个学生。\n环境搭建 1 2 3 4 5 6 @Data public class Student { private int id; private String name; private int tid; } 1 2 3 4 5 6 7 8 9 10 @Data public class Teacher { private int id; private String name; /** * 一个老师有多个学生 */ private List\u0026lt;Student\u0026gt; students; } 按结果嵌套查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!--按结果嵌套查询--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;TeacherStudent\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--集合中的泛型信息用ofType获取--\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;tid\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; JavaType和ofType都是用来指定对象类型的。\nJavaType是用来指定pojo中属性的类型。\nofType指定的是映射到list集合属性中pojo的类型。\n按查询嵌套 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--按查询嵌套--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher2\u0026#34; resultMap=\u0026#34;TeacherStudent2\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent2\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; select=\u0026#34;getStudentByTeacherId\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getStudentByTeacherId\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt; select * from student where tid = #{tid} \u0026lt;/select\u0026gt; 日志工厂 如果一个数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。可见打印出SQL语句是十分重要的。（还记得之前项目综合实践为了搞日志忙了半天，结果还是没搞出来😭）\n标准日志 在MyBatis里自带了通过控制台打印的日志功能，如果项目并不是很复杂，用它就足够了。\n只需要在设置里设置启用就可以了。\n1 2 3 \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; log4j log4j相比标准日志，那不知道高到哪里去了，具体的功能我就不写了，毕竟一百度就能出来了。\n使用步骤：\n导入log4j的包\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在resources目录下新建log4j.properties，并填入以下配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/log.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 在MyBatis里启用\n1 2 3 \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 在程序中使用Log4j进行输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 import org.apache.log4j.Logger; import org.junit.Test; public class UserMapperTest { static Logger logger = Logger.getLogger(UserMapperTest.class); @Test public void testLog4j(){ logger.info(\u0026#34;info:进入了testLog4j\u0026#34;); logger.debug(\u0026#34;debug:进入了testLog4j\u0026#34;); logger.error(\u0026#34;error:进入了testLog4j\u0026#34;); } } 使用注解开发 MyBatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。\n而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建。\n在注解开发中，主要使用这几个注解：@select ()、@update ()、@Insert ()、@delete ()\n举例：\n1 2 3 4 5 6 7 8 9 10 11 public interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; getUser(); @Select(\u0026#34;select * from user where id=#{id}\u0026#34;) User getUserByID(@Param(\u0026#34;id\u0026#34;) int id); @Insert(\u0026#34;insert into user(id,name,pwd) values(#{id},#{name},#{pwd})\u0026#34;) int addUser(User user); } 改造MybatisUtils工具类的getSession() 方法，重载实现。\n1 2 3 4 5 6 7 8 //获取SqlSession连接 public static SqlSession getSession(){ return getSession(true); //事务自动提交 } public static SqlSession getSession(boolean flag){ return sqlSessionFactory.openSession(flag); } @Param注解用于给方法参数起一个名字。以下是总结的使用原则：\n在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是JavaBean。 动态SQL 动态SQL指的是根据不同的查询条件 , 生成不同的sql语句。\n主要使用这几个标签：if、choose、where、set、foreach\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.BlogMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;addBook\u0026#34; parameterType=\u0026#34;Blog\u0026#34;\u0026gt; insert into blog(id, title, author, create_time, views) values (#{id}, #{title}, #{author}, #{createTime}, #{views}) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;queryBlogIF\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;queryBlogChoose\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and views = #{view} \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; update blog \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; \u0026lt;select id=\u0026#34;queryBlogForeach\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!--collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt; id = #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。\n提取SQL片段：\n1 2 3 4 5 6 7 8 \u0026lt;sql id=\u0026#34;if-title-author\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt; 引用SQL片段：\n1 2 3 4 5 6 7 8 \u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --\u0026gt; \u0026lt;include refid=\u0026#34;if-title-author\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;!-- 在这里还可以引用其他的 sql 片段 --\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意：\n①、最好基于 单表来定义 sql 片段，提高片段的可重用性\n②、在 sql 片段中不要包括 where\n缓存 简介 1、什么是缓存 [ Cache ]？\n存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 2、为什么使用缓存？\n减少和数据库的交互次数，减少系统开销，提高系统效率。 3、什么样的数据能使用缓存？\n经常查询并且不经常改变的数据。 MyBatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\nMyBatis系统中默认定义了两级缓存：一级缓存和二级缓存\n默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存：\n与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 一级缓存失效的四种情况 sqlSession不同 sqlSession相同，查询条件不同 sqlSession相同，两次查询之间执行了增删改操作！ sqlSession相同，手动清除一级缓存 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n工作机制\n一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 使用方法 开启全局缓存 mybatis-config.xml\n1 \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; 去每个mapper.xml中配置使用二级缓存，这个配置非常简单。\n1 2 3 4 5 6 7 8 9 \u0026lt;cache/\u0026gt; 官方示例 \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 ","date":"2021-08-11T11:11:10+08:00","image":"https://lbqaq.top/p/mybatis/86164137.webp","permalink":"https://lbqaq.top/p/mybatis/","title":"MyBatis学习笔记"},{"content":"这篇文章我打算来介绍一下如何构建qsqlmysql.dll，由于版权原因，在新版的Qt里是不自带该dll的，这样对我们编写数据库程序会很麻烦。（你用ODBC？那没事了）\n我在网上也查了很多资料，但根据步骤来总是会报错，提示没有mysql.h这个头文件。下面就记录一下我成功编译的过程。\n基于cmake的步骤 在6.1之后的Qt版本中，Qt公司删除了qmake而更换成了cmake的方式来构建项目文件，下面就是我总结的使用cmake生成的方法。\n注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.打开cmake-gui，选择目标文件夹为D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers，并设置生成文件夹为D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build\n3.点击左下角的Configure，会提示生成的目录不存在是否创建，直接点是就可以了。\n4.编译器这里选择MinGW Makefiles,然后点击Finish\n5.等待生成完成后，把FEATURE_sql_mysql后面的勾勾上，然后把其余的FEATURE_sql后面的勾取消。\n6.再次点击左下角的Configure，可以发现上面的红框已经消失了，说明配置成功了。然后点击Generate，生成Makefiles。\n7.这时配置文件已经构建完成了，接下来就是生成dll了，打开PowerShell切换目录至D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build，输入mingw32-make开始编译生成dll。\n没有报错，说明生成成功。\n8.最后打开目录D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers\\build\\plugins\\sqldrivers，就可以看到生成好的qsqlmysql.dll了。\n基于qmake的步骤 注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.进入D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins\\sqldrivers目录下，打开sqldrivers.pro这个文件。\n3.在左侧文件树中打开mysql文件夹，选择mysql.pro打开。\n4.修改里面的内容：\n注释掉QMAKE_USE += mysql这一句\n增加下面三行代码(注意把D:/MySQL/改为你MySQL的安装路径)：\n1 2 3 LIBS +=-LD:/MySQL/lib -llibmysql INCLUDEPATH += D:/MySQL/include DEPENDPATH += D:/MySQL/include 5.点击Qt左下角的小锤子进行构建，不出意外的话就可以在D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins这个路径下看到build开头的文件夹，在.\\plugins\\sqldrivers目录下就能看到编译好的dll了。\n6.最后将qsqlmysql.dll放入D:\\Qt\\6.0.3\\mingw81_64\\plugins\\sqldrivers\\里就行了。如果链接数据库时还报错，就把libmysql.dll复制到Qt的编译器的D:\\Qt\\6.0.3\\mingw81_64\\bin\\目录。\n","date":"2021-06-03T15:44:17+08:00","image":"https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/89217963.webp","permalink":"https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/","title":"Qt构建qsqlmysql.dll"},{"content":"1202年了，是时候抛弃老旧的cmd窗口和臃肿的VM虚拟机了，来试试巨硬推出的WSL2+Windows Terminal(～￣▽￣)～。\n起因 在知乎上刷到了一篇回答，是关于Windows编程的体验的。在这篇文章中提到了WSL2和Windows Terminal，我一下就被那精美的界面吸引了（管他好不好用，好看就完事了）。正好现在在上操作系统这门课，需要使用Linux进行实验，这还说什么，直接开冲。\nWSL2安装 安装其实很简单，按照微软的教程一步一步做就完事了。\n0.前置条件 想要用WSL2，首先你得是 Windows 10，而且还有版本号要求。\n对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。 1. 开启WSL服务 在Powershell(管理员)中输入下面的命令：\n1 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2. 启用虚拟机服务 在Powershell(管理员)中输入下面的命令：\n1 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。\n3. 下载 Linux 内核更新包 下载最新包并安装：\n适用于 x64 计算机的 WSL2 Linux 内核更新包 4. 将 WSL 2 设置为默认版本 在Powershell中输入下面的命令：\n1 wsl --set-default-version 2 5.安装 Linux 打开 Microsoft Store，并选择你偏好的 Linux 分发版并点击获取进行安装。 等安装好后，打开并设置用户名和密码。 到此WSL2就安装完事了。\nWindows Terminal安装 1. 下载和安装 从Microsoft Store中下载\n从Github上下载\n2. 配置 为了让Windows Terminal看起来更好看一些，我们还要对其进行一些配置。\n打开Windows Terminal的设置选项，然后选打开JSON文件，把我配好的配置文件粘贴进去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 { \u0026#34;$schema\u0026#34;: \u0026#34;https://aka.ms/terminal-profiles-schema\u0026#34;, // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \u0026#34;unbound\u0026#34;. // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \u0026#34;actions\u0026#34;: [ // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json. // These two lines additionally bind them to Ctrl+C and Ctrl+V. // To learn more about selection, visit https://aka.ms/terminal-selection { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;copy\u0026#34;, \u0026#34;singleLine\u0026#34;: false }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+c\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;paste\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+v\u0026#34; }, // Press Ctrl+Shift+F to open the search box { \u0026#34;command\u0026#34;: \u0026#34;find\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+f\u0026#34; }, // Press Alt+Shift+D to open a new pane. // - \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34; makes this pane open in the direction that provides the most surface area. // - \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; makes the new pane use the focused pane\u0026#39;s profile. // To learn more about panes, visit https://aka.ms/terminal-panes { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;splitPane\u0026#34;, \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;alt+shift+d\u0026#34; } ], \u0026#34;copyFormatting\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;copyOnSelect\u0026#34;: false, \u0026#34;defaultProfile\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;initialCols\u0026#34;: 120, \u0026#34;initialRows\u0026#34;: 30, \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34;: 0.75, \u0026#34;closeOnExit\u0026#34;: \u0026#34;graceful\u0026#34;, \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;cursorShape\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;fontFace\u0026#34;: \u0026#34;Consolas\u0026#34;, \u0026#34;fontSize\u0026#34;: 13, \u0026#34;historySize\u0026#34;: 9001, \u0026#34;padding\u0026#34;: \u0026#34;0, 0, 0, 0\u0026#34;, \u0026#34;snapOnInput\u0026#34;: true, \u0026#34;startingDirectory\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;useAcrylic\u0026#34;: true }, \u0026#34;list\u0026#34;: [ { \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe -NoLogo\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Windows PowerShell\u0026#34; }, { \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Command Prompt\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{2c4de342-38b7-51cf-b940-2309a097f518}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Ubuntu\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu/home/luobo\u0026#34; } ] } } 一般要修改这几项：\nfontFace - 字体，我的字体为Consolas，适合1080P的屏幕。高分辩率屏建议用monaco或者fira code fontSize - 字体大小，因人而异，因屏幕而异，自己根据视觉效果调整大小 acrylicOpacity - 背景透明度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialCols - 初始窗口宽度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialRows - 初始窗口高度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 startingDirectory - Ubuntu的默认打开路径，把其中的luobo换成你自己的用户名。 WSL+VSCode 毕竟都是微软家的软件，直接就能通过VSCode来远程编辑Linux里的文件。vim太难上手？我直接在Windows里编程(雾)。\n只要在项目目录里键入code .，就会自动跳到Windows里的VSCode里了。\n小结 WSL+Windows Terminal+VSCode，将三者配合起来，我觉得可以实现1+1+1\u0026gt;3的功能，毕竟，谁不喜欢颜值高的软件呢ヾ(≧▽≦*)o\n参考链接 微软官方WSL2教程 微软官方Windows Terminal教程 Windows Terminal 终端入门 ","date":"2021-04-08T13:14:20+08:00","image":"https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/43493473.webp","permalink":"https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/","title":"WSL2+WT配置小结"},{"content":"看到zsnmwy大佬的博客，和我使用的是同样的主题，但是人家却多了一些动画，瞬间就高级起来了。于是打开百度搜素一波，发现只要改一下CSS就可以实现了。\n准备工具 hugo的扩展版（extended）\n这里一定要下扩展版，因为我使用的主题都是利用scss来生成css的，如果用普通版是无法利用scss生成对应的css的。之前不知道下的是普通版，结果怎么改scss都没有效果，浪费了很多时间😥。\n23.7.13更新 现在优化了主题的编写方式，不需要修改原始的主题文件，降低了代码耦合😉。\n只需要在HUGO_SITE_FOLDER/assets/scss/custom.scss文件里填写下面的内容就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 :root { --article-background: #f0f8ff; \u0026amp;[data-scheme=\u0026#34;dark\u0026#34;] { --article-background: #292d30; } } // 文章列表 .article-list--compact article { //增加动画 transition: .5s ease; \u0026amp;:hover { transform: scale(1.02, 1.02); background: var(--article-background); } .article-image img { // 变成长方形 width: calc(var(--image-size) * 5 / 3); // 增加圆角 border-radius: var(--card-border-radius); } } //头像 .sidebar header .site-avatar .site-logo { transition: all 1.75s ease-out; \u0026amp;:hover { transform: rotate(360deg); } } //菜单栏 .menu { //把auto改为visible，为了图标放大溢出时不显示滚动条 overflow-y: visible; li { transition: .5s ease; \u0026amp;:hover { transform: scale(1.1, 1.1); } } } //文章头图 .article-list article .article-image { //避免出现滚动条 overflow: hidden; img { //设置图片缩放 transition: all .5s ease; \u0026amp;:hover { transform: scale(1.2); } @include respond(xl) { //加大图片高度 height: 385px; } } } //友情链接三栏 (From https://blog.linsnow.cn/p/join-hugo-and-stack/) @media (min-width: 1024px) { .article-list--compact.links { display: grid; grid-template-columns: 1fr 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; border-radius: var(--card-border-radius); \u0026amp;:nth-child(odd) { margin-right: 8px; } .article-image img { // 恢复成正方形 width: var(--image-size); } } } } 同时增加了一些特效，这里就不展开说了🕊️\n相关代码 1.头像转动 在themes/hugo-theme-stack/assets/scss/partials/sidebar.scss中增加以下代码：\n1 2 3 4 5 6 7 .site-logo { transition: all 1.75s ease-out; } .site-logo:hover { transform: rotate(360deg); } 2.文章头图缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\n1 2 3 4 5 6 7 8 9 10 .article-image { overflow:hidden; } .article-image { img { transition:all .5s ease; } \u0026amp;:hover{ transform:scale(1.2); } 3.Archives页面缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\n1 2 3 4 5 6 7 8 9 article{ transition:.5s ease; } article { \u0026amp;:hover{ transform:scale(1.05,1.05); background:#f0f8ff; } } 4.菜单缩放 在themes/hugo-theme-stack/assets/scss/partials/menu.scss中增加以下代码：\n1 2 3 4 5 6 7 8 9 overflow-y: visible; //把auto改为visible，为了图标放大溢出时不显示滚动条 li { transition:.5s ease; } li{ \u0026amp;:hover{ transform:scale(1.1,1.1); } } 有了动画后，感觉整个博客都变得高级起来了ヾ(•ω•`)o\n在这感谢zsnmwy大佬，上面有些动画懒得自己写了，就直接从他的css中复制了ヾ(￣▽￣)\n","date":"2021-02-01T13:55:05+08:00","image":"https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/86589864.webp","permalink":"https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/","title":"给Blog增加动画"},{"content":"最近刷了好几道关于STL的竞赛题，许多知识点还是不熟练，在继续学习之前，还是来好好整理一下一些常见的STL和容器吧。紫书上介绍的有以下几种：\n线性：vector,list,string 关联：map,set 特殊：stack,queue,priority_queue 算法：sort,lower_bound,find vector vector可以理解为可以自由变换长度的数组(不定长数组)，个人感觉使用频率还是很高的。vector是连续的，意味着可以使用[]或at()。\n声明： vector\u0026lt;int\u0026gt; a\n常用函数 push_back：在尾部添加一个数据\npop_back：删除尾部的一个数据\nsize：当前的大小（就是有多少元素）\nerase：删除指针指向的数据项\nclear：清空\nempty：判断是否为空\ndeque deque可以看作是双向队列，是连续存储结构。vector有的功能它都有，还支持高效的首/尾端插入/删除操作。\n新增函数 push_front：在头部添加一个数据 pop_front：在头部删除一个数据 list list可以看作是双链表，是非连续存储结构。可在两端进行push、pop，同时在内部可以很方便的进行插入和删除操作。不过我没怎么用到这个容器。等我做到相关的题目再来补充一些信息吧。\nstring string就是字符串。相比char[]那可是方便不少，c++的cin/cout就只支持string类型而不支持char型数组。string还支持+、=、+=等运算符。\n常用函数 append：在字符串后添加（相当于+=）\nsubstr(n,m)：返回string的子串，从n处开始，取m个。当m省略或超过了字符串的长度，则一直取到字符串结束。\n查找相关函数：\n如果没有查到，返回string::npos。\nfind：从前往后查找子串或字符出现的位置。\nrfind：从后往前查找子串或字符出现的位置。\nfind_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：\ns1.find_first_of(\u0026ldquo;abc\u0026rdquo;); //查找s1中第一次出现\u0026quot;abc\u0026quot;中任一字符的位置\nfind_last_of：从后往前查找何处出现另一个字符串中包含的字符。\nfind_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。\nfind_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。\n流处理 可以通过\u0026lt;sstream\u0026gt;，将string对象作为一个流。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string line; while(getline(cin,line)){ stringstream ss(line); while(ss\u0026gt;\u0026gt;x){...} } } set set就是数学中的集合，每个元素只能出现一次，set中的元素已经从小到大排好了。\n常用函数 insert：插入一个元素 erase：删除，可以传入定位器，也可直接传入值 count：统计元素出现的个数，因为只有0/1个，所以一般用来判断元素是否存在 find：查找 对于自己定义的结构体，需要重载\u0026lt;运算符。\n常用算法 在\u0026lt;algorithm\u0026gt;中提供了关于set的两种算法（目前只知道两种）\nset_union：取两个集合的并集，例如：\n1 2 3 #define ALL(x) x.begin(),x.end() #define INS(x) inserter(x,x.begin()) set_union(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取并集后放入x中 set_intersection：取两个集合的交集，例如：\n1 set_intersection(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取交集放入x中 map map是映射，支持[]运算符，还是非常实用的。\nmap的函数和set基本一致，这里就不重复写了。\nstack stack就是数据结构中的栈，数据是“后进先出”。\n基本函数 push：入栈 pop：出栈 top：取栈顶元素 要注意的是，使用pop()出栈并不会返回被删除的元素值，如果想要需要先top()一下\nqueue queue就是数据结构里的队列，数据符合“先进先出”的规则。\n基本函数 push：入队\npop：出队\nfront：取队首\npriority_queue 优先队列，将按照优先级来排序，取队首的front()的函数将换为top()。该容器也定义在头文件\u0026lt;queue\u0026gt;里。\n对于自定义数据类型的队列，需要定义\u0026lt;运算。对于已经定义过的数据类型，我们可以通过定义一个结构体，在其中重载()运算符来看起来像一个函数，例如：\n1 2 3 4 5 6 7 8 struct cmp { bool operator()(const int a, const int b) const { return abs(a) \u0026lt; abs(b); } }; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, cmp\u0026gt; p_queue; 这样就定义了一个绝对值大小优先的队列\n","date":"2021-01-31T20:39:29+08:00","image":"https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/85526504.webp","permalink":"https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/","title":"竞赛用STL整理"},{"content":"考前整理的算法，也顺便放到博客上吧ヾ(•ω•`)o\n数据结构代码复习 3.单链表逆置 带头结点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int Inverse_Link(LinkList *L) { LinkList *cur, *p; if (L-\u0026gt;next \u0026amp;\u0026amp; L-\u0026gt;next-\u0026gt;next) { p = L-\u0026gt;next-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = NULL; while (p) { cur = L-\u0026gt;next; L-\u0026gt;next = p; p = p-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = cur; } } return 0; } 5.双向链表 双链表定义：\n1 2 3 4 5 6 typedef struct DuLinkList { int data; struct DuLinkList *prior; struct DuLinkList *next; } DuLinkList; 遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Printlist_DuL(DuLinkList *L) { DuLinkList *s; s = L-\u0026gt;next; if (L-\u0026gt;next != NULL) { printf(\u0026#34;当前的双向链表值为：\u0026#34;); do { printf(\u0026#34;%d \u0026#34;, s-\u0026gt;data); s = s-\u0026gt;next; } while (s != NULL); } printf(\u0026#34;\\n\u0026#34;); } 交换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int ListSwap_DuL(DuLinkList *L, int i) { //在带头结点的双向链表中交换第i个，i+1个位置的元素 DuLinkList *p = L, *q; int j = 0; while (p \u0026amp;\u0026amp; j \u0026lt; i - 1) { p = p-\u0026gt;next; j += 1; } if (!p || j \u0026gt; i - 1) return -1; p = p-\u0026gt;next; q = p-\u0026gt;next; p-\u0026gt;prior-\u0026gt;next = q; //1 -\u0026gt;q p 2 q-\u0026gt;prior = p-\u0026gt;prior; //1\u0026lt;--\u0026gt;q p 2 p-\u0026gt;next = q-\u0026gt;next; //1\u0026lt;--\u0026gt;q p -\u0026gt;2 q-\u0026gt;next-\u0026gt;prior = p; //1\u0026lt;--\u0026gt;q p\u0026lt;--\u0026gt;2 q-\u0026gt;next = p; //1\u0026lt;--\u0026gt;q -\u0026gt;p\u0026lt;--\u0026gt;2 p-\u0026gt;prior = q; //1\u0026lt;--\u0026gt;q\u0026lt;--\u0026gt;p\u0026lt;--\u0026gt;2 return 0; } 6.链表回文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool isPalindrome(struct ListNode *head) { Lstack *s; int e; struct ListNode *p = head; s = (Lstack *)malloc(sizeof(Lstack)); Initlist_Stack(s); while (p) { push(s, p-\u0026gt;val); p = p-\u0026gt;next; } p = head; while (p) { e = pop(s); if (p-\u0026gt;val != e) break; p = p-\u0026gt;next; } if (p) return false; else return true; } 7-1.链队列 定义：\n1 2 3 4 5 6 7 8 9 10 11 typedef struct QNode //队列 { int data; struct QNode *next; } QNode; typedef struct LinkQueue //对列相关的指针 { QNode *front; //对头指针 QNode *rear; //队尾指针 } LinkQueue; 插入：\n1 2 3 4 5 6 7 8 9 10 11 int EnQueue(LinkQueue *q, int e) { //[入队]将元素e放入队尾，带头结点 QNode *p; p = (QNode *)malloc(sizeof(QNode)); p-\u0026gt;data = e; p-\u0026gt;next = NULL; q-\u0026gt;rear-\u0026gt;next = p; q-\u0026gt;rear = p; return 0; } 7-2.循环链表 插入和普通单链表没区别，这里就列举部分\n1 2 3 4 s = (LinkList *)malloc(sizeof(LinkList)); s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = s; 8.求二叉树各种数的算法 （1）求高度 高度很简单，来个递归就完事了\n1 2 3 4 5 6 7 8 9 10 11 12 13 int BiTreeHeight(BiTNode *T) { //求二叉树的高度 int treeHeight = 0; if (T != NULL) { int leftHeight = BiTreeHeight(T-\u0026gt;lchild); int rightHeight = BiTreeHeight(T-\u0026gt;rchild); treeHeight = leftHeight \u0026gt;= rightHeight ? leftHeight + 1 : rightHeight + 1; } return treeHeight; } （2）求叶子数 叶子数也一样，递归永远滴神\n1 2 3 4 5 6 7 8 9 10 void BiTreeLeafCount(BiTNode *T, int *count) { //求二叉树叶子结点数 if (!T) return; if (T-\u0026gt;lchild == NULL \u0026amp;\u0026amp; T-\u0026gt;rchild == NULL) *count += 1; BiTreeLeafCount(T-\u0026gt;lchild, count); BiTreeLeafCount(T-\u0026gt;rchild, count); } （3）求结点数 这不就遍历嘛，直接看下面吧=￣ω￣=\n9.二叉树的中序遍历 递归：\n1 2 3 4 5 6 7 8 9 int InOrderTraverse(BiTNode *T) { //中序遍历二叉树T的递归算法 if (T == NULL) return 0; InOrderTraverse(T-\u0026gt;lchild); printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); InOrderTraverse(T-\u0026gt;rchild); } 非递归（重要）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int inorder(BiTNode *T) { //中序遍历二叉树T的非递归算法 BiTNode *s[MAXSIZE + 1]; int top = 0; while (T != NULL || top != 0) { while (T != NULL) { s[++top] = T; T = T-\u0026gt;lchild; } if (top != 0) { T = s[top--]; printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); T = T-\u0026gt;rchild; } } return 0; } 10.二叉排序树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int Search_BST(BSTree t, int key, BSTree f, BSTree *p) { //在指针t所指的二叉排序树上查找key，成功则p指向该元素数据结点并返回0 //否则p指向查找路径上最后一个结点并返回1，f指向T的双亲，初始值为NULL if (!t) { *p = f; return 1; } else if (key == t-\u0026gt;data) { *p = t; return 0; } else if (key \u0026lt; t-\u0026gt;data) { return Search_BST(t-\u0026gt;lchild, key, t, p); } else return Search_BST(t-\u0026gt;rchild, key, t, p); } int Insert_BST(BSTree *t, int key) { //二叉排序树的插入，当不存在key时插入并返回0，否则返回1 BSTree p, s; p = NULL; if (Search_BST(*t, key, NULL, \u0026amp;p)) { s = (BSTree)malloc(sizeof(BSTNode)); s-\u0026gt;data = key; s-\u0026gt;lchild = s-\u0026gt;rchild = NULL; if (!p) *t = s; else if (key \u0026lt; p-\u0026gt;data) p-\u0026gt;lchild = s; else p-\u0026gt;rchild = s; return 0; } else return 1; } 14.图的遍历 （1）深度优先 入栈时打印结点信息\n递归：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void DFS(ALGraph *G, int v, int visited[]) { ArcNode *p; int w, i; visited[v] = 1; printf(\u0026#34;%d \u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) DFS(G, w, visited); p = p-\u0026gt;nextarc; } } 非递归：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void DFS1(ALGraph *G, int v) { ArcNode *p; int w, i; int visited[MAX_VERTEX_NUM]; ArcNode *s[MAX_VERTEX_NUM]; //顺序栈 int top = 0; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化 visited[v] = 1; printf(\u0026#34;%2d\u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL || top != 0) { while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) { printf(\u0026#34;%2d\u0026#34;, w); visited[w] = 1; s[++top] = p; p = G-\u0026gt;vertices[w].firstarc; } else p = p-\u0026gt;nextarc; } if (top != 0) { p = s[top--]; p = p-\u0026gt;nextarc; } } } （2）广度优先 出队列时打印结点信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void BFS(ALGraph *G, int v) { ArcNode *p; int w, i; int queue[MAX_VERTEX_NUM], front = 0, rear = 0; // 定义循环队列 int visited[MAX_VERTEX_NUM]; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化 printf(\u0026#34;%2d\u0026#34;, v); //输出被访问顶点的编号 visited[v] = 1; //置已访问标记 rear = (rear + 1) % MAX_VERTEX_NUM; queue[rear] = v; //v进队 while (front != rear) // 队列不空时循环 { front = (front + 1) % MAX_VERTEX_NUM; w = queue[front]; //出队并赋给w p = G-\u0026gt;vertices[w].firstarc; //找w的第一个的邻接点 while (p != NULL) { if (visited[p-\u0026gt;adjvex] == 0) { printf(\u0026#34;%2d\u0026#34;, p-\u0026gt;adjvex); //访问之 visited[p-\u0026gt;adjvex] = 1; rear = (rear + 1) % MAX_VERTEX_NUM; //相邻顶点进队 queue[rear] = p-\u0026gt;adjvex; } p = p-\u0026gt;nextarc; //找下一个邻接顶点 } } } 15.双向冒泡 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void BubbleSort1(int R[], int n) { //双向冒泡 int i, j, lastExchange, lastExchange1, i1, temp; i = n; //i 指示无序序列中最后一个记录的位置 i1 = 1; while (i \u0026gt; i1) { lastExchange = 1; //记录正序最后一次交换发生的位置 lastExchange1 = n; //记录逆序最后一次交换发生的位置 for (j = i1; j \u0026lt; i; j++) if (R[j] \u0026gt; R[j + 1]) { temp = R[j]; R[j] = R[j + 1]; R[j + 1] = temp; //逆序时交换 lastExchange = j; } for (j = lastExchange; j \u0026gt; i1; j--) if (R[j] \u0026lt; R[j - 1]) { temp = R[j]; R[j] = R[j - 1]; R[j - 1] = temp; //逆序时交换 lastExchange1 = j; } i = lastExchange; i1 = lastExchange1; } } ","date":"2021-01-10T15:06:20+08:00","image":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/83667969.webp","permalink":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/","title":"数据结构算法复习"},{"content":"生成随机数 在C语言中，生成随机数可以使用stdlib.h头文件里的rand()来生成，例如：\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(){ int a = rand(); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。\n但是这样生成的随机数每次开启程序都是一样的，则需要使用srand()来重新播种，一般常与\u0026lt;time.h\u0026gt;里的time()函数一起使用。\n1 srand((unsigned)time(NULL)); 连续生成多个随机数 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { int a, i; srand((unsigned)time(NULL)); //使用for循环生成10个随机数 for (i = 0; i \u0026lt; 10; i++) { a = rand(); printf(\u0026#34;%d \u0026#34;, a); } return 0; } 生成指定范围的随机数 想要生成指定范围的随机数，只要进行%运算就好了\n1 2 int a = rand() % 10; //产生0~9的随机数 int a = rand() % 10 + 1; //产生1~10的随机数 连续生成不重复的随机数 这就是本文的重点了ヾ(•ω•`)o （其实就是为了记下这个算法才水了一篇文章）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int *GetRandom(int m) { //根据给定的m生成随机不重复的数组a int i, n, w, t; int *a; n = 2 * m; srand((unsigned int)time(0)); a = (int *)malloc(n * sizeof(int)); for (i = 0; i \u0026lt; n; i++) a[i] = i + 1; for (i = 1; i \u0026lt;= m; i++) { w = rand() % (n - i) + i; t = a[i]; a[i] = a[w]; a[w] = t; } return a; } ","date":"2020-12-22T19:36:53+08:00","image":"https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/84444030.webp","permalink":"https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","title":"C语言生成随机数"},{"content":"基本操作 建立版本库：git init\n查看结果：git status\n查看不同：git diff\n版本回退 查看提交日记：git log\n回退：git reset --hard HEAD^\nHEAD^表示上一个版本，HEAD^^表示前两个版本，HEAD~100表示前100个版本\n恢复：git reflog查看命令历史，确定回到未来的哪个版本\n撤销修改 直接丢弃工作区的修改时，用命令git checkout -- file 已经添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD \u0026lt;file\u0026gt;，第二步按1操作。 上传 1 2 3 4 git remote add origin 仓库链接 #将远程仓库和本地仓库绑定 git add . git commit -m \u0026#34;提交信息\u0026#34; git push -u origin 自己当前的分支名 #-u将本地库和远程库的分支关联，之后可以不加 下载 1 git clone 仓库链接 git clone到当前文件夹\n1 git clone 仓库链接 . 分支管理 创建与合并分支 查看分支：git branch\n创建分支：git branch \u0026lt;name\u0026gt;\n切换分支：git checkout \u0026lt;name\u0026gt;或者git switch \u0026lt;name\u0026gt;\n创建+切换分支：git checkout -b \u0026lt;name\u0026gt;或者git switch -c \u0026lt;name\u0026gt;\n删除分支：git branch -d \u0026lt;name\u0026gt;\n合并某分支到当前分支：git merge \u0026lt;name\u0026gt;\n当Git无法自动合并分支时，就必须首先解决冲突，自己手动修改冲突文件再合并即可。 查看分支合并图：git log --graph 使用非快速模式合并，有commit：git merge --no-ff -m \u0026quot;merge with no-ff\u0026quot; dev Bug分支 需要紧急处理Bug时，可以使用git stash将现在的工作区暂存\n恢复原来的工作区\n恢复但不删除stash内容：git stash apply 手动删除stash内容：git stash drop 恢复且删除stash内容：git stash pop 可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，如：\n1 git stash apply stash@{0} 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick \u0026lt;commit\u0026gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n多人协作 查看远程库信息，使用git remote -v\n从本地推送分支，使用git push origin branch-name\n如果冲突，先git pull抓取远程的新提交，处理好后再push\n在本地创建和远程分支对应的分支：git checkout -b branch-name origin/branch-name\n建立本地分支和远程分支的关联：git branch --set-upstream branch-name origin/branch-name\n将非直线的提交日记变为直线：git rebase\n标签管理 创建标签 新建一个标签：git tag \u0026lt;name\u0026gt;,默认为HEAD，也可以指定一个commit id\n指定标签信息：git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;blablabla...\u0026quot;\n查看所有标签：git tag\n标签管理 推送一个本地标签：git push origin \u0026lt;tagname\u0026gt; 推送全部未推送过的本地标签：git push origin --tags 删除一个本地标签：git tag -d \u0026lt;tagname\u0026gt; 删除一个远程标签：git push origin :refs/tags/\u0026lt;tagname\u0026gt; ","date":"2020-12-16T13:16:45+08:00","image":"https://lbqaq.top/p/git/79008828.webp","permalink":"https://lbqaq.top/p/git/","title":"Git的常用命令"},{"content":"主题相关 FrontMatter 字段含义\n1 2 3 4 5 6 7 8 9 10 11 12 title: 标题 description: 描述 image: 显示的特色图片 comments: 显示 / 隐藏评论区(T/F) license: 文章协议 输入 false 可以隐藏 hidden: 隐藏文章（不在首页，归档等页面显示，但是可以直接通过链接访问） math: 是否加载 KaTeX 脚本 slug: 固定链接 draft: 是否为草稿 categories: 分类 tags: 标签 lastmod: 上次更新时间 MarkDown相关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 我是一级标题 ## 我是二级标题 可对应1-6级标题 *斜体文本* **粗体文本** ***粗斜体文本*** 一行中用三个以上的星号*、减号-、底线_来建立一个分隔线 ~~删除线~~ \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt; 创建脚注格式类似这样 [^JiaoZhu]。 [^JiaoZhu]: 脚注的内容 列表：*、+、-、1. \u0026gt; 区块 [链接文本](网址) 图片在前加! | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 ","date":"2020-12-15T18:02:14+08:00","image":"https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/80228475.webp","permalink":"https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","title":"Blog常用的命令"}]